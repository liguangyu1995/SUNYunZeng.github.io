<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法题:位运算相关]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例1:12输入: [2,2,1]输出: 1示例2:12输入: [4,1,2,1,2]输出: 4思路由于时间复杂度与空间复杂度的限制，这道题目解决办法一定是很巧妙的。答案是采用异或的方法。Java的异或^是位运算的一种，含义是相同的位数置 0 ，相异的位数置 1 。数字本身(相同数字)的异或结果为 0 ，0 与任何数字的异或结果为其本身。Hash Map中的hash码映射到数组位置就采用了异或的方法，(h=key.hashcode())^(h&gt;&gt;16);例如:0000 0000 0000 1011 ^0000 0000 0000 11110000 0000 0000 0100代码12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; int len = nums.length; for(int i=0; i&lt;len; i++)&#123; result = result^nums[i]; &#125; return result; &#125;&#125;汉明距离题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 231.示例：12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。思路先异或运算 ^ 将相同位置不同数字的置为 1 。再通过移位， 与 1 进行 与 &amp; 运算，计算出结果。代码1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x^y; int result = 0; // 计算二进制表示中 1 的数量 while(z&gt;0)&#123; if((z &amp; 1) == 1)&#123; result ++; &#125; z &gt;&gt;= 1; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm-排序算法]]></title>
    <url>%2F2019%2F05%2F27%2FAlgorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[插入排序每次遍历都将对应位置的数字插入到合适的位置，当前位置之前的数据保持排序。代码12345678910111213141516public class InsertionSort &#123; public static int[] sort(int[] arr)&#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr, 0, A, 0, len); int i,j; for (i = 1; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j - 1] &gt; temp; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; return A; &#125;&#125;冒泡排序每次将最大的(或最小的)沉入数组最底层。代码123456789101112131415161718public class BubbleSort &#123; public static int[] sort(int[] arr) &#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr,0, A, 0, len); for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-i; j++) &#123; if(A[j]&gt;A[j+1])&#123; // 无需中介的数值互换方法 A[j] += A[j+1]; A[j+1] = A[j] - A[j+1]; A[j] -= A[j+1]; &#125; &#125; &#125; return A; &#125;&#125;转自知乎]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux终端常用指令]]></title>
    <url>%2F2019%2F05%2F27%2FLinux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令集指令作用pwd打印当前工作目录hostname获取我的计算机的网络名称mkdir创建目录cd更改目录ls列出目录下的文件rmdir删除目录pushdpush directorypopdpop directorycp复制文件或目录mv移动/重命名文件或目录less按页查看文件cat输出整个文件xargs执行参数find查找文件grep查找文件里面的东西man阅读帮助手册aproposfind what man page is appropriateenv查看计算机环境echo输出一些参数export设置一个新的环境变量exit退出终端sudo危险! 拥有超级用户权限!]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题--买卖股票的最佳时机]]></title>
    <url>%2F2019%2F05%2F26%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目1给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例11234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例212345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例3123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路贪心算法，通过计算局部最优，综合多个局部最优结果得到全局最优结果一次循环，只要第二天股票价格比当天高，就买入，否则不买入。计算当天买入跟第二天卖出的利润和，即为结果。并不一定要在最低值买入，在最高点卖出。因为每次低买高卖的累积和等于最低点与最高点之间的收益。代码1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int result = 0; for(int i=0; i&lt;=prices.length-2; i++)&#123; if(prices[i]&lt;prices[i+1])&#123; result += prices[i+1]-prices[i]; &#125; &#125; return result; &#125;&#125;题目链接题目2给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。示例 1：12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.注意 :1230 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000.思路简单DP问题当前的状态 i 共有两种，持有股票与不持有股票持有股票状态可能是当前买入或者前一状态买入收益方程：$buy_{profit}^1=max(buy_{profit}^0,sell_{profit}^1-prices[i])$不持有股票可能是当前卖出或者前一状态卖出收益方程：$sell_{profit}^1=max(sell_{profit}^0,prices[i]+buy_{profit}^1-fee)$代码1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len&lt;2) return 0; //没有stock的收益 int sell_profit = 0; //拥有stock的收益 int buy_profit = -prices[0]; for(int i=1; i&lt;len; i++)&#123; //今天卖了或者之前卖了的收益 sell_profit = Math.max(sell_profit, prices[i]+buy_profit-fee); //今天买了或者之前买了的收益 buy_profit = Math.max(buy_profit, sell_profit-prices[i]); &#125; //卖了股票的收益肯定大于持有股票的收益，因为持有股票是负收益 return sell_profit; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Greedy Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum-Falling-Path-Sum]]></title>
    <url>%2F2019%2F05%2F25%2FMinimum-Falling-Path-Sum%2F</url>
    <content type="text"><![CDATA[下降路径最小和题目细节给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。示例112输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12解释：可能的下降路径有：123[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。提示121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100思路典型的二维动态数组题目。创建一个二维的数组A[row][column]存储结果，每一个位置存储的是第一行到该位置最小的下降路径。一般情况1A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]);前后两列情况12第一列: A[i][j] += min(A[i-1][j],A[i-1][j+1]);最后一列: A[i][j] += min(A[i-1][j-1],A[i-1][j]);Algorithm123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minFallingPathSum(int[][] A) &#123; int row = A.length; int col = A[0].length; if(row==1)&#123; return A[0][0]; &#125; for(int i=1;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; if(j-1&lt;0)&#123; A[i][j] += min(A[i-1][j],A[i-1][j+1]); &#125; else if(j+1&gt;col-1)&#123; A[i][j] += min(A[i-1][j-1],A[i-1][j]); &#125; else&#123; A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]); &#125; &#125; &#125; int result = Integer.MAX_VALUE; for(int i=0;i&lt;col;++i)&#123; if (A[row-1][i] &lt; result) &#123; result = A[row-1][i]; &#125; &#125; return result; &#125; public int min(int a, int b)&#123; return (a&lt;=b?a:b); &#125;&#125;题目链接类似题目]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Third Maximum Number]]></title>
    <url>%2F2019%2F05%2F23%2FAlgorithm-Third-Maximum-Number%2F</url>
    <content type="text"><![CDATA[1. Third Maximum NumberTitle DetailGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).Example 1:123Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:123Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:12Input: [2, 2, 3, 1]Output: 1Explanation:Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum.思路因为要求算法的时间复杂度为O(n)，所以不能用排序的方法。因为只求第三大的数，跟求第一大的数原理类似，只不过注意边界条件。Algorithm1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int thirdMax(int[] nums) &#123; if(nums.length==1) return nums[0]; if(nums.length==2) return Math.max(nums[0], nums[1]); int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; int max3 = Integer.MIN_VALUE; int flag = 0; boolean f = true; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;max1)&#123; max3=max2; max2=max1; max1=nums[i]; ++flag; continue; &#125; if(max1&gt;nums[i] &amp;&amp; nums[i]&gt;max2)&#123; max3=max2; max2=nums[i]; ++flag; continue; &#125; if(max2&gt;nums[i] &amp;&amp; nums[i]&gt;max3)&#123; max3=nums[i]; ++flag; continue; &#125; // 边界条件，如果有多个最小值，则只算一次 if(nums[i]==Integer.MIN_VALUE&amp;&amp;f)&#123; flag++; f = false; continue; &#125; &#125; return (flag&lt;3?max1:max3); &#125;&#125;题目链接2. Smallest Range ITitle DetailGiven an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i].After this process, we have some array B.Return the smallest possible difference between the maximum value of B and the minimum value of B.Example 1:123Input: A = [1], K = 0Output: 0Explanation: B = [1]Example 2:123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8]Example 3:123Input: A = [1,3,6], K = 3Output: 0Explanation: B = [3,3,3] or B = [4,4,4]Note:1231 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 100000 &lt;= K &lt;= 10000思路求出数组最大值与最小值的差值，比较差值与K/2的关系。Algorithm1234567891011121314151617class Solution &#123; public int smallestRangeI(int[] A, int K) &#123; if(A.length==0) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(int i=0; i&lt;A.length; i++)&#123; if(A[i]&lt;min) min = A[i]; if(A[i]&gt;=max) max = A[i]; &#125; int len = max-min; if(len&gt;2*K) return len-2*K; else return 0; &#125;&#125;题目链接3. 数组形式的整数加法题目细节对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。示例1：123输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234示例2：123输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455示例3：123输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021示例4：123输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000提示：12341 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 90 &lt;= K &lt;= 10000如果 A.length &gt; 1，那么 A[0] != 0思路最初思路是字符串转数字，相加后转字符串。但是最终没过，因为数据量太大，不允许。后又通过进位方式实现，老太太的裹脚布。Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int len = A.length; for(int i=len-1; i&gt;=0; --i) &#123; int temp = A[i] + K; if (temp &gt;= 10) &#123; A[i] = temp % 10; K = temp / 10; &#125; else &#123; A[i] = temp; K = temp /10; break; &#125; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (K!=0)&#123; String s = String.valueOf(K); for(char c: s.toCharArray()) result.add(c-'0'); &#125; for (int i : A) &#123; result.add(i); &#125; return result; &#125;&#125;官方答案123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int N = A.length; int cur = K; List&lt;Integer&gt; ans = new ArrayList(); int i = N; while (--i &gt;= 0 || cur &gt; 0) &#123; if (i &gt;= 0) cur += A[i]; ans.add(cur % 10); cur /= 10; &#125; Collections.reverse(ans); return ans; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ArrayList Handbook]]></title>
    <url>%2F2019%2F05%2F21%2FJava-ArrayList-API%2F</url>
    <content type="text"><![CDATA[Java List常用类型类型特征ArrayList随机访问元素快；中间插入与删除元素较慢；操作不是线程安全的LinkedList中间插入与删除操作代价较低，提供优化的顺序访问；随机访问元素慢ArrayList 常用 API方法描述boolean add(E object)再 ArrayList 尾存入对象void add(int location, E object)在 location 添加对象boolean addAll(Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入boolean addAll(int location, Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入locationboolean contains(Object object)是否包对象 objectboolean containsAll(Collection&lt;?&gt; collection)是否包含一个 Collection 对象boolean isEmpty()ArrayList 是否为空E get(int location)获取 location 的对象E set(int location, E object)将某个位置的元素替换成 objectint indexOf(Object object)获取某个对象的位置（顺序遍历第一个）int lastIndexOf(Object object)获取某个对象的位置（逆序遍历第一个）int size()返回 ArrayList 存储的对象数量boolean remove(Object object)删除存储的某个对象E remove(int lcoation)删除位于 location 的对象boolean removeAll(Collection&lt;?&gt; collection)删除存储的某个 Collection 对象Object [] toArray()ArrayList 转数组List&lt;’E’&gt; subList(int start, int end)获取位于 start 与 end 之间的 Listvoid clone()克隆ArrayListvoid clear()移除ArrayList中所有对象Iterator&lt;’E’&gt; iterator()获取该 ArrayList 对应的迭代器对象ArrayList 应用示例ArrayList与数组之间的转换1234567891011121314151617181920// 转数组List&lt;String&gt; list = new ArrayList&lt;&gt;();String[] strings = new String[list.size()];list.toArray(strings);// 或者String[] strings = (String[])list.toArray(new String[list.size()]);// 数组转List// 法1 快速，但是以视图形式返回，无法对数据进行删除及添加操作；// 可用 set() 方法修改元素，但是原始List数据会随之改变String[] s = &#123;"abc", "def", "ghi"&#125;;List&lt;String&gt; list = java.util.Arrays.asList(s);//法 2 慢，但是新生成一个ArrayList，可对List进行操作不会对原对象产生影响List&lt;String&gt; assertList = new ArrayList();Collections.addAll(assertList, strings);ArrayList遍历方式12345678910111213141516171819// 第一种，通过迭代器遍历。即通过Iterator去遍历。Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125;// 第二种，随机访问，通过索引值去遍历。Integer value = null;int size = list.size();for (int i=0; i &lt; size; i++) &#123; value = (Integer)list.get(i); &#125;// 第三种，for循环遍历。Integer value = null;for (Integer integer: list) &#123; value = integer;&#125;初始化12345678910111213141516171819202122232425// 第一种方式 Arrays.asList()方法ArrayList&lt;Integer&gt; list = new Arraylist&lt;&gt;(Arrays.asList(1, 2, 3));// 第二种方法 常规方式ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);//或者List innerList = Arrays.asList(1, 2, 3);list.addAll(innerList);// 第三种方法 使用生成匿名内部类ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123; &#123; add(1); add(2); add(3); &#125;&#125;；// 第四种方式 使用Collection.nCopiesint element = 1;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Collections.nCopies(2, element)); //复制伍分到list中。打印信息由于ArrayList内部实现了toString()方法，所以可以直接打印12ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));System.out.println(list);对于数组信息的打印123456789int[] A = &#123;1, 2, 3&#125;;// 方法一for(Integer i: A)&#123; System.out.println(i);&#125;//方法二System.out.println(Arrays.toString(A));]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--删除最外层的括号]]></title>
    <url>%2F2019%2F05%2F21%2FAlgorithm-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[删除最外层括号题目有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。示例1输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。示例2输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。示例3输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。提示123S.length &lt;= 10000S[i] 为 "(" 或 ")"S 是一个有效括号字符串思路用一个数组模拟栈，发现 “(“ 使其进栈，发现 “)” 时使 “(“ 出栈。注意: 栈底的 “(“ 出栈不输出，当输出字符串中 “(“ 和 “)” 数量不相等时，才输出 “)” 。代码12345678910111213141516171819202122232425262728class Solution &#123; public String removeOuterParentheses(String S) &#123; // list作为栈，记录(数量 List&lt;Character&gt; list = new ArrayList(); StringBuilder bf = new StringBuilder(); int left = 0; // 记录输出的 ( 数量 int right = 0; //记录输出的 ) 数量 for(int i=0; i&lt;S.length(); i++)&#123; char c = S.charAt(i); if(c=='(') list.add(c); if(c==')')&#123; if(list.size()==1&amp;&amp;left==right) list.remove(0); if(list.size()&gt;1)&#123; while(list.size()!=1)&#123; bf.append("("); list.remove(list.size()-1); ++left; &#125; &#125; if(left!=right)&#123; bf.append(")"); ++right; &#125; &#125; &#125; return bf.toString(); &#125;&#125;更Niubility的code：123456789101112131415161718class Solution &#123; public String removeOuterParentheses(String S) &#123; StringBuilder bf = new StringBuilder(); int flag = 0; for(char c: S.toCharArray())&#123; if(c == '(')&#123; ++flag; if(flag == 1) continue; &#125; if(c==')')&#123; --flag; if(flag == 0) continue; &#125; bf.append(c); &#125; return bf.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Minimum path sum]]></title>
    <url>%2F2019%2F05%2F21%2FAlgorithm-Minimum-path-sum%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingMinimum Path SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6思路动态规划 问题。用原来的grid矩阵存储路径和注意三种特殊情况，即矩阵初始位置、顶栏及左侧栏和求解。初始：grid[0][0] = grid[0][0]顶栏：grid[i][j] = grid[i][j-1]左侧栏：grid[i][j] = grid[i-1][j]其余位置：grid[i][j] = min(grid[i][j-1], grid[i-1][j])Algorithm12345678910111213141516171819202122class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; for(int i=0; i&lt;m;i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0&amp;&amp;j==0)&#123; continue; &#125; else if(i==0&amp;&amp;j!=0)&#123; grid[i][j] += grid[i][j-1]; &#125; else if(j==0&amp;&amp;i!=0)&#123; grid[i][j] += grid[i-1][j]; &#125;else&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Partition-array-for-maximum-sum]]></title>
    <url>%2F2019%2F05%2F21%2FAlgorithm-partition-array-for-maximum-sum%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingPartition Array for Maximum SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6思路动态规划 问题。用一个长度为A.length的数组dp维护最终的加和结果。计算思想如下：dp[i] := max sum of A[0] ~ A[i]dp[i] = max{dp[i – k] + max(A[i+1-k:i]) * k}, 1 &lt;= k &lt;= min(i, K)最终返回结果dp[A.length-1]Algorithm1234567891011121314class Solution &#123; public int maxSumAfterPartitioning(int[] A, int K) &#123; int len = A.length; int[] dp = new int[len]; for(int i=0; i&lt;A.length; ++i)&#123; int max_num = A[i]; for(int k=1; k&lt;=K &amp;&amp; i+1-k&gt;=0; ++k)&#123; max_num = Math.max(max_num, A[i+1-k]); dp[i] = Math.max(dp[i], (i-k&gt;=0?dp[i-k]:0) + k*max_num); &#125; &#125; return dp[len-1]; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-for循环那些事]]></title>
    <url>%2F2019%2F05%2F21%2FJava-for%E5%BE%AA%E7%8E%AF%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[Java for循环里面的 i++ 与 ++i在for循环里两者的作用是一样的i++12345for(int i=0; i&lt;5; i++)&#123; System.out.print(i + ",");&#125;&gt;&gt; 0, 1, 2, 3, 4++i12345for(int i=0; i&lt;5; ++i)&#123; System.out.print(i + ",");&#125;&gt;&gt; 0, 1, 2, 3, 4工作原理i++1234&#123; System.out.print(i + ","); i++;&#125;++i1234&#123; System.out.print(i + ","); ++i;&#125;区别在Java里面，i++ 需要开辟新的存储空间用于存储结果，++i 直接在原存储空间中存储结果。故 ++i 在 for 循环里面执行效率要高。 可以作为代码优化的一部分。foreach 与 for循环的效率首先测试数组123456789101112131415161718192021// 测试for循环int[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(int i=0; i&lt;len; i++)&#123; res += A[i];&#125;long endTime = System.nanoTime();System.out.println("for循环: "+(endTime- startTime));// 测试foreachint[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(Integer i: A)&#123; res += i;&#125;long endTime = System.nanoTime();System.out.println("foreach循环: "+(endTime- startTime));结果12for循环: 37143324forecah循环: 75450311可见对于大数组采用for循环效率更高再测试ArrayList12345678910111213141516171819202122ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000); for(int i=0; i&lt;30000000; i++)&#123; list.add(i); &#125;// 测试for循环long startTime = System.nanoTime();int size = list.size();int res = 0;for(int i=0; i&lt;size; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println("for循环: "+(endTime- startTime));// 测试foreachlong startTime = System.nanoTime();int res = 0;for(Integer i: list)&#123; res += i; &#125;long endTime = System.nanoTime();System.out.println("foreach循环: "+(endTime- startTime));结果12for循环: 39368248forecah循环: 42177137可见对于ArrayList仍然是采用for循环效率更高！for循环小技巧关于数组循环嵌套采用小套大。原理跟复制几个大文件跟复制一堆小文件耗时一样。测试12345678910long startTime = System.nanoTime();int res = 0;// 大套小for(int i=0; i&lt;10000000; i++)&#123; for(int j=0; j&lt;100; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println("大套小: "+(endTime- startTime));12345678// 小套大for(int i=0; i&lt;100; i++)&#123; for(int j=0; j&lt;10000000; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println("小套大: "+(endTime- startTime));结果12大套小: 57934223小套大: 4918044数组复制时采用System.arraycopy()方法比for循环复制效率高。System.arraycopy()public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 关于ArrayList在循环时，首先把ArrayList长度size记录下来。测试1234567891011121314151617181920ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000);for(int i=0; i&lt;30000000; i++)&#123; list.add(i);&#125;long startTime = System.nanoTime();//先把长度保存下来int len = list.size();int res = 0;for(int i=0; i&lt;len; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println("保存size(): "+(endTime- startTime));//没有保存size()for(int i=0; i&lt;list.size(); i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println("没有保存size(): "+(endTime- startTime));结果12保存size(): 38973440没有保存size(): 39486862]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java--Map API]]></title>
    <url>%2F2019%2F05%2F19%2FJava-Map-API%2F</url>
    <content type="text"><![CDATA[Java Map常用类型类型特征HashMap根据 HashCode 存储数据，访问速度快。至多允许一条记录键为 null;允许多条记录的值为 null；线程非同步TreeMap保存的记录按照键(key)排序，也可自定义排序规则。用生成的 Iterator 遍历 TreeMap 得到记录是排序后的。不允许记录的键为 null；线程非同步Hashtable用 HashMap 类似,不同的是键值都不允许为 null。 支持线程同步，但写入较慢LinkedHashMap保留记录的插入顺序，生成Iterator遍历顺序与插入顺序一致。遍历比HashMap慢，键值都允许为 null；线程非同步–&gt; HashMap剖析常用 API方法描述Object put(Object k, Object v)存入键值对Object get(Object k)返回键所映射的值；如果不存在该映射则返回 nullboolean containsKey(Object k)是否包含键 kboolean containsKey(Object v)是否包含值 vboolean isEmpty()Map 是否为空int size()返回 Map 的键值对数boolean remove(Object k)如果存在一个键映射关系，则删除此关系(映射关系不存在不会报错)void clear()移除Map中所有映射关系boolean equals(Object obj)比较指定对象于此 Map 是否相等void putAll(Map m)将指定 Map 的映射关系复制到此 Map 中Collection values()以 Collection 形式返回 Map 包含的值Set keySet()以 Set 形式返回 Map 包含的键Set entrySet()以 Set 形式返回 Map 的映射关系List 应用示例123456789Map&lt;Integer, Character&gt; map = new HashMap&lt;&gt;();map.put(1, 'c');map.get(1);for(int i: map.keySet())&#123; System.out.println(map.get(i)); &#125;if(map.containsKey(1))&#123; map.remove(1);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Coin Change]]></title>
    <url>%2F2019%2F05%2F19%2FAlgorithm-Coin-Change%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingCoin ChangeTitle DetailYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.Example 1:123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 1:12Input: coins = [2], amount = 3Output: -1Note:You may assume that you have an infinite number of each kind of coin.思路动态规划 问题。用一个 amount+1长度的数组 bp 维护不同面值金额需要最小的硬币数。bp[0]=0bp[1~amount]=amount+1位置0表示面值为零，最小需要0个硬币，初始为0.位置0~amount假设需要amount个硬币，因硬币类型为int，即代表无解。对于硬币类型coins[i]，寻找j=coins[i] ~j=amount对应面值金额的最小硬币数，即为min(dp[j], dp[j-coins[i]]+1)。dp[j-coins[i]]+1代表放入一个该类型硬币。前提： dp[j-coins[i]]面值的金额不是无解，因为如果无解，那么dp[j-coins[i]]+1对于当前面值金额也是无解。返回dp数组第amount位置数字，即为所求。Algorithm12345678910111213141516171819class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(coins.length==0) return -1; // 创建维护结果的数组 int[] dp=new int[amount+1]; Arrays.fill(dp,1,dp.length,amount+1); for(int i=0; i&lt;coins.length;i++)&#123; // 前提 for(int j=coins[i]; j&lt;=amount;j++)&#123; // 硬币数量统计 if(dp[j-coins[i]]!=amount+1)&#123; dp[j]=Math.min(dp[j], dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=amount+1) return dp[amount]; return -1; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Sqrt(x)]]></title>
    <url>%2F2019%2F05%2F19%2FAlgorithm-Sqrt-x%2F</url>
    <content type="text"><![CDATA[Some Algorithm using Math AlgorithmAlgorithm-1 Sqrt(x)Title detailImplement int sqrt(int x)Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:12Input: 4Output: 2Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.思路牛顿迭代法公式： $x_{k+1} = \lfloor {x_k + \frac n{x_k}} \rfloor / 2$当$k \rightarrow \infty$ 时，${x_{k+1}}^2 \rightarrow n$Algorithm123456789101112class Solution &#123; public int mySqrt(int x) &#123; if(x&lt;=1) return x; long r=x; long t = x/r; while(r&gt;t)&#123; t = x/r; r = (r + t)/2; &#125; return (int)r; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algortthm--Jewels and Stones]]></title>
    <url>%2F2019%2F05%2F19%2FAlgortthm-Jewels-and-Stones%2F</url>
    <content type="text"><![CDATA[Map的应用Jewels and StonesTitle DetailYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.Example 1:12Input: J = "aA", S = "aAAbbbb"Output: 3Example 2:12Input: J = "z", S = "ZZ"Output: 0Note:S and J will consist of letters and have length at most 50.The characters in J are distinct.思路使用Java里面的 Map。key键保存宝石类型，value键保存数量统计。Algorithm1234567891011121314151617181920class Solution &#123; public int numJewelsInStones(String J, String S) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;J.length(); i++)&#123; map.put(J.charAt(i), 0); &#125; for(int i=0; i&lt;S.length();i++)&#123; Character c = S.charAt(i); if(map.get(c)!=null)&#123; Integer freq =map.get(c); map.put(c, freq+1); &#125; &#125; int result = 0; for(Integer value: map.values())&#123; result += value; &#125; return result; &#125;&#125;法2 正则表达式123String a = "[^"+J+"]"; S = S.replaceAll(a, ""); return S.length();Python方法1return sum(S.count(i) for i in J)题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String Relative</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Fast and Slow Pointer]]></title>
    <url>%2F2019%2F05%2F17%2FAlgorithm-Fase-and-Low-Pointer%2F</url>
    <content type="text"><![CDATA[快慢指针的应用判断链表是否存在环Title DetailGiven a linked list, determine if it has a cycle in it.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.Example 1:123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.思路利用快慢指针，快指针每次走两步，慢指针每次走一步。如果快指针能够追上慢指针，则链表存在环。Algorithm1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null || head.next.next==null) return false; ListNode fast = head; ListNode slow = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow)&#123; return true; &#125; &#125; return false; &#125;&#125;题目链接有序数组移除重复数字Title DetailGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 1:12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;思路前提是有序数组，可见排序是很基础且重要的算法！过程：初始，快慢指针指向第一个数字。当快慢指针指向的数字都相同，快指针往前移动一位。当快慢指针指向的数字不相同，慢指针往前移动一位，把快指针指向的数字赋予慢指针，快指针往前移动一位。慢指针移动的 位数+1 即为不同数字的数量。且数组从初始位置到慢指针指向的位置，数字都是排好序的。Algorithm1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int fast=0; int slow=0; while(fast&lt;nums.length)&#123; if(nums[fast]==nums[slow])&#123; fast++; &#125;else&#123; nums[++slow]=nums[fast++]; &#125; &#125; return slow+1; &#125;&#125;图片地址题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Fast and Slow Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Find Common Characters]]></title>
    <url>%2F2019%2F05%2F17%2FAlgorithm-Find-Common-Characters%2F</url>
    <content type="text"><![CDATA[Find Common CharactersTitle detailGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.You may return the answer in any order.Example 112Input: ["bella","label","roller"]Output: ["e","l","l"]Example 212Input: ["cool","lock","cook"]Output: ["c","o"]Note:1231 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 100A[i][j] is a lowercase letter思路统计每个字符串中26个字母的出现次数。每个字符串都出现的字母且统计次数最少的即为结果输出的字符。用int数组0-25位置表示0-26个字母，存储的整数代表出现总次数。Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; commonChars(String[] A) &#123; List&lt;String&gt; list = new ArrayList(); int[] res = new int[26]; for(int i=0; i&lt;A[0].length();i++)&#123; res[A[0].charAt(i) - 'a'] += 1; &#125; for(int i=0; i&lt;A.length;i++)&#123; int[] temp = new int[26]; for(int j=0; j&lt;A[i].length(); j++)&#123; temp[A[i].charAt(j) - 'a'] +=1; &#125; for(int m=0; m&lt;26; m++)&#123; res[m] = Math.min(res[m], temp[m]); &#125; &#125; for(int i=0; i&lt;26; i++)&#123; if(res[i] &gt; 0)&#123; for(int j=0; j&lt;res[i]; j++)&#123; list.add((char)('a'+i)+""); &#125; &#125; &#125; return list; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String Relative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux系统中同步更新我们的Github博客]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[原理介绍类似于版本管理，我们把hexo博客文件系统在Github上建立一个分支，通过管理分支提交最新的博客文件系统，保证我们博客框架的更新。然后我们基于最新的博客框架，撰写文章，进行Github Pages网页的更新，即我们博客内容的更新。创建两个分支，一个用于存放博客静态资源，一个用于备份博客的部署文件。参考资料前期准备一台Linux系统的电脑（我的linux系统是Ubuntu 18.04.2 LTS）安装node.js 及 npm安装 ssh安装 git按照我们前面教程搭建好的博客创建Github 博客仓库分支首先在我们搭建Hexo博客的电脑上，创建我们博客仓库在Github上的分支。打开我们的博客仓库，选择setting：选择Branches,创建博客仓库的Hexo分支，并将其设置为默认分支。将该仓库克融到本地，并把本地博客的(所有Hexo目录下文件)全部拷贝进username.github.io文件目录中去。 然后把更新后的博客部署文件提交到Github的hexo分支中。依次执行123git add .git commit -m &apos;some info&apos;git push注意事项：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后我们的博客备份分支就创建好了。Linux 部署项目安装Node.js 与 npm安装gitlinux与Github建立联系把我们创建好的博客备份仓库clone到本机（linux）4.1 在要保存的位置执行语句 git clone git@github.com:your.github.io/your.github.io.git4.2 进入username.github.io目录，执行npm install (由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以要安装依赖)安装hexo插件sudo npm install hexo-cli -g撰写我们的博客文章，然后依次执行下面指令，更新我们的博客备份。12345hexo cleanhexo ggit add .git commit -m &apos;some info&apos;git push更新博客界面hexo d注意事项1. 每当撰写博客前，先 git pull，获取最新的博客备份。2. 写完博客后，先依次执行hexo clean 、 hexo g 、 git add . 、 git commit -m &#39;some info 、 git push&#39;进行博客备份部署文件更新。3. 最后执行 hexo d部署博客界面，实现博客更新。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows环境下Hexo+Github搭建个人博客教程]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言你是否也想拥有属于自己的博客？是否也想拥有跟我一样的博客空间？如果心动了，就赶紧往下看吧！教程炒鸡简单，炒鸡详细，而且博客搭建完全是Free of Charge!原理Github PagesGithub不仅可以让我们把代码托管在平台上，而且允许我们利用Github的服务器部署自定义网页对我们的项目作简介。这个网页就被称为Github Pages。这是我们可以利用Github搭建免费博客的基础啦~HexoHexo是一款轻量但高逼格的搭建博客快速工具，它是基于Node.js开发的。而Node.js…好了，扯远了…有兴趣的童鞋可以出门左转自己百度…准备知道了大致的原理，我们首先需要准备搭建博客的材料。如下：1. 一台windows系统的电脑2. 一个Github账号3. 安装Node.js4. 安装Git5. 安装Hexo开始申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)假设我们都有了Github账号，这是首先在右上角点击“+”号，选择New repository注意 仓库名一定是”你的Github用户名”+github.io !!!之后为我们的项目添加一个说明Pages！建好的项目顶部最右边有个Setting按钮，点击进入配置界面，下滑界面，直到看到Github Pages，这时你发现竟然自动生成了一个说明网页！因为Github说明网页的默认地址就是“你的Github用户名”+github.io，其它说明网页都是基于该地址的。Ok! 到此为止，Gihub Pages的部分就结束了。搭建Hexo，把Github Pages修改为自己的博客界面！安装Git以及Node.js！因为我们需要通过Git把我们的Hexo生成的网页提交到Github pages上，而Node.js是我们Hexo插件运行的基础！下载安装Windows版Git下载安装Node.js验证：“Win”+R打开运行界面，输入”cmd”打开命令行窗口。是否安装Git:输入git version出现版本信息：1git version 2.19.1.windows.1是否安装Node.js:输入node -v出现版本信息：1v8.12.0安装及部署Hexo首先创建一个文件夹，用来放置我们的Hexo。然后进入我们的文件夹，例如我们文件夹路径为D:\blog则在终端依次输入并执行D: 、 cd blog 进入文件夹打开命令终端，利用Node.js的包管理器npm安装Hexo:npm install hexo-cli -g输入hexo -v验证是否安装成功输入hexo init初始化该文件夹输入npm install安装需要的组件输入npm g生成静态文件输入npm s启动服务器，现在在浏览器输入http://localhost:4000/打开我们的博客界面！是不是有点鸡冻！别急，我们还需要把页面推送到Github Pages上，步骤如下：1. 设置Git的user name和email在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;2. SSH 授权打开git bash，输入ssh-keygen -t rsa, 接着回车三下。最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去3. 上传项目首先用IDE(我用的是WebStorm)打开我们的Hexo文件夹，发现它的文档目录是这样的：12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- public|-- themes|-- .gitignore_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 –save 保存进去。scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;layout(布局)&gt; &lt;’title’&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用hexo clean 清除 db.json 和 public 文件夹下的所有文件。themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。打开配置文档_config.yml，修改deploy值（在末尾）:1234deploy: type: git repo: git@github.com:SUNYunZeng/SUNYunZeng.github.io.git branch: master安装在git上部署文章的扩展npm install hexo-deployer-git --save打开终端并进入到Hexo文件系统中，创建一篇新博客hexo new post &quot;博客名&quot;这时文件夹source/_posts文件夹里会出现博客名.md的博客文章源文件文件是markdown格式，书写方法有一套规范，下篇博客会讲到。PS:非常简单啦~编辑好博客内容后，一顿滚键盘，依次执行以下命令：hexo g 生成静态文件hexo d 部署到Github Pages就这样，你的第一篇博客就上传啦！更换Hexo主题由于默认的博客主题可能不能满足大家的需求，所以再提一下更换主题的方法。首先到Hexo官网中选择一款喜欢的主题这里我以我博客采用的主题为例，我采用的pure主题首先在Hexo系统文件夹中打开终端，然后输入git clone https://github.com/cofess/hexo-theme-pure.git themes/pure之后在系统目录theme文件夹下你会发现多出了pure命名的一个文件夹，这就是我们主题保存的位置,其中pure文件夹下的config.yml文件就是我们博客的配置文件，在里面可以自己对博客界面进行个性化配置，详情请参看网址在我们的Hexo系统配置文件config.yml中，修改theme为我们的pure主题1theme: pure然后进入文件夹 cd themes/pure把主题提交git pull重新生成博客静态文件，然后部署到Github Pageshexo ghexo d当当~我们的个性化博客就搭建完毕啦！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
</search>
