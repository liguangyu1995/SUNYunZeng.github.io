<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指Offer：二叉树和为某一值的路径]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)思路 + 代码递归求解，左右子树分别遍历（深度优先）。遍历终止条件为节点为null或者是叶子节点且和为目标值。否则回退列表，寻找更短的路径。1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res; private ArrayList&lt;Integer&gt; list; public Solution()&#123; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); list = new ArrayList&lt;Integer&gt;(); &#125; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root==null) return res; target = target - root.val; list.add(root.val); if(target==0&amp;&amp;root.right==null&amp;&amp;root.left==null)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); &#125; FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return res; &#125;&#125;]]></content>
      <categories>
        <category>Algorihm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer：二叉搜索树的后序遍历序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。思路 + 代码二叉搜索树的左子树所有节点小于根节点，右子树的所有节点大于根节点。后序遍历是先访问左子树，后访问右子树。因此，根节点永远在序列的最后位置。找到根节点数值后，根据前面节点数值与根节点的大小关系，找到左右子树的分割位置，递归求解。123456789101112131415161718192021222324252627public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; // 初始条件判断 if(sequence==null || sequence.length==0) return false; // 调用重写的辅助函数 return VerifySquenceOfBST(sequence, 0, sequence.length-1); &#125; private boolean VerifySquenceOfBST(int[] sequence, int start, int end)&#123; // 递归截止条件 if(start &gt;= end) return true; // 寻找分割节点 int currentCutIndex = start; while(sequence[currentCutIndex]&lt;sequence[end])&#123; currentCutIndex++; &#125; // 如果右子树存在小于根节点的节点，则该序列不是二叉搜索树的后序遍历 for(int i=currentCutIndex; i&lt;end; i++)&#123; if(sequence[i]&lt;sequence[end]) return false; &#125; // 左右子树递归寻找 return VerifySquenceOfBST(sequence, start, currentCutIndex-1) &amp;&amp; VerifySquenceOfBST(sequence, currentCutIndex, end-1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer：从上往下打印二叉树]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目从上往下打印出二叉树的每个节点，同层节点从左至右打印。思路 + 代码二叉树的层次遍历，用队列保存同一层次的树节点，然后依次遍历。类似题目http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/1234567891011121314151617181920212223242526272829303132333435import java.util.*;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root==null) return list; queue.add(root); while(!queue.isEmpty())&#123; int len = queue.size(); for(int i=0; i&lt;len; i++)&#123; root = queue.remove(); list.add(root.val); if(root.left!=null) queue.add(root.left); if(root.right!=null) queue.add(root.right); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer: 顺时针打印矩阵]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.思路 + 代码制造一个子函数，用来打印每一层。函数接收的参数是需要打印的行数跟列数，以及起始打印的位置（都是 n * n）。特殊情况处理：打印行列错误、数组为空、单行或单列数组1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); printArr(matrix.length, matrix[0].length, 0, matrix, res); return res; &#125; private void printArr(int I,int J,int s,int[][] arr, ArrayList&lt;Integer&gt; res)&#123; if(I&lt;=0 || J&lt;=0 || arr==null || arr.length==0 || arr[0].length==0) return; if(I==1)&#123; for(int i=0; i&lt;J;i++)&#123; res.add(arr[s][s+i]); &#125; return; &#125; if(J==1)&#123; for(int i=0; i&lt;I;i++)&#123; res.add(arr[s+i][s]); &#125; return; &#125; for(int i=0; i&lt;J;i++)&#123; res.add(arr[s][s+i]); &#125; for(int i=1;i&lt;I;i++)&#123; res.add(arr[s+i][s+J-1]); &#125; for(int i=J-1; i&gt;0; i--)&#123; res.add(arr[s+I-1][s+i-1]); &#125; for(int i=I-1; i&gt;1; i--)&#123; res.add(arr[s+i-1][s]); &#125; printArr(I-2,J-2,s+1,arr, res); return; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 树的子结构]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）思路 + 代码涉及到二叉树相关的问题，首先想到递归。由于二叉树是否为子树的判断，涉及到是否为 null的判断，因此需要建立子判定函数，避免空树情况产生干扰。判断条件：如果当前树节点与待判断树节点数值相同，则继续进行左右树的数值判断。直到两树中某一树为空。否则分别对当前树的子树与右树跟带判断子树进行判定。123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null) return false; // 不能只判断当前第一个节点，如果首节点是伪相等，就是错误的 return isSubtree(root1, root2)|| isSubtree(root1.left, root2)||isSubtree(root1.right, root2); &#125; private boolean isSubtree(TreeNode root1,TreeNode root2)&#123; if(root2==null) return true; if(root1==null) return false; if(root1.val==root2.val)&#123; return (isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right)); &#125;else&#123; return (isSubtree(root1.left, root2) || isSubtree(root1.right, root2)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式: Java泛型]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[不要使用原始类型原始类型是Java(5之前)的历史遗留问题，之前集合对于类型在编译期间不进行检查，而在运行期进行类型检查。这导致问题的定位困难，降低效率。此后采用泛型解决这个问题，保证在编译期间进行检查。例如List 类型是原始类型，而List&lt; E &gt;是泛型类型，指定了参数化类型为 E 类型。List表明可以存储任何类型的对象，List&lt; E &gt; 是它的子类型，可以转化为List类型，但是丧失了安全性检查；而List&lt; E &gt; 却不是List&lt; Object &gt; 的子类型。List&lt; Object &gt; 只能是List&lt; Object &gt; 。如果想实现类似于List等存储任何类型的对象， 可以利用无限制通配符类型（unbounded wildcard types）表示泛型类型，即List&lt; ? &gt; 。泛型的几个注意点：1. 类字面常量不允许使用泛型数组String[].class、基本类型int.class、不带参数化类型的类List.class可以使用。2. instanceof 只能对无限制通配符类型的参数化类型的类或接口使用。123if(o instanceof Set)&#123; Set&lt;?&gt; s = (Set&lt;?&gt;) o;&#125;术语中文含义举例Parameterized type参数化类型List&lt; String &gt;Actual type parameter实际类型参数StringGeneric type泛型类型List&lt; E &gt;Formal type parameter形式类型参数EUnbounded wildcard type无限制通配符类型List&lt;?&gt;Raw type原始类型ListBounded type parameter限制类型参数&lt; E extends Number&gt;Recursive type bound递归类型限制&lt; T extends Comparable&lt; T &gt;&gt;Bounded wildcard type限制通配符类型List&lt;? extends Number&gt;Generic method泛型方法static &lt; E &gt; List&lt; E &gt; asList(E[] a)Type token类型令牌String.class列表优先于数组即List优先于数组。因为数组是协变类型的，所以下面代码编译期间是合法的, 但是运行期间是违法的。12Object[] o = new String[1];o[1] = 1;尽量使用列表来在编译过程中就确保安全性，虽然会损失掉一定的性能与简洁性。下面代码运行有警告，因为java程序中的泛型信息在编译后会进行擦除（这意味着它们只在编译时执行类型约束，并在运行时丢弃它们的元素类型信息），为了与Java5之前的代码共存。因此实际在运行中虚拟机并不知道返回数组具体类型，返回的类型是顶层类 Object, 在强制转换为T[]时会有问题。123public Chooser(Collection&lt;T&gt; choices) &#123; choiceArray = (T[]) choices.toArray();&#125;因此最好采用List替代。123public Chooser(Collection&lt;T&gt; choices) &#123; choiceList = new ArrayList&lt;&gt;(choices);&#125;优先考虑泛型一个简单实现的栈，原始版本 vs 添加泛型版本。原始版本12345678910111213141516171819202122232425262728293031class Stack&#123; // 存储数量 private int size = 0; // 默认长度 private static final int DEFAULT_INITIAL_CAPACITY; // 元素桶 private Object[] elements; public Stack&#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size==0) throw new EmptyStackException(); Object res = elements[--size]; // 清除无用的引用 elements[size] = null; return res; &#125; private ensureCapacity()&#123; if(elements.length==size) elements = Arrays.copyOf(elements, size*2+1); &#125;&#125;这样的版本Stack每次取出元素都要进行强制类型转换。泛型版本1234567891011121314151617181920212223242526272829303132333435363738class Stack&lt;E&gt;&#123; // 存储数量 private int size = 0; // 默认长度 private static final int DEFAULT_INITIAL_CAPACITY; // 元素桶 private E[] elements; // 确保强制转换是安全的。有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害 @SuppressWarnings("unchecked") public Stack()&#123; // 强制类型转换，因为无法创建泛型数组 new E[DEFAULT_INITIAL_CAPACITY]; elements = (E)new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(E e)&#123; ensureCapacity(); elements[size++] = e; &#125; public E pop()&#123; if(size==0) throw new EmptyStackException(); E res = elements[--size]; // 清除无用的引用 elements[size] = null; return res; &#125; public isEmpty()&#123; return size==0; &#125; private ensureCapacity()&#123; if(elements.length==size) elements = Arrays.copyOf(elements, size*2+1); &#125;&#125;考虑泛型方法声明类型参数的类型参数列表位于方法的修饰符和返回类型之间。123456// Generic methodpublic static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(s1); result.addAll(s2); return result;&#125;限定通配符增加API灵活性PECS代表： producer-extends，consumer-super。如果一个参数化类型代表一个 T 生产者，使用 &lt;? extends T&gt;；如果它代表 T 消费者，则使用 &lt;? super T&gt;。 在我们的 Stack 示例中，pushAll 方法的 src 参数生成栈使用的 E 实例，因此 src 的合适类型为 Iterable&lt;? extends E&gt;；popAll 方法的 dst 参数消费 Stack 中的 E 实例，因此 dst 的合适类型是 Collection &lt;? super E&gt;。所有 Comparable 和 Comparator 都是消费者。可变参数与泛型可变参数: 类型 T 加…构成，例如：12345public void test(String ... strs)&#123; for(String s: strs)&#123; System.out.println(s); &#125;&#125;Java用一个数组来保存变长的参数，但是可变参数的类型与泛型要注意混淆。考虑一个例子：123456public &lt;T&gt; T[] toArray(T ... t)&#123; return t;&#125;// testString[] strs = toArray("abc", "def");上面的会报错，因为泛型传递的是非具体类型，也就是编译时的类型信息要多与运行时信息（由于擦除），因此可变参数的数组用 Object类型存储，当Object转为String时，会报错ClassCastException。另一个例子：123456public void test(List&lt;String&gt;... stringList)&#123; Object[] obj = stringList; List&lt;Integer&gt; intList = List.of(15); // List.of生成一个不可变列表（不能用set设置数值） obj[0] = intList; // 发成堆污染 String s = obj[0].get(0); // 出现警告，编译没错，但是运行报错 ClassCastException。&#125;可见，可变参数中混淆了泛型，还是很容易产生类型转换的不安全性，但是Java并没有因此抛弃，而在Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)中大量使用，说明只要保证可变参数中的泛型是安全的（以下三点），就可：1. 可变参数数组不会存储跟修改。2. 可变参数数组的引用不会转义。3. 可变参数数组仅用来为方法传递可变参数。当然，可变参数数组可以变为列表，但同时降低了一定性能与可读性。123456public &lt;T&gt; List&lt;T&gt; toArray(List&lt;T&gt; t)&#123; return t;&#125;// testList&lt;String&gt; strs = toArray("abc", "def");可变参数的另一个用法因为可变参数数组的产生都会产生性能损耗，因此当 95％ 的调用是三个或更少的参数的方法，那么声明该方法的五个重载。123456789public void foo() &#123; &#125;public void foo(int a1) &#123; &#125;public void foo(int a1, int a2) &#123; &#125;public void foo(int a1, int a2, int a3) &#123; &#125;public void foo(int a1, int a2, int a3, int... rest) &#123; &#125;异构容器泛型中规定的可变类型数量总是有限的，例如单个类型约束&lt; T &gt;以及Map的&lt; K , V&gt;。异构容器可以通过参数化键的方式，实现泛型设定数量的灵活性。例如在数据库查询中任意列值。下面是一个异构容器的示例：1234567891011121314151617public class Favorites&#123; // 用Class&lt;T&gt;存放未知的键 Map&lt;Class&lt;?&gt;, T&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance)&#123; favorites.put(Object.requireNonNull(type), type.cast(instance)); &#125; public &lt;T&gt; T get(Class&lt;T&gt; type)&#123; return type.cast(favorites.get(type)); &#125;&#125;public static void main(String[] args) &#123; Favorites f = new Favorites(); f.put(String.class, "syz"); f.put(Integer.class, 12); f,get(String.class);&#125;可以使用 ColumnClass 对象作为此类型安全异构容器的键。 以这种方式使用的 Class 对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的 DatabaseRow 类型和一个泛型类型 Column&lt; T &gt; 作为其键。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class文件长什么样]]></title>
    <url>%2FClass%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[定义Class文件是Java语言实现跨平台的原材料，JVM(Java Vritual Machine)是实现跨平台的机器。机器 + 原材料 = 跨平台。不同的平台有自己的JVM，但是Class文件是一样的。Class文件由java文件编译产生。Class文件是由8位字节构成的二进制流，用类似于C语言结构体的伪结构来存储数据。Class文件由无符号数和表组成。无符号数用u1 u2 u4 u8来表示1 2 4 8个字节的无符号数。它用来表示数量值、数值、索引引用、按照UTF-8编码的字符串。表是一种特殊的数据结构，它由表及无符号数组成，习惯表以_info结尾。Class文件就是一张表，用来描述唯一确定的类或接口。下面是从《深入了解JVM》中摘的Class文件的表结构。图1 Class表结构进入Class这张表首先我们写一个简单的类，叫做HelloClass。1234567public class HelloClass &#123; private int name; public int addName() &#123; return name + 1; &#125;&#125;然后编译生成 HelloClass.class文件，我们用文本编辑器打开它，如下：图2 编译后的class文件最复杂的结构，常量池由于Class本身就是一张表，而常量池是嵌套在Class中的表，其结构最复杂。常量池用来存储类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。如图2所示，前四个字节的无符号数 u4表示 Magic Number，是用来区分文件格式的，这样比文件名后缀更安全。CAFE BABE是Java的Class文件的魔数，很魔性。接着的u4是版本号，即图1中的 00 00 00 34。然后就是常量池了，先看常量池的项目类型：图3 常量池的项目类型每个项目类型的第一位都是项目标志，唯一标识该类型。常量池开始是容量说明，u2类型，及 00 16，表示容量为 16+6=22-1=21，因为常量池容量计算是从1开始，0表示为空。之后一个u1类型是常量类型标志符，为 0A，为 10。查找图2表示该常量为 CONSTANT_Methodref_info，由两个u2无符号类型组成，第一个指向 00 04 即第4个常量，为 CONSTANT_Class_info 类型；第二个指向 00 12 即第 16+2=18 个常量， 为 CONSTANT_NameAndType 类型。依次类推，直到翻译完常量池。我们可以通过javap工具的 -verbose 输出字节码内容，如下：访问标志访问标志(access_flags)用于识别类和接口的访问信息，诸如是否是public及抽象类等。常量池后面是访问标志。不同访问标志求 | 运算得到。类索引、父类索引、接口索引分别是一个 u2、u2和一组u2，因为java单继承，可实现多个接口。各自指向一个 CONSTANT_Class_info 的类描述常量。字段表集合字段表(field_info)用来描述接口或类中声明的变量，字段包括类级别变量以及实例级别变量。但不包括方法内部声明的局部变量。字段需要用访问标志描述，包括作用域(public、protected、default、private)、实例变量还是类变量(static)、是否为final、并发可见性(volatile)、是否可序列化(transient)、类型(基本类型、对象及数组)以及字段名称。字段表的结果除了字段描述，还有字段的简单名称 name_index 及方法的描述符 discriptor_index、属性表统计 attributes_count 及属性表 attributes。字段的简单名称及方法描述符都是对常量池引用。描述符是用来描述字段与方法的类型与返回参数的。基本数据类型用相应大写字母表示，对象类型用大写字母 L加对象全限定名表示。其中数组类型用前面 [加类型表示，如 String[][],就表示为 [[Ljava/lang/String;。描述方法时，先参数列表，后返回类型。如 int i(), 表示为 （）I方法表集合与字段表类似,只不过并发可见性(volatile)、是否可序列化(transient)不能修饰方法。方法中的代码描述，由编译器编译成字节指令后，存放在属性表attributes 的 Code属性里。属性表属性表(attributes_info)在Class文件、属性表与方法表内都有出现，用于描述场景特殊信息。属性表其它数据项目严格要求的顺序、长度和内容，它不再要求各个属性有严格的顺序，且只要不与已有属性名重复，任何实现的编译器都可向属性表中写入自己定义的属性信息；Java虚拟机在运行时会忽略掉不认识的属性。《Java虚拟机规范(Java SE 7)》中，预定义的属性为：其中每个属性表首先根据 attributes_name_index 去常量池引用 CONSTANT_Class_info 类型的名称，然后用一个 u4 长度的属性说明属性表占用的长度 attribute_length 即可。属性表中描述的信息单位是 u1，共attribute_length个。属性表的结构如下：Code属性java程序方法体内的代码通过编译成字节码后，存在Code属性中。Code属性存储在方法表的属性表集合中。Code属性是Class文件中最重要的属性，是对代码的描述。其它信息可以看做是对元数据（类型、字段、方法及其他信息）的描述。Code的属性表如下：各部分的含义如下：类型名称含义u2attributes_name_index指向 CONSTANT_Class_info 常量索引，表示该属性表名称u1attribute_length属性表长度。由于属性名称索引 u2 加长属性名长度 u4，所以属性表长度为整个属性表长度减去 6 字节。u2max_stack栈的最大深度。Java虚拟机为该方法体分配栈针的操作栈深度。u2max_locals局部变量的最大存储空间。方法参数、显示异常处理的参数及方法体中定义的局部变量都需用局部变量表表示。局部变量中统计单位是 Slot。小于32位(boolean、short、char、int、float、returnAddress)的变量用一个 Slot 表示，double与long两个64位的用两个Slot表示。u4code_length字节码长度。实际是 u2 长度，即16个字节， 65535条字节码，超过改长度虚拟机将拒绝编译。u1code一些类的字节码指令，用于描述编译后的方法体内方法。u2exception_table_lenght显示异常处理表长度。excessption_infoexception_table显示异常处理表u2attributes_count属性表数量attributes_infoattributes属性表参考深入理解java虚拟机]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 打印1到最大的n位数]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer-%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目打印1到最大的n位数。示例：123输入 n = 1打印 1 2 3 4 5 6 7 8 9思路 + 代码常规操作是暴力循环打印 1 到 n 位数，但是大数问题，存在数值溢出。采用字符串或者数组存储中间结果。思路1用一个 长度为 n 的数组存储，然后分别在最后一位计算，每次加一，逢十进一。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class PrintToNNumber &#123; private static boolean increment(int[] nums) &#123; if(nums==null || nums.length==0) return false; // 相加是否大于10 int overflow = 0; int len = nums.length; for (int i = len - 1; i &gt;= 0; i--) &#123; int nSum = overflow + nums[i]; // 只在最后一位加 if(i==len-1)&#123; nSum++; &#125; if (nSum &lt; 10) &#123; nums[i] = nSum; return true; &#125; // &gt;= 10 // 超出范围 if(i==0)&#123; return false; &#125; nums[i] = 0; overflow = 1; &#125; return false; &#125; // 清楚掉数组前面的零 public static void printArray(int[] nums) &#123; int len = nums.length; boolean isZero = true; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]!=0) isZero = false; if (!isZero) &#123; System.out.print(nums[i]); &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int n = 3; int[] nums = new int[n]; while (increment(nums))&#123; printArray(nums); &#125; &#125;&#125;思路2使用递归方法，递归到组后一位，然后依次往前打印。12345678910111213141516private static void recursive(int[] nums, int index) &#123; if (nums.length == index) &#123; printArray(nums); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; nums[index] = i; recursive(nums, index+1); &#125; &#125;public static void main(String[] args) &#123; int n = 3; int[] nums = new int[n]; recursive(nums, 0); &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15.三数之和]]></title>
    <url>%2FLeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]]思路+代码先排序，然后三数之和等于零必定有 1 到 2 个小于零， 1 到 2 个大于零。然后我们采用双指针，先固定最小的一个数（负值）；然后双指针再后面区间寻找两个数，与前面数相加等于零。注意：因为不能包含重复三元组，在遍历过程中注意去重。保证每次遍历的数字与前面不一样即可（因为排序了）。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 排序求解 Arrays.sort(nums); // 循环求解 int len = nums.length; for(int i=0; i&lt;len; i++)&#123; // 此时没有满足条件的情况 if(nums[i]&gt;0) break; // 避免重复计算 if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; int j=i+1; int k=len-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==-nums[i])&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[k]); res.add(list); // 跳过重复的数字 while(j&lt;k&amp;&amp;nums[j]==nums[j+1])&#123; j++; &#125; while(j&lt;k&amp;&amp;nums[k]==nums[k-1])&#123; k--; &#125; j++; k--; &#125;else if(nums[j]+nums[k]&lt;-nums[i])&#123; // 左边负值大了 j++; &#125;else&#123; // 右边正值大了 k--; &#125; &#125; &#125; return res; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 674.最长连续子序列]]></title>
    <url>%2FLeetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目给定一个未经排序的整数数组，找到最长且连续的的递增序列。示例1：1234输入: [1,3,5,4,7]输出: 3解释: 最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。示例2：123输入: [2,2,2,2,2]输出: 1解释: 最长连续递增序列是 [2], 长度为1。注意：数组长度不会超过10000。思路 + 代码思路1我的思路，用一个栈进行递增子序列长度的检查，用res缓存结果。12345678910111213141516171819class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int res = 1; int len = nums.length; s.push(nums[0]); for(int i=1; i&lt;len; i++)&#123; if(nums[i]&lt;=nums[i-1])&#123; res = Math.max(res, s.size()); s.clear(); &#125; s.push(nums[i]); &#125; res = Math.max(res, s.size()); return res; &#125;&#125;思路2动态规划，用一个长度为n的数值维度维护每个位置的最大长度，然后取其中最大值。123456789101112131415161718class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; int res = 1; int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for(int i=1; i&lt;len; ++i)&#123; if(nums[i]&gt;nums[i-1])&#123; dp[i] += dp[i-1]; res = Math.max(dp[i], res); &#125; &#125; return res; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式：Java类和接口]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[使类与成员可访问性最小成员（类、接口、方法、字段）的访问级别private —— 该成员只能在声明它的顶级类内访问。package-private —— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。protected —— 成员可以从被声明的类的子类中访问（会受一些限制 [JLS, 6.6.2]），以及它声明的包中的任何类。public —— 该成员可以从任何地方被访问。公共类的实例字段很少情况下采用 public 修饰如果需要调用私有成员，就写一个方法。12345private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final Thing[] values() &#123; return PRIVATE_VALUES.clone();&#125;公共类中使用访问方法而不是访问属性虽然包内访问权限，如果只包内可见是可行的，也可以，同时可以避免视觉混乱，但是不提倡这样做。12345// Degenerate classes like this should not be public!class Point &#123; public double x; public double y;&#125;提供提供方法与设置方法12345678910111213141516171819// Encapsulation of data by accessor methods and mutatorsclass Point &#123; private double x; private double y; public Point(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setX(double x) &#123; this.x = x; &#125; public void setY(double y) &#123; this.y = y; &#125;&#125;不变类不变类中所有实例的信息在生命周期中都是固定的，因此是安全可靠的。不变类的设计规则不要提供修改对象状态的方法 （也称为 mutators）。确保这个类不能被继承。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。把所有属性设置为 final。 通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为。把所有的属性设置为 private。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共 final 属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示。确保对任何可变组件的互斥访问。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法中进行防御性拷贝。多使用组合而不是继承如果父类不是为了继承而专门设计，那么后面父类的修改可能会导致子类产生严重的bug。明智的方法是多使用组合composition。即在类内部使用其它类的引用。一个新类由一系列现有类组成，新类的方法通过调用现有类的方法获取结果，成为转发 (farwarding)。继承需要深思熟虑还要详细的设计文档测试为继承而设计的类的唯一方法是编写子类。构造方法绝不能直接或间接调用可重写的方法。For example:12345678910111213141516171819202122232425262728public class Super &#123; // Broken - constructor invokes an overridable method public Super() &#123; overrideMe(); &#125; public void overrideMe() &#123; &#125;&#125;public final class Sub extends Super &#123; // Blank final, set by constructor private final Instant instant; Sub() &#123; instant = Instant.now(); &#125; // Overriding method invoked by superclass constructor @Override public void overrideMe() &#123; System.out.println(instant); &#125; public static void main(String[] args) &#123; Sub sub = new Sub(); sub.overrideMe(); &#125;&#125;上述子类由于重写了方法，调用父类时 instant 成员没有指向任何一个对象，因此有问题。专门为了继承而设计类是一件很辛苦的工作。你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。为了允许其他人能编写出高效的子类，还你必须导出一个或者多个受保护的方法。除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。接口优先抽象类抽象类的实现只有继承，限制了混合类型的定义。同时，对于非层次的类级关系，想要为类添加额外的功能，接口是一个很好的方法。骨架抽象类，首先是一个抽象类，然后该抽象类实现了一个接口的基本方法，形成默认的方法实现，提供基础的功能。用户可以自由的选择是选择继承该抽象类还是直接实现该抽象类实现的接口，从而保证灵活性。骨架抽象类的例子：AbstractList、AbstractSet等。例子：12345678910111213141516171819202122232425262728293031323334// Skeletal implementation classpublic abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // Entries in a modifiable map must override this method @Override public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; // Implements the general contract of Map.Entry.equals @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue()); &#125; // Implements the general contract of Map.Entry.hashCode @Override public int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; @Override public String toString() &#123; return getKey() + "=" + getValue(); &#125;&#125;接口用户定义类型层次类优先于标签类标签类：是一个类，该类的实例根据构造方法传入标签的不同而不同。问题：代码可读性差，扩展性差，且内存负担大，因为类实例保存很多不属于它本身的字段。层次类：即在顶层实现一个抽象类，该抽象类将属于公共的方法、字段及依赖于标签值的方法包括起来，提供实现样板。然后根据需求依次实现不同的子类，每个子类实现各自的方法。12345678910111213141516171819202122232425262728293031323334353637383940// 标签类// Tagged class - vastly inferior to a class hierarchy!class Figure &#123; enum Shape &#123; RECTANGLE, CIRCLE &#125;; // Tag field - the shape of this figure final Shape shape; // These fields are used only if shape is RECTANGLE double length; double width; // This field is used only if shape is CIRCLE double radius; // Constructor for circle Figure(double radius) &#123; shape = Shape.CIRCLE; this.radius = radius; &#125; // Constructor for rectangle Figure(double length, double width) &#123; shape = Shape.RECTANGLE; this.length = length; this.width = width; &#125; double area() &#123; switch(shape) &#123; case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(shape); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930// 层次类// Class hierarchy replacement for a tagged classabstract class Figure &#123; abstract double area();&#125;class Circle extends Figure &#123; final double radius; Circle(double radius) &#123; this.radius = radius; &#125; @Override double area() &#123; return Math.PI * (radius * radius); &#125;&#125;class Rectangle extends Figure &#123; final double length; final double width; Rectangle(double length, double width) &#123; this.length = length; this.width = width; &#125; @Override double area() &#123; return length * width; &#125;&#125;// 类之间的层次关系可读且灵活class Square extends Rectangle &#123; Square(double side) &#123; super(side, side); &#125;&#125;嵌套类嵌套类最好只存在于宿主类 (enclosing class) 中, 否则，就应将其设计为顶层类。四种嵌套类：静态内部类、非静态内部类、匿名类、局部类。静态内部类：不与类的实例有关联，一个用法是提供类的帮助类。非静态内部类：确定与实例有关联才用，否则其默认将引用传给宿主类的实例，会占用存储空间与时间。最常用方法就是 Adapter 模式，可将外部类的实例视为某个不相关类的实例。例子：12345678910111213// Typical use of a nonstatic member classpublic class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; &#123; ... // Bulk of the class omitted @Override public Iterator&lt;E&gt; iterator() &#123; return new MyIterator(); &#125; private class MyIterator implements Iterator&lt;E&gt; &#123; ... &#125;&#125;匿名类： 只能在非静态上下文环境中使用时声明与实例化，在静态上下文环境，只能带有常量型变量（final修饰的基本类型及初始化为 String）。不能执行 instanceof 方法测试，不能在运行外实例化，不能实现多个接口或继承一个类同时实现一个接口。常用：创建小函数对象和处理对象的首选方法。局部类：非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。永远不要将多个顶级类或接口放在一个源文件中保证在编译时不能有多个定义。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式：Java方法]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用 try-with-resources调用用完需关闭的方法。实现了 AutoCloseable接口（由一个返回为 void的close组成）的资源可以使用try-with-resources方法。AutoCloseable接口在Java的类库和第三方类库中许多类和接口都有实现或继承，例如 BufferedReader、InputStream、OutputStream 等。123456789101112// examplestatic void copy(String src, String dst) throws IOException &#123; try(InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst))&#123; byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.read(buf)) &gt;= 0)&#123; out.write(buf, 0, n); &#125; &#125; OutputStream &#125;重写equals方法规则使用 == 运算符检查参数是否为该对象的引用。如果是，返回 true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。使用 instanceof 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 Float.compare(float, float) 方法；对于 double 基本类型的属性，使用 Double.compare(double, double) 方法。由于存在 Float.NaN，-0.0f 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。某些对象引用的属性可能合法地包含 null。 为避免出现 NullPointerException 异常，请使用静态方法 Objects.equals(Object, Object) 检查这些属性是否相等。重写equals方法时一定重写hashCode方法。基于Hash值的散列数据结构，例如hashMap、HashSet等，需要基于Hash值判断两个是否相等，其实是根据equals方法来判断。equals方法改变，要想实例也能跟被基于hash的散列结构识别，需要将hashCode方法重写。时刻重写toString方法。使用clone方法对于可变对象的克隆需要谨慎。克隆出来的对象的类型与原始对象的一致，并且x.clone != x返回true。123456789101112131415161718192021222324252627282930313233343536373839404142434445// HashTable的克隆方法，需要深度克隆，保证克隆出来的对象是原先对象的深层拷贝，桶或链都拷贝一份// Recursive clone method for class with complex mutable statepublic class HashTable implements Cloneable &#123; private Entry[] buckets = ...; private static class Entry &#123; final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) &#123; this.key = key; this.value = value; this.next = next; &#125; // Recursively copy the linked list headed by this Entry //Entry deepCopy() &#123; // return new Entry(key, value, // next == null ? null : next.deepCopy()); //&#125; // 避免链表过长导致栈溢出错误 Entry deepCopy()&#123; Entry result = new Entry(key, value, next); for(Entry p = result; p!=null; p=p.next)&#123; p.next = new Entry(p.next.key, p.next.value, p.next.next); &#125; return result; &#125; &#125; @Override public HashTable clone() &#123; try &#123; HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; ... // Remainder omitted&#125;在可比较大小的类中考虑实验Comparable接口。123public interface Comparable&lt;T&gt;&#123; int compareTo(T t);&#125;在conpareTo()中比较大小时，避免使用 &lt; 或者 &gt; ,应该使用包装类中的compare()方法或者自己实现Comparator接口中的compare()方法12345678910// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123; public int compare(Object o1, Object o2) &#123; return Integer.compare(o1.hashCode(), o2.hashCode()); &#125;&#125;;// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());参考： https://sjsdfg.github.io/effective-java-3rd-chinese/#/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式：Java创建对象]]></title>
    <url>%2FJava%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用静态工厂方法代替构造方法静态工厂方法是一个静态方法，用来生成实例。例如：12345678910111213// 单例模式public class Dog&#123; // 私有方法防止在外调用创建实例 private Dog()&#123; &#125; private static class Inner()&#123; private static final Dog dog = new Dog(); &#125; public static getInstance()&#123; return Inner.dog; &#125;&#125;因为构造方法每次调用都需要新建一个对象，有些情况下不能满我们的要求。而静态工厂方法生成对象有以下几个好处：1. 名字更有意义。from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant);of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set faceCards = EnumSet.of(JACK, QUEEN, KING);valueOf —— from 和 to 更为详细的替代 方式，例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：StackWalker luke = StackWalker.getInstance(options);create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen);getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：FileStore fs = Files.getFileStore(path);newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：BufferedReader br = Files.newBufferedReader(path);type —— getType 和 newType 简洁的替代方式，例如：List litany = Collections.list(legacyLitany);2. 可以实现实例数量的控制。例如单例、不可实例化类的实现。3. 返回的对象可以根据参数不同而不同。4. 返回的实例可以没有对应的对象类型。例如服务者提供框架，就是用到静态工厂方法。服务接口，表示实现；提供者注册API，选择实现；服务访问API，客户端调用。服务提供者接口，描述生成服务接口实例的工厂对象。依赖注入框架可以被看作强大的服务提供者。当构造函数多时使用builder模式构造函数名字都与类名一样，区分不同构造函数依靠参数的顺序与数量。当构造参数很多时，实例的生成非常麻烦，往往不知道调用哪个构造函数。123456789101112131415161718192021222324252627282930313233343536public class NutritionFacts&#123; private final int servingSize; private final int calories; private final int fat; public static class Builder&#123; private final int servingSize; private int calories; private int fat; public Builder(int servingSize)&#123; this.servingSize = servingSize; &#125; public Builder calories(int calories)&#123; calories = calories; return this; &#125; public Builder fat(int fat)&#123; fat = fat; return this; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder)&#123; this.servingSize = builder.servingSize; this.calories = builder.calories; this.fat = builder.fat; &#125;&#125;NutritionFacts coca = NutritionFacts.Builder(10).calories(40).fat(0).build();使用场景：当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。单例模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 懒汉模式，线程不安全，不是严格意义上单例模式public class Dog&#123; private static final Dog dog; private Dog()&#123; &#125; public static getInstance()&#123; if(dog==null) dog = new Dog(); return dog; &#125;&#125;// 饿汉模式，线程安全，但易产生垃圾public class Dog&#123; private static final Dog dog = new Dog(); private Dog()&#123; &#125; public static getInstance()&#123; return dog; &#125;&#125;// 内部类方式，线程安全，但是序列化要保证单例，需要重写 readResolve()public class Dog&#123; private Dog()&#123; &#125; private static class Inner()&#123; private static final Dog dog = new Dog(); &#125; public static getInstance()&#123; return Inner.dog; &#125; // 序列化也保证一个单类 Object readResolve() throws ObjectStreamException&#123; return dog; &#125;&#125;//枚举模式，最简单，但不常用。线程安全，且保证序列化唯一性public enum Dog&#123; INSTANCE; public static getInstance()&#123; return Dog.INSTANCE; &#125;&#125;使用私有构造方法非实例化构造方法声明为私有方法，可以创建非实例化类。该类存在的意义就是提供工具静态方法，例如 java.util.Arrays 工具类等。简单依赖注入通过构造方法把类依赖的客户端资源注入到类中，是依赖注入的一种方式。123456789public class SpellChecker&#123; private final Chinese dictionary; public SpellChecker(Chinese dictionary)&#123; this.dictionary = Object.requireNonNull(dictionary); &#125; public boolean isValid(String word)&#123;...&#125;&#125;可以通过依赖注入把同一子类的资源工厂当做参数。工厂就是可以被重复调用生产实例的对象。Java 8的函数式接口Supplier非常适合工厂。12345@FunctionalInterfaceinterface Supplier&lt;T&gt;&#123; // 用来提供对象 T get();&#125;1Mosaic create(Supplier&lt;T? extends Tile&gt; tileFactroy)&#123;..&#125;避免创建不必要的对象例如12345678910// 例子1Integer it = 0; for(int i=0; i&lt;1000000; i++)&#123; // 创建了1000000对象 it += i;&#125;// 例子2// 多创建了一个StringString s = new String("moreClass");原则：尽量使用基本类型而不使用装箱的基本类型，即使自动装箱也要考虑。消除过期的对象引用。如果对象引用是隐式存在，如果不需要，则置为null。例如编写stack类pop()方法：12345public &lt;T&gt; pop()&#123; &lt;T&gt; result = bucket[--size]; bucket[size] = null; return ;&#125;避免使用Finalizer和Cleaner机制！参考： https://sjsdfg.github.io/effective-java-3rd-chinese/#/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 33.搜索旋转排序数组]]></title>
    <url>%2FLeetcode%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1思路+代码时间复杂度要求是O(log n)，也就是二分法。于是我写了一个最基础的二分法…还是用递归..1234567891011121314151617181920212223242526272829class Solution &#123; public int search(int[] nums, int target) &#123; if(nums.length==0 || nums==null) return -1; if(nums.length==1) return nums[0]==target?0:-1; return subSearch(nums, target, 0, nums.length-1); &#125; private int subSearch(int[] nums, int target, int left, int right)&#123; if(nums[left]==target) return left; if(nums[right]==target) return right; int mid = (left+right)/2; if(nums[mid]==target) return mid; if(right-left==1) return -1; int tmp=-1; tmp=subSearch(nums, target, left, mid); if(tmp!=-1) return tmp; tmp=subSearch(nums, target, mid, right); return tmp; &#125;&#125;看了答案之后… 我想说:****123456789101112131415161718192021222324252627class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(target==nums[mid]) return mid; // 左侧不包含旋转序列 if(nums[left]&lt;=nums[mid])&#123; if(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125; // 右侧不包含旋转序列 else&#123; if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123; left = mid+1; &#125;else&#123; right = mid-1; &#125; &#125; &#125; return -1; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet技术]]></title>
    <url>%2FServlet%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[什么是Servet?Servlet (Server Applet)，从字面上看，就是Java服务器小程序的意思。它确实就像字面意思一样，是在服务中用于处理网络请求的小程序。在Web的世界中，客户端会提交各种请求到服务端，服务端如何处理客户端的请求呢？常规的Java编程方法，好像很难完成这项任务，但是没有事情是难倒程序猿的。于是，他们设计了Servlet规范，用来处理网络的各种请求。具体网络的请求呢，无非就是get、post等等，这在HTTP规范系列里面有讲到。Servlet规范也没有想象中的那么高大上，其实它就是一个Java接口，里面一共就定义了五个方法，如图：其中：init() 规定了Servet如何初始化。getServletConfig() 获取Sevvlet的配置。service(ServletRequest, ServletResponse) 接收到请求怎么处理。getServletInfo() 提供有关servlet的信息，如作者、版本、版权等。destroy() 销毁Servlet。Servlet的运行任何合理实现了Servlet接口的类都具有处理HTTP请求的能力，但是就像java类的运行需要在JVM环境中一样，Servlet的运行也要环境，这里称为容器。即Servlet的运行需要特定的容器，该容器负责实现对端口的监听，将请求内容解析，然后实例Servlet对象，给Servlet提供运行环境，然后将Servlet的处理结果发给客户端。Tomcat就是一个开源的Servlet的容器，它也是一个Web服务器。HttpServlet就是已经实现好的一个Servlet类，他对一些方法进行了详细的补充，我们通过doGet()、doPost()等方法很方便地实现处理HTTP请求功能。它的一些源码如下：service()实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取http request的method参数，其实就是html的form标签 //中method属性对应的字符串 String method = req.getMethod(); long errMsg; //判断请求方式 if(method.equals("GET")) &#123; //获取最后被修改时间 errMsg = this.getLastModified(req); if(errMsg == -1L) &#123; /**如果servlet不支持http request header的if-modified-since属性 * 则继续处理 **/ this.doGet(req, resp); &#125; else &#123; //如果支持这个属性 long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader("If-Modified-Since"); &#125; catch (IllegalArgumentException var9) &#123; ifModifiedSince = -1L; &#125; /** * 如果客户端的文件最后修改时间和服务器端的文件最后修改时间一致则返回304不需要修改状态 * 这样服务器就不返回html，浏览器读取本地缓存文件，否则重新获取服务器端的对应html文件 **/ if(ifModifiedSince &lt; errMsg / 1000L * 1000L) &#123; this.maybeSetLastModified(resp, errMsg); this.doGet(req, resp); &#125; else &#123; resp.setStatus(304); &#125; &#125; &#125; else if(method.equals("HEAD")) &#123; errMsg = this.getLastModified(req); this.maybeSetLastModified(resp, errMsg); this.doHead(req, resp); &#125; else if(method.equals("POST")) &#123; this.doPost(req, resp); &#125; else if(method.equals("PUT")) &#123; this.doPut(req, resp); &#125; else if(method.equals("DELETE")) &#123; this.doDelete(req, resp); &#125; else if(method.equals("OPTIONS")) &#123; this.doOptions(req, resp); &#125; else if(method.equals("TRACE")) &#123; this.doTrace(req, resp); &#125; else &#123; //如果请求不是以上的所有请求方式，该方法就会响应501错误，也就是不支持这种请求 String errMsg1 = lStrings.getString("http.method_not_implemented"); Object[] errArgs = new Object[]&#123;method&#125;; errMsg1 = MessageFormat.format(errMsg1, errArgs); resp.sendError(501, errMsg1); &#125; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException("non-HTTP request or response"); &#125; this.service(request, response);&#125;doGet()实现：1234567891011121314protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取协议 String protocol = req.getProtocol(); //获取http.method_get_not_supported的国际化字符串 String msg = lStrings.getString("http.method_get_not_supported"); if(protocol.endsWith("1.1")) &#123; //如果是HTTP/1.1，返回405禁止访问方法错误 resp.sendError(405, msg); &#125; else &#123; //如果不是HTTP/1.1，返回400错误的请求错误 resp.sendError(400, msg); &#125; &#125;doPost()实现：12345678910protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_post_not_supported"); if(protocol.endsWith("1.1")) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125;其实在工业界，几乎没有直接利用Servlet开发Web应用的了，但是它是一个基础，很多开源框架都是基于Servlet开发的，如大名鼎鼎的Spring如何实现？首先我写一个Servlet类,作用是得到get()请求，然后返回“Hello Servlet!”与打印当前时间。12345678910111213public class HelloServlet extends HttpServlet&#123; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; response.getWriter().println("&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;然后配置web.xml文件，建立URL与Servlet处理类 HelloServlet 之间的关联关系。1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;其中servlet-name是类名简写，servlet-class 是类名。servlet-mapping实现URL与类的映射，这里实现了访问路径 http://127.0.0.1//hello 时调用HelloServlet类的相应方法。http://127.0.0.1 是一个监听地址，需要服务器实现监听，此时就需要Tomcat。然后修改Tomcat的conf/server.xml的路径配置。1&lt;Context path="/" docBase="F:\\eclipse-workspace\\j2ee\\web" debug="0" reloadable="false" /&gt;Servlet的特点1. Servlet是单实例多线程。1) 当Web服务器启动或者用户请求抵达服务器时，Servlet被实例化且只存在一个实例。2) 当请求抵达时，Servlet容器(如Tomcat)会调度线程 (Dispathchaer Thread)调度它管理下的线程池中等待执行的线程 (Worker Thread) 给请求者。3) 线程执行Servlet中的sercive方法。4) 请求结束，该线程放回线程池，等待被调用。2. Servet使用标准API，可被更多Web服务器调用。线程安全由于Servlet是单实例多线程，当多个线程的用户同时访问共享资源时，就会出现线程安全的问题。解决方法:首先，定义在 doPost() 和 doGet()里的方法由于是局部变量，再每个用户调用实例方法时都会初始化，所以不存在线程安全。（一些属性尽量定义在实例的局部方法中）实在需要共享的资源，只需加synchronized同步机制，在共享资源被某一线程占用后，该线程就拥有锁，其它线程只有等待该线程执行完毕才能使用该资源（抢占锁后一一执行）。Servlet的常用方法在HttpServlet中sercive方法中，参数列表接受两个对象，一个是HttpServletResponse对象，一个是HttpServletRequest对象。HttpServletRequest常用方法常见方法方法名作用request.getRequestURL()浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI()浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString()请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr()浏览器所处于的客户机的IP地址request.getRemoteHost()浏览器所处于的客户机的主机名request.getRemotePort()浏览器所处于的客户机使用的网络端口request.getLocalAddr()服务器的IP地址request.getLocalName()服务器的主机名request.getMethod()得到客户机请求方式一般是GET或者POST获取参数方法名作用request.getParameter()是常见的方法，用于获取单值的参数request.getParameterValues()用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap()用于遍历所有的参数，并返回Map类型。获取头信息方法名作用request.getHeader()获取浏览器传递过来的头信息。比如getHeader(“user-agent”)可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器request.getHeaderNames()获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息头信息含义：host: 主机地址user-agent: 浏览器基本资料accept: 表示浏览器接受的数据类型accept-language: 表示浏览器接受的语言accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码connection: 是否保持连接cache-control: 缓存时限HttpServletResponse常用方法设置相应内容PrintWriter pw= response.getWriter();通过response.getWriter(); 获取一个PrintWriter 对象可以使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。设置相应内容response.setContentType(“text/html”);设置相应编码response.setContentType(&quot;text/html; charset=UTF-8&quot;);不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文response.setCharacterEncoding(&quot;UTF-8&quot;);仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。301或者302客户端跳转客户端有两种跳转:302 表示临时跳转response.sendRedirect(&quot;fail.html&quot;);301 表示永久性跳转response.setStatus(301);response.setHeader(&quot;Location&quot;, &quot;fail.html&quot;);设置不使用缓存123response.setDateHeader("Expires",0 );response.setHeader("Cache-Control","no-cache");response.setHeader("pragma","no-cache");参考: http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2FGit-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git简介Git是世界上最先进的分布式版本控制系统。当时是为了帮助管理 linux 内核开发而开发的一个开源码版本控制系统。Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库Git 是分布式版本控制系统，每个人的电脑上都有完整的版本库。常用命令列表常用1234567891011121314151617181920$ git remote add origin git@github.com:yeszao/dofiler.git # 配置远程git版本库$ git pull origin master # 下载代码及快速合并 $ git add . # 跟踪所有改动过的文件$ git add &lt;file&gt; # 跟踪指定的文件$ git commit -m “commit message” # 提交所有更新过的文件$ git push origin master # 上传代码及快速合并$ git fetch origin # 从远程库获取代码$ git branch # 显示所有分支$ git checkout master # 切换到master分支$ git checkout -b dev # 创建并切换到dev分支$ git commit -m &quot;first version&quot; # 提交$ git status # 查看状态$ git log # 查看提交历史$ git config --global core.editor vim # 设置默认编辑器为vim（git默认用nano）$ git config core.ignorecase false # 设置大小写敏感$ git config --global user.name &quot;YOUR NAME&quot; # 设置用户名$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; # 设置邮箱别名Alias123456789$ git config --global alias.br=&quot;branch&quot; # 创建/查看本地分支$ git config --global alias.co=&quot;checkout&quot; # 切换分支$ git config --global alias.cb=&quot;checkout -b&quot; # 创建并切换到新分支$ git config --global alias.cm=&quot;commit -m&quot; # 提交$ git config --global alias.st=&quot;status&quot; # 查看状态$ git config --global alias.pullm=&quot;pull origin master&quot; # 拉取分支$ git config --global alias.pushm=&quot;push origin master&quot; # 提交分支$ git config --global alias.log=&quot;git log --oneline --graph --decorate --color=always&quot; # 单行、分颜色显示记录$ git config --global alias.logg=&quot;git log --graph --all --format=format:&apos;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)&apos; --abbrev-commit --date=relative&quot; # 复杂显示创建版本库12$ git clone &lt;url&gt; # 克隆远程版本库$ git init # 初始化本地版本库修改和提交123456789$ git status # 查看状态$ git diff # 查看变更内容$ git add . # 跟踪所有改动过的文件$ git add &lt;file&gt; # 跟踪指定的文件$ git mv &lt;old&gt; &lt;new&gt; # 文件改名$ git rm &lt;file&gt; # 删除文件$ git rm --cached &lt;file&gt; # 停止跟踪文件但不删除$ git commit -m “commit message” # 提交所有更新过的文件$ git commit --amend # 修改最后一次提交查看提交历史123$ git log # 查看提交历史$ git log -p &lt;file&gt; # 查看指定文件的提交历史$ git blame &lt;file&gt; # 以列表方式查看指定文件的提交历史撤销12345$ git reset --hard HEAD # 撤消工作目录中所有未提交文件的修改内容$ git reset --hard &lt;version&gt; # 撤销到某个特定版本$ git checkout HEAD &lt;file&gt; # 撤消指定的未提交文件的修改内容$ git checkout -- &lt;file&gt; # 同上一个命令$ git revert &lt;commit&gt; # 撤消指定的提交分支与标签1234567891011$ git branch # 显示所有本地分支$ git checkout &lt;branch/tag&gt; # 切换到指定分支或标签$ git branch &lt;new-branch&gt; # 创建新分支$ git branch -d &lt;branch&gt; # 删除本地分支$ git tag # 列出所有本地标签$ git tag &lt;tagname&gt; # 基于最新提交创建标签$ git tag -a &quot;v1.0&quot; -m &quot;一些说明&quot; # -a指定标签名称，-m指定标签说明$ git tag -d &lt;tagname&gt; # 删除标签$ git checkout dev # 合并特定的commit到dev分支上$ git cherry-pick 62ecb3合并与衍合1234$ git merge &lt;branch&gt; # 合并指定分支到当前分支$ git merge --abort # 取消当前合并，重建合并前状态$ git merge dev -Xtheirs # 以合并dev分支到当前分支，有冲突则以dev分支为准$ git rebase &lt;branch&gt; # 衍合指定分支到当前分支远程操作12345678910复制代码$ git remote -v # 查看远程版本库信息$ git remote show &lt;remote&gt; # 查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; # 添加远程版本库$ git remote remove &lt;remote&gt; # 删除指定的远程版本库$ git fetch &lt;remote&gt; # 从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; # 下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; # 上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; # 删除远程分支或标签$ git push --tags # 上传所有标签打包123$ git archive --format=zip --output ../file.zip master # 将master分支打包成file.zip文件，保存在上一级目录$ git archive --format=zip --output ../v1.2.zip v1.2 # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中$ git archive --format=zip v1.2 &gt; ../v1.2.zip # 作用同上一条命令远程与本地合并123456$ git init # 初始化本地代码仓$ git add . # 添加本地代码$ git commit -m &quot;add local source&quot; # 提交本地代码$ git pull origin master # 下载远程代码$ git merge master # 合并master分支$ git push -u origin master # 上传代码参考资料：https://www.cnblogs.com/ldj3/p/9172804.htmlhttps://www.zhihu.com/question/41667536/answer/486640083]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2FTCP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[起源HTTP的来历CERN(欧洲核子研究组织)的蒂姆 • 伯纳斯 - 李(Tim BernersLee)博士提出了一种能让远隔两地的研究者们共享知识的设想。最初的设想是通过超文本(HyperText)标记,各地互联连接成可相互参阅的WWW(World Wide Web, 万维网)。目前WWW构建的关键技术为：基于SGML(Standard Generalized Markup Language,标准通用标记语言)的HTML （HyperText Markup Language, 超文本标记语言）。指定文档所在的地址URL (Uniform Resource Locator, 统一资源定位符) 。各个Web服务器通过万维网互相连接，以 HTML 标准编辑网页（存储信息），用 URL 实现信息的查找，最后通过Web浏览器实现界面的渲染。如何控制信息的传输？然而，Web服务器有各种各样的类型及硬件接口，显示平台也有各种各样的类型，如何实现平台之间信息的互相交流呢？ —— 统一协议控制。答案是通过统一的协议 (Protocol)。# TCP/TP 协议簇TCP/IP 有说法是专指TCP和IP协议。这里指互联网相关的各类协议簇的总称，例如：IP, PPPoE, TCP, FTP, HTTP, FDDI, IEEE 802.3, SNMP, UDP, DNS, ICMP 等等。也就是说 HTTP 是 TCP/IP 协议的子集。分层管理在逻辑上，TCP/IP分为四个层次：应用层、传输层、网络层和数据链路层。名称作用应用层客户端实现信息的封装与解析。该层使用的协议如 HTTP、DNS (Domain Name System, 域名系统)、FTP (File Transfer Protocol, 文件传输协议)等。传输层提供网络连接中两台计算机之间的数据传输。使用的协议：TCP (Transmission Control Protocol) 和 UDP (User Data Protocol, 用户数据协议)。网络层将网络中流动的数据包（网络传输最小数据单位）通过规定的路径（传输线路）到达对方的计算机，并把数据传给对方。数据链路层肉眼可见的硬件层，包括网卡、光纤等。数据传输过程用户根据HTTP协议发送一个数据请求（应用层）。获得应用层数据后，传输层（TCP协议）为了方便，将数据（HTTP请求报文）进行分割，每个报文打上标记序号及端口号，然后转发给网络层。网络层将通信目的地的DNS增加到数据中，然后转发给数据链路层。数据链路层将数据发给目的地终端。在解析数据时，按照数据包装的逆序层层解包（去除每一层打上的首部信息），最终获得请求的HTTP报头。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 岛屿最大的面积]]></title>
    <url>%2FLeetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)示例1:12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。示例2:1[[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。注意: 给定的矩阵grid 的长度和宽度都不超过 50。思路+代码一开始想的是动态规划，但是该题没有规律的求解方法，即岛屿的形状无法用统一的方法计算。此题采用 DFS（深度优先遍历）的方法求解。DFS一般解体模板（https://blog.csdn.net/weixin_43272781/article/details/82959089）。123456789101112131415161718192021int check(参数)&#123; if(满足条件) return 1; return 0;&#125; void dfs(int step)&#123; 判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） &#125;&#125;此题的解法：边界条件是二维矩阵的边界。尝试每一种可能是上、下、左、右四个方向进行遍历。check是是否为陆地（数值是否为1）。标记是将遍历过的陆地变成海洋（置为1）。123456789101112131415161718192021222324252627282930313233class Solution &#123; private int row; private int col; public int maxAreaOfIsland(int[][] grid) &#123; row = grid.length; col = grid[0].length; if(row==0 || col==0) return 0; int res = 0; for(int i=0; i&lt;row; i++)&#123; for(int j=0; j&lt;col; j++)&#123; if(grid[i][j]&gt;0)&#123; res = Math.max(res, dfs(grid, i, j)); &#125; &#125; &#125; return res; &#125; private int dfs(int[][] g, int i, int j)&#123; int sum = 1, x=0, y=0; int[][] dir = new int[][]&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; //避免再次被选到 g[i][j] = 0; for(int s=0;s&lt;4;s++)&#123; x = i + dir[s][0]; y = j + dir[s][1]; if(x&gt;=0 &amp;&amp; x&lt;row &amp;&amp; y&gt;=0 &amp;&amp; y&lt;col &amp;&amp; g[x][y]&gt;0)&#123; sum += dfs(g, x ,y); &#125; &#125; return sum; &#125;&#125;题目链接：https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>DFS Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文件中添加UML图]]></title>
    <url>%2FMarkdown%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0UML%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML图简介UML(Unified Modeling Language)是统一建模语言的简写。它可分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。静态图分为：用例图，类图，对象图，包图，构件图，部署图。动态图分为：状态图，活动图，协作图，序列图。其中类图 (Class Diagrams)是用来表示类的内部结构和类与类之间的关系的一种UML。常见的关系有：泛化 (Generalization)，实现 (Realization)，组合 (Composition)，聚合 (Aggregation)，关联 (Association)，依赖 (Dependency)。各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖参考教程UML类图的绘制及插入我们利用在线的开源工具plantUML实现UML图绘制。具体的绘制方法可以参考官网plantUML。然后将网址中生成的UML图片地址插入到Markdown文件中。参考教程]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 字符串的排列 (String 练习 03)]]></title>
    <url>%2FLeetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97-String-%E7%BB%83%E4%B9%A0-03%2F</url>
    <content type="text"><![CDATA[题目给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。示例1:123输入: s1 = "ab" s2 = "eidbaooo"输出: True解释: s2 包含 s1 的排列之一 ("ba").示例2:12输入: s1= "ab" s2 = "eidboaoo"输出: False注意:121. 输入的字符串只包含小写字母2. 两个字符串的长度都在 [1, 10,000] 之间思路 1暴力法，滑动窗口依次判定。但是超出时间限制！1234567891011121314151617181920212223class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; for(int i=0; i+len1&lt;=len2; i++)&#123; if(checkSubString(s1, s2.substring(i, i+len1))) return true; &#125; return false; &#125; private boolean checkSubString(String subS1, String subS2)&#123; String s = new String(subS2); for(int i=0; i&lt;subS1.length(); i++)&#123; if(s.indexOf(subS1.charAt(i))!=-1)&#123; s = s.replaceFirst(String.valueOf(subS1.charAt(i)), ""); &#125; &#125; return s.isEmpty()?true:false; &#125;&#125;时间复杂度：O((len2-len1) * len1 * len2 * len2)空间复杂度：O(1)思路 2也是滑动窗口法，不过不用内置的函数（使用过程中存在循环遍历），而利用数组存储各个字母出现的次数，进行子串是否匹配的判定依据。123456789101112131415161718192021222324252627class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; int[] temp1 = new int[26]; for(int i=0; i&lt;len1; i++) temp1[s1.charAt(i)-'a']++; for(int i=0; i+len1&lt;=len2; i++)&#123; int[] temp2 = new int[26]; for(int j=0; j&lt;s1.length(); j++)&#123; temp2[s2.charAt(i+j)-'a']++; &#125; if(match(temp1, temp2)) return true; &#125; return false; &#125; private boolean match(int[] tmp1, int[] tmp2)&#123; for(int i=0; i&lt;tmp1.length; i++)&#123; if(tmp1[i]!=tmp2[i]) return false; &#125; return true; &#125;&#125;时间复杂度：O(len1 + (len2-len1) * len1 * 26)空间复杂度: O(1)思路 3基于思路2，继续进行优化。其实在滑动窗口中，每次只更新哈希表（数组）的第一个值及最后一个值，中间的不需要遍历。因此时间复杂度降低 len1123456789101112131415161718192021222324252627282930class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; int[] temp1 = new int[26]; int[] temp2 = new int[26]; for(int i=0; i&lt;len1; i++)&#123; temp1[s1.charAt(i)-'a']++; temp2[s2.charAt(i)-'a']++; &#125; if(match(temp1, temp2)) return true; for(int i=0; i+len1&lt;len2; i++)&#123; temp2[s2.charAt(i+len1)-'a']++; temp2[s2.charAt(i)-'a']--; if(match(temp1, temp2)) return true; &#125; return false; &#125; private boolean match(int[] tmp1, int[] tmp2)&#123; for(int i=0; i&lt;tmp1.length; i++)&#123; if(tmp1[i]!=tmp2[i]) return false; &#125; return true; &#125;&#125;时间复杂度：O(len1 + (len2-len1) * 26)空间复杂度: O(1)作者：LeetCode链接：https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 最长公共前缀 (String 练习 01)]]></title>
    <url>%2FLeetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。示例1:12输入: ["flower","flow","flight"]输出: "fl"示例2:123输入: ["dog","racecar","car"]输出: ""解释: 输入不存在公共前缀。说明:1所有输入只包含小写字母 a-z 。思路1暴力法，时间复杂度O(n^3)。123456789101112131415161718192021class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; String ans = ""; if(strs.length==0) return ans; lable:&#123; for(int j=0; j&lt;strs[0].length(); j++)&#123; char c = strs[0].charAt(j); for(int i=1; i&lt;strs.length; i++)&#123; if(j&gt;=strs[i].length() || !isCharEqual(c, strs[i], j))&#123; break lable; &#125; &#125; ans += c; &#125; &#125; return ans; &#125; private boolean isCharEqual(char c, String s, int i)&#123; return c==s.charAt(i); &#125;&#125;思路2巧用String提供的一些API，例如substring(),判定子串的位置。123456789101112131415class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; String ans; if(strs.length==0) return ""; ans = strs[0]; for(int i=1; i&lt;strs.length; i++)&#123; while(strs[i].indexOf(ans)!=0)&#123; ans = ans.substring(0, ans.length()-1); if(ans.isEmpty()) return ans; &#125; &#125; return ans; &#125; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java: Set API]]></title>
    <url>%2FJava-Set-API%2F</url>
    <content type="text"><![CDATA[Java Set概述Set 继承自集合（Collection），该集合不能包含相同的元素。Set 里面进行元素是否相同的判定是通过 Object 类自带的equals()实现。Set 最多可存储一个 null 元素。Set 只是一个抽象的接口，具体的使用还要用具体的实现，如HashSet、TreeSet等。常用方法因为 Set 继承自集合 Collection，所以具有集合的方法。方法描述int size()返回Set里面存储的元素个数。boolean isEmpty()如果没有元素，返回true。boolean add(E e)如果Set里面没有包含元素e，就将其加入。boolean addAll(Collection&lt;? extends E&gt;c)如果指定集合中的元素不存在Set中，就将其加入Set。如果该Collection也是一个Set，相当于对这两个Set取并集。boolean contains(Object o)是否包含特定的元素 o。即对Set里面的任意元素e执行判定(o==null?e==null:o.equals(e))。boolean containsAll(Collecton&lt; ? &gt;c)该Set是否包含指定Collection的所有元素。void clear()清除所有元素。boolean remove(Object o)删除指定元素。boolean removeAll(Collection&lt; ? &gt;c)删除Set中存在于该Collection里的元素。Object[ ] toArray()将Set转化为数组。&lt; T &gt; T[ ] toArray(T[ ] a)返回所有的Set元素并存储在Array中。如果a的长度大于Set长度，则多余空间以null补全。Iterator&lt; E &gt; iterator()返回一个该Set的迭代器default Spliterator&lt; E &gt; spliterator()在该集合中创建拆分器。常用Set实现HashSetHashSet的方法基本与Set一致，只不过多了一个Object clone()方法（浅复制，只复制地址）。主要方法包括：add()clear()clone()contains()isEmpty()iterator()remove()size()spliterator()HashSet底层是基于HashMap实现的。即通过HashMap的键唯一性实现。构造方法示例1234567891011121314151617public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125;// 该构造方法为LinkedHashSet实现准备HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;LinkedHashSetLinkedHashSet保存了元素的顺序，即插入时的顺序，再使用iterator遍历时会按顺序遍历。LinkedHashSet底层也是根据LinkHashMap实现的。通过父类HashSet的构造方法，调用LinkHashMap。123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;继承自 HashSet，实现了接口 Serializable 及 Cloneable。Serializable是一个空接口，是一个序列化的标记，用来告诉JVM该类可以序列化。序列化就是把对象的状态转化为可存储和传输的格式（如二进制流）；反序列化就是序列化的逆过程，根据序列化后的数据重新恢复对象及其状态。TreeSet可实现排序的Set，排序规则可以是自带的或者通过Comparator实现。基础操作（add,contains and remove）的耗时是log(n)。实现了NavigableSet接口，该接口是基于TreeMap的。TreeSet底层是基于TreeMap实现，所以对于系统内部类例如Integer、String等，由于实现了Comparable接口，可直接进行存储；对于自定义的类，必须实现Comparable接口并重写comparaTo（）方法，这样TreeSet才能根据排序规则进行排序。TreeSet不能有重复元素。TreeSet的存取不如HashSet快。comparaTo()方法在被调用过程中，如果返回真值（或大于零的数），就认为新插入元素大于根元素，存入右节点，此时为顺序排列；反之存入左节点，为逆序排列。构造函数：序号构造函数的说明1TreeSet()，此构造函数构造空树集，将在根据其元素的自然顺序按升序排序。2TreeSet (集合 c)，此构造函数生成树的集合，它包含的元素的集合 c。3TreeSet (比较器 comp)，此构造函数构造一个空树集，将根据给定的比较器进行排序。4TreeSet (SortedSet ss)，此构造函数生成包含给定 SortedSet 的元素 TreeSet常用方法：修饰符和类型方法和描述booleanadd(E e)，将指定的元素添加到这套，如果它已不存在。booleanaddAll(Collection&lt;? extends E&gt; c)，在加入这一组指定的集合中添加的所有元素。Eceiling(E e)，返回最小的元素在这一组大于或等于给定的元素，则null如果没有这样的元素。voidclear()，从这一组中移除所有元素。Objectclone()，返回此TreeSet实例浅表副本。Comparator&lt;? super E&gt;comparator()，返回用于排序在这集，或空元素，如果这套使用自然排序其元素的比较。booleancontains(Object o)，如果此集合包含指定的元素，则返回true 。IteratordescendingIterator()，返回迭代器中这套降序排序的元素。NavigableSetdescendingSet()，返回逆序视图中包含的元素这一套。Efirst()，返回第一个 （最低） 元素当前在这一套。Efloor(E e)，返回的最大元素在这一组小于或等于null如果没有这样的元素。SortedSetheadSet(E toElement)，返回其元素是严格小于toElement这套的部分视图.NavigableSetheadSet(E toElement, boolean inclusive)，返回一个视图的这部分设置的元素都小于 （或等于，如果inclusive是真的） toElement.Ehigher(E e)，返回最小的元素在这套严格大于给定的元素，则null如果没有这样的元素。booleanisEmpty()，如果此集不包含任何元素，则返回true 。Iteratoriterator()，返回迭代器中这套以升序排序的元素。Elast()，在这套目前返回的最后一个 （最高） 的元素。Elower(E e)，在这一套严格的小于给定的元素，则null返回的最大元素，如果没有这样的元素。EpollFirst()，检索和删除第一个 （最低） 元素，或如果此集合为空，则返回null 。EpollLast()，检索和删除的最后一个 （最高） 的元素，或如果此集合为空，则返回null 。booleanremove(Object o)，从这一组中移除指定的元素，如果它存在。intsize()，在这套 （其基数） 中返回的元素的数目。NavigableSetsubSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)，返回此集的部分视图的元素范围从fromElement到toElement.SortedSetsubSet(E fromElement, E toElement)，返回视图的部分的这一套的元素范围从fromElement，具有包容性，到toElement，独家。SortedSettailSet(E fromElement)，返回其元素是大于或等于fromElement这套的部分视图.NavigableSettailSet(E fromElement, boolean inclusive)，返回其元素是大于 （或等于，如果inclusive是真的） 这套的部分视图fromElement.实现原理TreeSet底层依赖于TreeMap，通过TreeMap来作为存储TreeSet的容易，键值保证了元素的唯一性。采用“红黑树”的排序二叉树保存Map中的每个Entry，每个Entry被当做“红黑树”的一个节点。“红黑树”是一种平衡二叉查找树，树中节点都大于等于左子树所有节点，且小于等于右子树左右节点。TreeSet部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245package java.util;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 使用NavigableMap对象的key来保存Set集合的元素 private transient NavigableMap&lt;E,Object&gt; m; //使用PRESENT作为Map集合中的value private static final Object PRESENT = new Object(); // 不带参数的构造函数。创建一个空的TreeMap //以自然排序方法创建一个新的TreeMap，再根据该TreeMap创建一个TreeSet //使用该TreeMap的key来保存Set集合的元素 public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; // 将TreeMap赋值给 "NavigableMap对象m" TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; //以定制排序的方式创建一个新的TreeMap。根据该TreeMap创建一个TreeSet //使用该TreeMap的key来保存set集合的元素 public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;E,Object&gt;(comparator)); &#125; // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中 public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); // 将集合c中的元素全部添加到TreeSet中 addAll(c); &#125; // 创建TreeSet，并将s中的全部元素都添加到TreeSet中 public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; // 返回TreeSet的顺序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator(); &#125; // 返回TreeSet的逆序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator(); &#125; // 返回TreeSet的大小 public int size() &#123; return m.size(); &#125; // 返回TreeSet是否为空 public boolean isEmpty() &#123; return m.isEmpty(); &#125; // 返回TreeSet是否包含对象(o) public boolean contains(Object o) &#123; return m.containsKey(o); &#125; // 添加e到TreeSet中 public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; // 删除TreeSet中的对象o public boolean remove(Object o) &#123; return m.remove(o)==PRESENT; &#125; // 清空TreeSet public void clear() &#123; m.clear(); &#125; // 将集合c中的全部元素添加到TreeSet中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // Use linear-time version if applicable if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; //把C集合强制转换为SortedSet集合 SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; //把m集合强制转换为TreeMap集合 TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); //如果cc和mc两个Comparator相等 if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; //把Collection中所有元素添加成TreeMap集合的key map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; return super.addAll(c); &#125; // 返回子Set，实际上是通过TreeMap的subMap()实现的。 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; // 返回Set的头部，范围是：从头部到toElement。 // inclusive是是否包含toElement的标志 public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; // 返回Set的尾部，范围是：从fromElement到结尾。 // inclusive是是否包含fromElement的标志 public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。 public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; // 返回Set的头部，范围是：从头部到toElement(不包括)。 public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。 public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; // 返回Set的比较器 public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; // 返回Set的第一个元素 public E first() &#123; return m.firstKey(); &#125; // 返回Set的最后一个元素 public E first() &#123; public E last() &#123; return m.lastKey(); &#125; // 返回Set中小于e的最大元素 public E lower(E e) &#123; return m.lowerKey(e); &#125; // 返回Set中小于/等于e的最大元素 public E floor(E e) &#123; return m.floorKey(e); &#125; // 返回Set中大于/等于e的最小元素 public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; // 返回Set中大于e的最小元素 public E higher(E e) &#123; return m.higherKey(e); &#125; // 获取第一个元素，并将该元素从TreeMap中删除。 public E pollFirst() &#123; Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null)? null : e.getKey(); &#125; // 获取最后一个元素，并将该元素从TreeMap中删除。 public E pollLast() &#123; Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null)? null : e.getKey(); &#125; // 克隆一个TreeSet，并返回Object对象 public Object clone() &#123; TreeSet&lt;E&gt; clone = null; try &#123; clone = (TreeSet&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; clone.m = new TreeMap&lt;E,Object&gt;(m); return clone; &#125; // java.io.Serializable的写入函数 // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); // 写入比较器 s.writeObject(m.comparator()); // 写入容量 s.writeInt(m.size()); // 写入“TreeSet中的每一个元素” for (Iterator i=m.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeSet的“比较器、容量、所有的元素值”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden stuff s.defaultReadObject(); // 从输入流中读取TreeSet的“比较器” Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); TreeMap&lt;E,Object&gt; tm; if (c==null) tm = new TreeMap&lt;E,Object&gt;(); else tm = new TreeMap&lt;E,Object&gt;(c); m = tm; // 从输入流中读取TreeSet的“容量” int size = s.readInt(); // 从输入流中读取TreeSet的“全部元素” tm.readTreeSet(size, s, PRESENT); &#125; // TreeSet的序列版本号 private static final long serialVersionUID = -2479143000061671589L;&#125;我们发现，TreeSet底层是依靠TreeMap对key进行存储排序实现的，现在看一下TreeMap的部分源码。TreeMap的put()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public V put(K key, V value) &#123; //定义一个t来保存根元素 Entry&lt;K,V&gt; t = root; //如果t==null，表明是一个空链表 if (t == null) &#123; //如果根节点为null，将传入的键值对构造成根节点（根节点没有父节点，所以传入的父节点为null） root = new Entry&lt;K,V&gt;(key, value, null); //设置该集合的size为1 size = 1; //修改此时+1 modCount++; return null; &#125; // 记录比较结果 int cmp; Entry&lt;K,V&gt; parent; // 分割比较器和可比较接口的处理 Comparator&lt;? super K&gt; cpr = comparator; // 有比较器的处理，即采用定制排序 if (cpr != null) &#123; // do while实现在root为根节点移动寻找传入键值对需要插入的位置 do &#123; //使用parent上次循环后的t所引用的Entry // 记录将要被掺入新的键值对将要节点(即新节点的父节点) parent = t; // 使用比较器比较父节点和插入键值对的key值的大小 cmp = cpr.compare(key, t.key); // 插入的key较大 if (cmp &lt; 0) t = t.left; // 插入的key较小 else if (cmp &gt; 0) t = t.right; // key值相等，替换并返回t节点的value(put方法结束) else return t.setValue(value); &#125; while (t != null); &#125; // 没有比较器的处理 else &#123; // key为null抛出NullPointerException异常 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 与if中的do while类似，只是比较的方式不同 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 没有找到key相同的节点才会有下面的操作 // 根据传入的键值对和找到的“父节点”创建新节点 Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); // 根据最后一次的判断结果确认新节点是“父节点”的左孩子还是又孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 对加入新节点的树进行调整 fixAfterInsertion(e); // 记录size和modCount size++; modCount++; // 因为是插入新节点，所以返回的是null return null; &#125;发现在插入过程中，会进行二叉树排序的判定：如果新增节点大于当前节点且当前节点的右子节点存在，则以右子节点作为当前节点。并继续循环如果新增节点小于当前节点且当前节点的左子节点存在，则以左子节点作为当前节点。并继续循环如果新增节点等于当前节点，则新增节点覆盖当前节点，并结束循环。TreeMap的get()方法123456public V get(Object key) &#123; //根据key取出Entry Entry&lt;K,V&gt; p = getEntry(key); //取出Entry所包含的value return (p==null ? null : p.value); &#125;关键在于 getEntry()是怎么根据Comparable取出对应Entry的。1234567891011121314151617181920212223242526272829303132final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 如果有比较器，返回getEntryUsingComparator(Object key)的结果 if (comparator != null) return getEntryUsingComparator(key); // 查找的key为null，抛出NullPointerException if (key == null) throw new NullPointerException(); // 如果没有比较器，而是实现了可比较接口 //将key强制转换为Comparable接口 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 获取根节点 Entry&lt;K,V&gt; p = root; // 从根节点开始对树进行遍历查找节点 while (p != null) &#123; // 把key和当前节点的key进行比较 int cmp = k.compareTo(p.key); // key小于当前节点的key if (cmp &lt; 0) // p “移动”到左节点上 p = p.left; // key大于当前节点的key else if (cmp &gt; 0) // p “移动”到右节点上 p = p.right; // key值相等则当前节点就是要找的节点 else // 返回找到的节点 return p; &#125; // 没找到则返回null return null;&#125;其实就是一个二叉查找，根据Comparable进行key大小的判断。如果采用定制比较器，则采用getEntryUsingComparator()方法。1234567891011121314151617181920212223242526272829final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; // 获取比较器 Comparator&lt;? super K&gt; cpr = comparator; // 其实在调用此方法的get(Object key)中已经对比较器为null的情况进行判断，这里是防御性的判断 if (cpr != null) &#123; // 获取根节点 Entry&lt;K,V&gt; p = root; // 遍历树 while (p != null) &#123; // 获取key和当前节点的key的比较结果 int cmp = cpr.compare(k, p.key); // 查找的key值较小 if (cmp &lt; 0) // p“移动”到左孩子 p = p.left; // 查找的key值较大 else if (cmp &gt; 0) // p“移动”到右节点 p = p.right; // key值相等 else // 返回找到的节点 return p; &#125; &#125; // 没找到key值对应的节点，返回null return null;&#125;参考资料1 参考资料2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 无重复字符的最长子串（String 练习 02）]]></title>
    <url>%2FLeetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例1:123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。示例2:123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。示例3:1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。思路 1暴力法，用Set记录检查的无重复的最长子串。123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; char[] chars = s.toCharArray(); if(chars.length==1) return 1; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int result = 0; for(int i=0; i &lt; chars.length-1; i++)&#123; set.add(chars[i]); for(int j=i+1; j&lt;chars.length;j++)&#123; if(!set.contains(chars[j]))&#123; set.add(chars[j]); &#125;else&#123; break; &#125; &#125; result = Math.max(result, set.size()); set.clear(); &#125; return result; &#125;&#125;思路 2滑动窗口法。暴力法虽然容易想到，但是很多情况重复考虑了。例如假定在 i ~ j 子串为不重复子串，那么该子串内的子串都会不重复。滑动窗口法 1：采用标记记录左侧窗口的索引值。12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int result = 0; char[] chars = s.toCharArray(); int leftIndex = 0; // 滑动窗口的右边索引 for(int i=0; i&lt;chars.length; i++)&#123; // 对于当前的滑动窗口进行重复性字符检查 for(int checkIndex = leftIndex; checkIndex&lt;i; checkIndex++)&#123; // 如果存在相同字符串，就更新窗口左边索引 if(chars[checkIndex]==chars[i])&#123; // 更新结果 result = Math.max(result, i-leftIndex); leftIndex = checkIndex+1; break;a &#125; &#125; &#125; // 检查最后一次窗口的长度与result保留长度进行对比 return Math.max(chars.length-leftIndex, result); &#125;&#125;滑动窗口 2：巧用 HashSet，利用HashSet维护范围为 [i,j) 的滑动窗口。先滑动右边，j++。如果存在重复，记录此时长度，再滑动左边 i++。直到所有的 i 遍历完成。12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ans=0, i=0, j=0; int len = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while(i &lt; len &amp;&amp; j &lt; len)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j-i); &#125;else&#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125;滑动窗口 3：上面的优化。如果 j 存在重复，那么 i 不仅移动一位，而是移动到 j+1 的位置。123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int ans = 0; int len = s.length(); for(int i=0, j=0; j&lt;len; j++)&#123; if(map.containsKey(s.charAt(j)))&#123; i = Math.max(i, map.get(s.charAt(j))); &#125; ans = Math.max(ans, j-i+1); map.put(s.charAt(j), j+1); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 969.煎饼排序]]></title>
    <url>%2FLeetcode-969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。示例 1:123456789输入：[3,2,4,1]输出：[4,2,4,3]解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。初始状态 A = [3, 2, 4, 1]第一次翻转后 (k=4): A = [1, 4, 2, 3]第二次翻转后 (k=2): A = [4, 1, 2, 3]第三次翻转后 (k=4): A = [3, 2, 1, 4]第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。示例 2:12345输入：[1,2,3]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如[3，3]，也将被接受。思路煎饼反转就是以数组中心索引位置为轴，两两数字交换。例如最后一个数字与第一个数字交换，倒数第二个与第二个交换。要想实现排序效果，就是依次把最大的放入最后面，这需要以下几步：找到未排序的数组里面最大的数，并记录索引。以该索引为数组边界，进行一次煎饼反转，将该数转到第一个数字。以未排序的子数组边界索引为边界，进行一次煎饼反转，将该数转到最后面。循环进行。代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;Integer&gt; pancakeSort(int[] A) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int size = A.length-1; while(size&gt;0)&#123; if(findIndex(A, size) &lt; size)&#123; // 两次反转将未排序子数组中最大的数字移到后面 // result记录反转的索引位置 result.add(findIndex(A, size)+1); reverse(A, 0, findIndex(A, size)); result.add(size+1); reverse(A, 0, size); &#125; size--; &#125; return result; &#125; // 煎饼反转算法 private static void reverse(int[] A, int i, int j)&#123; for(;i&lt;j;i++,j--)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; // 寻找当前数组的最大值所在的索引位置 private static int findIndex(int[] A, int size)&#123; int max=0, k=0; for(int i=0; i&lt;=size; i++)&#123; if(A[i]&gt;max)&#123; max = A[i]; k = i; &#125; &#125; return k; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pancake-sorting著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM如何回收对象]]></title>
    <url>%2FJVM%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[如何判断对象是否要回收？对象回收的依据——是否被有效引用？引用的可分为强引用(Strong Reference)——指向new 对象的引用、软引用(Soft Reference)——有用但没必要的引用、弱引用(Weak Reference)——没有必要的引用、虚引用(Phantom Reference)——为了在对象被回收时获得系统通知。强引用只要存在就不回收；软引用只有在内存即将不足的情况下才回收；弱引用及虚引用随便回收。怎么判断对象是否被有效引用？引用计数法。如果对象的引用计数器为0，则表示该对象可以回收。但是存在互相引用无法清理的情况。可达性分析法。通过创建一个成为“GC Root”的对象作为搜索根节点，向下搜索。如果对象到该对象之间没有引用链关联，则该对象可回收。对象死亡的判决书再对象确定没有引用的情况下，还需要判断其finalize方法没有被覆盖或者已经被执行一次（该方法只能执行一次），满足这两个条件，GC才会回收该对象。如果finalize方法被覆盖，则将该对象加入一个 “F-Queue”队列中，由虚拟机创建的、优先级低的Finalizer的线程去处理。如果对象在finalize方法中建立了与”GC Root”对象的连接链，则对象成功逃离了死亡的命运。否则，对象就被判决了死刑。垃圾回收算法标记-清理算法。根据对象是否被有效引用进行标记，然后清理无用对象。优点：简洁有效。缺点：存在空间碎片，不利于下次对象内存的分配及内存空间的合理利用。复制算法。将内存划分为两大块，一块用于存储对象，另一块用于复制准备。第一步也是标记，第二步是把不需清理的对象复制到另一块内存区域，保持这些对象在内存空间上是连续排列。优点：无碎片空间，且新对象内存空间分配便捷。缺点：二分法对空间利用率不高，且复制过程中效率不高。由于新生代中无用对象多，需要复制移动的对象少，所以该法很适合。改进版：内存划分为一块较大的Eden内存空间及两块较小的Survivor空间（默认8:1:1），一块Eden及Survivor用于分配对象，另一块用于复制准备。如果要复制的对象的内存超出了准备的Survivor，则需要其他内存（老生代）进行分配担保。标记-整理。第一步标记。第二步将存活的对象都往前移动，在内存空间中紧密排列，然后对于边界外的内存空间进行清理。分代收集算法。将内存空间分为新生代与老生代。新生代中每次垃圾回收时都会有大量对象死亡，需要复制的对象很少，因此采用复制算法。老生代对象的利用率高，存活时间长，因此采用标记-清理或者标记整理算法。垃圾回收器新生代垃圾收集器1. Serial收集器特点： Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。使用算法：复制算法2. ParNew收集器特点： ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。使用算法：复制算法3. Parallel Scavenge收集器特点： Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。使用算法：复制算法老年代垃圾收集器1. Serial Old收集器特点： Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。使用算法：标记-整理2. Parallel Old收集器特点： Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。使用算法：标记-整理3. CMS收集器特点： CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用”标记-清除”算法的并发收集器。CMS 收集器的工作过程可以分为 4 个阶段：初始标记（CMS initial mark）阶段、并发标记（CMS concurrent mark）阶段、重新标记（CMS remark）阶段、并发清除(（CMS concurrent sweep）阶段。使用算法：复制+标记清除3. G1 垃圾收集器特点： 主要步骤：初始标记，并发标记，重新标记，复制清除。使用算法：复制 + 标记整理参考:深入理解java虚拟机JVM面试突破]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 638.大礼包]]></title>
    <url>%2FLeetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85%2F</url>
    <content type="text"><![CDATA[题目在LeetCode商店中， 有许多在售的物品。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。任意大礼包可无限次购买。示例1:1234567输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释: 有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。示例2:1234567输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]输出: 11解释: A，B，C的价格分别为¥2，¥3，¥4.你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。思路 + 代码DFS + 剪枝即使暴力法，然后提出一些不满足条件的情况，即购买数量超出 (大礼包数量不对)1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; return subShoppingOffers(price, special, needs, 0); &#125; private int subShoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, int index)&#123; // index标记，顺序开始计算，防止(1,2) 与 (2,1) 的重复计算 int minCost = originalCost(price, needs); for(int i=index; i&lt;special.size(); i++)&#123; // 统计当前还需要购买多少物品 List&lt;Integer&gt; currentNeeds = new ArrayList&lt;&gt;(); // 当前礼包信息 List&lt;Integer&gt; offer = special.get(i); for(int j=0; j&lt;needs.size(); j++)&#123; // 剪枝 if(offer.get(j) &gt; needs.get(j))&#123; currentNeeds = null; break; &#125; currentNeeds.add(needs.get(j)-offer.get(j)); &#125; // 如果礼包中物品的数量没有超,则加上该礼包金额，并且继续深度优先(DFS)遍历 if(currentNeeds!=null)&#123; minCost = Math.min(minCost, offer.get(offer.size()-1)+subShoppingOffers(price, special, currentNeeds, i)); &#125; &#125; return minCost; &#125; private int originalCost(List&lt;Integer&gt; price, List&lt;Integer&gt; needs)&#123; int sum = 0; for(int i=0; i&lt;needs.size(); i++)&#123; sum += price.get(i) * needs.get(i); &#125; return sum; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shopping-offers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 运行时数据区域]]></title>
    <url>%2FJava-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[定义Java虚拟机把所管理的内存划分为不同的区域，总称为运行时数据区域。数据区域用途各不相同，有的随虚拟机启动而存在，有的随线程的生命周期存在。根据《Java虚拟机规范（Java SE7版)》规定，Java虚拟机将数据区域划分为：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）。程序计数器• 线程私有，每个线程都有一个用来记录字节码执行位置。• 一块内存区域，java虚拟机规范中唯一没有规定OutOfMemoryError的区域。• java字节码解释器通过改变计数器的值实现分支、跳转、循环、异常处理、线程恢复等操作。• 如果执行的是Java方法，则存储的是虚拟机字节码指令地址；如果是Native方法，则存储为空。Java虚拟机栈• 所谓的栈内存指的就是Java虚拟机栈。• Java方法的运行，都会生成一个栈帧，用来存储执行Java方法的局部变量、操作数栈、动态链接、方法出口等信息。• 一个Java方法的执行到结束，对应为一个栈帧的出栈与入栈。• 虚拟机栈可以为固定内存，也可动态扩展。如果线程请求栈深度大于虚拟机深度，则会报StackOverflowError;如果动态扩展时无法申请到足够内存，则会报OutOfMemoryError。本地方法栈• 与Java虚拟机栈类似，但是是为Native方法的执行提供服务。• 也会抛出StackOverflowError与OutOfMemoryError。Java堆• 各线程共享区域。• 是java虚拟机管理的最大的一块内存区域。• 是Java对象实例存储的空间。• 是垃圾收集器主要工作区域。• 存储空间逻辑上连续，物理上可以不连续。• 可设置为固定大小或动态扩展，如果动态扩展时无法申请到足够内存，则会报OutOfMemoryError。方法区• 各线程共享区域。• 用于存储已被Java虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等。• 方法区无法内存分配需求时，会抛出OutOfMemoryError。运行时常量池• 是方法区的一部分。• Class类文件中有一项是常量池，用来存放编译期生成的字面量和符号引用。• 类加载后常量池存储在方法区内的运行时常量池。• 具有动态性，非编译期间的新的常量也可放入运行时常量池中。直接内存• 不是Java虚拟机规范定义的内存区域。• JDK1.4后新加入的NI/O（New Input/Output）类，引入了仅与通道（Channel）与缓存。(Buffer)的I/O方式，可以直接通过Native函数库分配堆外内存。• 内存收到本机总内存及处理器寻址空间的限制。直接内存无法内存分配需求时，会抛出OutOfMemoryError。参考:深入理解java虚拟机]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 1046.最后一块石头的重量]]></title>
    <url>%2FLeetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目有一堆石头，每块石头的重量都是正整数。每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。提示121 &lt;= stones.length &lt;= 301 &lt;= stones[i] &lt;= 1000思路（排序 -&gt; 选最大及第二大做差 -&gt; 更新数组 -&gt; 排序）（循环 length-1 次） -&gt;最大的为结果代码1234567891011class Solution &#123; public int lastStoneWeight(int[] stones) &#123; int len = stones.length; for(int i=len-1; i&gt;=1; i--)&#123; Arrays.sort(stones); stones[len-1] = stones[len-1]-stones[len-2]; stones[len-2] = 0; &#125; return stones[len-1]; &#125;&#125;或者采用优先堆栈的方法维护数据的先后顺序123456789101112131415161718192021class Solution &#123; public int lastStoneWeight(int[] stones) &#123; int len = stones.length; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; return (b - a); &#125; &#125;); for(int i=0; i&lt;len; i++)&#123; queue.add(stones[i]); &#125; while(queue.size()&gt;1)&#123; int a = queue.poll(); int b = queue.poll(); if(a-b != 0)&#123; queue.add(a-b); &#125; &#125; return queue.isEmpty()?0:queue.poll(); &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/last-stone-weight著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Greedy Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 647.回文子串]]></title>
    <url>%2FLeetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。示例1：123输入: "abc"输出: 3解释: 三个回文子串: "a", "b", "c".示例2：123输入: "aaa"输出: 6说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".注意：1输入的字符串长度不会超过1000。思路 + 代码回文子串的内部一定是回文子串，因此关键在于重复利用回文子串已经统计过的数值。可采用双指针由回文子串向两端同时检测的方法。分为偶数回文子串与奇数回文子串。123456789101112131415161718class Solution &#123; private int sum = 0; public int countSubstrings(String s) &#123; int len = s.length(); for(int i=0; i&lt;len; i++)&#123; count(s, i, i); // 统计奇数的回文子串数量 count(s, i, i+1); //统计偶数的回文子串数量 &#125; return sum; &#125; private void count(String s, int start, int end)&#123; while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s.charAt(start)==s.charAt(end))&#123; sum++; start--; end++; &#125; &#125;&#125;思路 + 代码采用动态规划，用一个二维数组 dp[i][j] 统计字符串从 i ~ j 是否是回文子串。1234567891011121314151617181920212223242526272829303132class Solution &#123; public int countSubstrings(String s) &#123; int sum = 0; int length = s.length(); // 用dp数组存储回文子串结果，第一维为长度（有哨兵），第二维为起始位置 boolean[][] dp = new boolean[length+1][length]; for(int i=1; i&lt;length+1; ++i)&#123; for(int j=0; j&lt;length; ++j)&#123; // 所有长度为1的子串都为回文子串 if(i==1)&#123; dp[j][j] = true; sum++; &#125; // 所有长度为2的子串情况 else if(i==2)&#123; if(j+1&lt;length &amp;&amp; s.charAt(j)==s.charAt(j+1))&#123; dp[j][j+1] = true; sum++; &#125; &#125; // 长度大于3的情况 else&#123; if(j+i-1&lt;length &amp;&amp; dp[j+1][j+i-2] &amp;&amp; s.charAt(j)==s.charAt(j+i-1))&#123; dp[j][j+i-1] = true; sum++; &#125; &#125; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 983.最低票价]]></title>
    <url>%2FLeetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[题目在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。示例1：12345678输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。示例2：1234567输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。提示：123451 &lt;= days.length &lt;= 3651 &lt;= days[i] &lt;= 365days 按顺序严格递增costs.length == 31 &lt;= costs[i] &lt;= 1000思路动态规划。ans[i] = min(ans[i-1]+costs[0] + ans[i-7]+costs[1] + ans[i-30]+costs[2]);代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int mincostTickets(int[] days, int[] costs) &#123; int len = days.length; int[] results = new int[len]; for(int i=0; i&lt;len; ++i)&#123; results[i] = Integer.MAX_VALUE; &#125; // 防止一周或者一月的火车票更便宜的情况出现 int minCost = Math.min(Math.min(costs[0],costs[1]),costs[2]); results[0] = costs[0]; // 动态规划寻找最优值，分三种情况，计划时间一周内，一周到一个月，一个月以上 for(int i=1; i&lt;len; ++i)&#123; if(days[i]&lt;=7)&#123; results[i] = Math.min(minCost+results[i-1],costs[1]); &#125;else if(7&lt;days[i]&amp;&amp;days[i]&lt;=30)&#123; // 遍历具今天最近的一周外的时间 int j=i; while(days[j]&gt;days[i]-7)&#123; j--; if(j&lt;0) break; &#125; // 这种情况是如果最开始的到当前时间都在一周内，例如[5,7,8,9] int tmp0 = j&lt;0?0:results[j]; results[i] = Math.min(Math.min(results[i-1]+minCost,costs[1]+tmp0),costs[2]); &#125;else if(30&lt;days[i])&#123; // 同上 int k=i; while(days[k]&gt;days[i]-30)&#123; k--; if(k&lt;0) break; &#125; int m=i; while(days[m]&gt;days[i]-7 &amp;&amp; m&gt;0)&#123; m--; if(m&lt;0) break; &#125; int tmp1 = k&lt;0?0:results[k]; int tmp2 = m&lt;0?0:results[m]; results[i] = Math.min(Math.min(results[i-1]+minCost,costs[2]+tmp1),costs[1]+tmp2); &#125; &#125; return results[len-1]; &#125;&#125;大神的做法，扩充dp数组，实现算法的一致，即简化了代码，又提高了代码的运行效率。1234567891011121314151617class Solution &#123; public int mincostTickets(int[] days, int[] costs) &#123; boolean[] rec = new boolean[365+1]; for(int day:days) rec[day] = true; int lastDay = days[days.length-1]+30; // 扩充一个月dp数组使得判定条件一致 int[] dp = new int[366+30]; for(int i=31; i&lt;=lastDay; ++i)&#123; if(rec[i-30]) dp[i] = Math.min(Math.min(dp[i-1]+costs[0],dp[i-7]+costs[1]),dp[i-30]+costs[2]); else dp[i]=dp[i-1]; &#125; return dp[lastDay]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 11.盛最多水的容器]]></title>
    <url>%2FLeetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明: 你不能倾斜容器，且 n 的值至少为 2。思路 + 代码方法1：暴力破解法即遍历所有情况，找到最优解。123456789101112class Solution &#123; public int maxArea(int[] height) &#123; int len = height.length; int res = 0; for(int i=1; i&lt;len; i++)&#123; for(int j=0; j&lt;i; j++)&#123; res = Math.max((i-j)*Math.min(height[i], height[j]),res); &#125; &#125; return res; &#125;&#125;时间复杂度O(n^2), 空间复杂度 1方法2：双指针法两个指针，一个指向数组首，一个指向数组尾。指向数字小的往中间移动，并计算一次结果。取最优即为最终结果。原因请戳1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int last = height.length-1; int first = 0; int res = 0; while(first &lt; last)&#123; int tmp = (last-first)*Math.min(height[first], height[last]); if(height[first] &lt;= height[last])&#123; first++; &#125;else&#123; last--; &#125; res = Math.max(res,tmp); &#125; return res; &#125;&#125;时间复杂度O(n), 空间复杂度 1来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 347.前K个高频元素]]></title>
    <url>%2FLeetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目给定一个非空的整数数组，返回其中出现频率前 k 高的元素。示例1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例2:12输入: nums = [1], k = 1输出: [1]说明:12你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。思路首先用一个HashMap统计不同数字出现的次数。然后用一个最小堆维护k大小的结果。这里采用java的优先队列 PriorityQueue 去维护最小堆。这里需要注意的一点是比较器的设计，部分源代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public boolean add(E e) &#123; return offer(e); &#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125;@SuppressWarnings("unchecked")private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key;&#125;@SuppressWarnings("unchecked")private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; // 注意：这里的比较原则是当前的与栈顶元素比较，大的就进行替换，所以维护的是最小堆栈。 if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125;PriorityQueue方法参考博文代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; return map.get(a) - map.get(b); &#125; &#125;); int len = nums.length; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); // 统计各数字出现次数 for(int i=0; i&lt;len; ++i)&#123; if(map.containsKey(nums[i]))&#123; map.put(nums[i], map.get(nums[i])+1); &#125;else&#123; map.put(nums[i], 1); &#125; &#125; // 使用最小堆更新结果 for(int i:map.keySet())&#123; if(pq.size()&lt;k)&#123; pq.add(i); &#125;else&#123; if(map.get(i)&gt;map.get(pq.peek()))&#123; pq.remove(); pq.add(i); &#125; &#125; &#125; while(!pq.isEmpty())&#123; result.add(pr.poll()); &#125; return result; &#125;&#125;l]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 739.每日温度]]></title>
    <url>%2FLeetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。思路+代码最简单的思路，两次循环。1234567891011121314151617class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] results = new int[len]; for(int i=0; i&lt;len-1; i++)&#123; int tmp = 0; for(int j=i+1; j&lt;len; j++)&#123; if(T[j]&gt;T[i])&#123; results[i]=tmp+1; break; &#125; tmp++; &#125; &#125; return results; &#125;&#125;利用栈栈的特性是先进后出，所以需要从后往前遍历。维护一个递减数据的索引（天）序列。如果当前数据（温度）大于等于栈顶索引（天）对应的数据（温度），则更新栈内数据，保持递减特性。否则计算当前数据索引（天）与栈顶所索引（天）为结果值。123456789101112131415161718class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] results = new int[len]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=len-1; i&gt;=0; --i)&#123; while(!stack.isEmpty() &amp;&amp; T[i] &gt;= T[stack.peek()])&#123; stack.pop(); &#125; if(!stack.isEmpty()) // 更新结果值 results[i] = stack.peek() - i; // 维护递减序列 stack.push(i); &#125; return results; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/daily-temperatures著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 287.寻找重复数]]></title>
    <url>%2FLeetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。示例1：12输入: [1,3,4,2,2]输出: 2示例2：12输入: [3,1,3,4,2]输出: 3说明：1234不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。思路 + 代码易想到方法不符合题目要求，因为需要额外的空间。用链表或者HashMap存储数值，遇到相同的已存储的数就返回。空间复杂度最坏O(n)，时间复杂度最坏O(n)。或者先排序，遇到相同的数返回。时间复杂度视排序方法而定，最好O(log(n))。巧妙算法1巧用快慢指针。数组的索引与存储的数值之间形成了特殊链表。如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。环的入口即为结果。答案的求解变成环入口的求解。思路123456789101112131415161718class Solution &#123; public int findDuplicate(int[] nums) &#123; // 快慢指针 int fast = nums[0]; int low = nums[0]; do&#123; low = nums[low]; fast = nums[nums[fast]]; &#125;while(fast != low); int step = nums[0]; // 寻找环链表的入口，即为结果 while(step != low)&#123; step = nums[step]; low = nums[low]; &#125; return low; &#125;&#125;巧妙算法2二分法。统计小于中间数 mid 的数值数量，如果大于，则在0~mid之间寻找。反之，则在mid~high中寻找。最终找到重复的数值。123456789101112131415161718192021class Solution &#123; public int findDuplicate(int[] nums) &#123; // 二分法 int len = nums.length; int low = 0; int hight = len-1; while(low&lt;hight)&#123; int count = 0; int mid = low+(hight-low)/2; for(int i=0; i&lt;len; i++)&#123; if(nums[i]&lt;=mid) count++; &#125; if(count&lt;=mid) low = mid+1; else hight = mid; &#125; return low; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 746.使用最小花费爬楼梯]]></title>
    <url>%2FLeetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[题目数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。示例1：123输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例2：123输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。注意：121. cost 的长度将会在 [2, 1000]。2. 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。思路典型的动态规划问题，上楼梯问题。注意的是，最后的结果是最后一阶楼梯与倒数第二个楼梯中取最小值。代码123456789101112131415161718class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len = cost.length; if(len==2) return(Math.min(cost[0], cost[1])); int[] result = new int[len]; result[0]=cost[0]; result[1]=cost[1]; for(int i=2; i&lt;len; i++)&#123; result[i] = Math.min(result[i-1], result[i-2])+cost[i]; &#125; // noted return Math.min(result[len-2], result[len-1]); &#125;&#125;`来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 102.二叉树的层次遍历]]></title>
    <url>%2FLeetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7返回其层次遍历结果：12345[ [3], [9,20], [15,7]]思路 + 代码二叉树相关算法题两种解题思路：递归和迭代。递归方法用一个辅助函数，更新结果。记录遍历的层数，并按照从左到右的顺序依次在相应层数List中记录数值。返回结果。代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public void helper(TreeNode root, int level)&#123; // 更新记录List if(results.size()==level) results.add(new ArrayList&lt;Integer&gt;()); // 从左到右记录数据 results.get(level).add(root.val); if(root.left!=null) helper(root.left, level+1); if(root.right!=null) helper(root.right, level+1); &#125; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null) return results; helper(root, 0); return results; &#125;&#125;迭代方法:用队列辅助，先进的节点先出。层层进队列，然后层层出队列，存入结果results中。代码:12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(root==null) return results; queue.add(root); int level = 0; while(!queue.isEmpty())&#123; results.add(new ArrayList&lt;Integer&gt;()); int levelLength = queue.size(); // 将level层元素依次存入List，level+1层节点依次入队列 for(int i=0; i&lt;levelLength; ++i)&#123; // 改成节点出队列 root = queue.remove(); // 按层存入 results.get(level).add(root.val); // 下一层节点入队列 if(root.left!=null) queue.add(root.left); if(root.right!=null) queue.add(root.right); &#125; level++; &#125; return results; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 94.二叉树的中序遍历]]></title>
    <url>%2FLeetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，返回它的中序 遍历。示例:12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2]进阶:递归算法很简单，你可以通过迭代算法完成吗？思路 + 代码递归方法递归截止条件：root==null递归执行条件：list.add(inorderTraversal(root.left))list.add(root.val)list.add(inorderTraversal(root.right))代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null) return list; List&lt;Integer&gt; 递归算法很简单，你可以通过迭代算法完成吗？ List&lt;Integer&gt; rightList = inorderTraversal(root.right); for(int i=0; i&lt;leftList.size(); i++)&#123; list.add(leftList.get(i)); &#125; list.add(root.val); for(int i=0; i&lt;rightList.size(); i++)&#123; list.add(rightList.get(i)); &#125; return list; &#125;&#125;迭代方法用一个栈存储遍历过得父子节点，循环遍历。代码12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); // 当树没有遍历完全 while(root!=null || !stack.isEmpty())&#123; // 找到当前树的最左侧叶子节点（父节点） while(root!=null)&#123; stack.push(root); root=root.left; &#125; // 中序遍历 root = stack.pop(); list.add(root.val); root = root.right; &#125; return list; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 215.数组中第K个最大元素]]></title>
    <url>%2FLeetcode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:12输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2::12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4思路 + 代码简单办法，最容易想到的：用一个长度为 k 存储最大到第k大的数，然后返回数组最后一个元素，即为结果。1234567891011121314151617181920212223class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; // 数组初始化 int[] results = new int[k]; for(int i=0; i&lt;k; i++)&#123; results[i] = Integer.MIN_VALUE; &#125; // 特殊情况处理 int len = nums.length; if(len&lt;2) return nums[0]; // 维护结果数组的值 for(int i=0; i&lt;len; i++)&#123; for(int j=0; j&lt;k; j++)&#123; if(nums[i]&gt;results[j])&#123; System.arraycopy(results,j,results,j+1,k-1-j); results[j] = nums[i]; break; &#125; &#125; &#125; return results[k-1]; &#125;&#125;执行用时 :74 ms, 在所有 Java 提交中击败了18.90%的用户内存消耗 :40.5 MB, 在所有 Java 提交中击败了35.28%的用户答案里的方法：桶排序，非常好理解，先遍历一遍数组找出最大最小值。创建一个桶，长度为max-min+1，桶的引对应于与Min的差值，桶中装的元素为该值出现次数。1234567891011121314151617181920class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int max=Integer.MIN_VALUE; int min=Integer.MAX_VALUE; for(int num:nums)&#123; max=Math.max(max,num); min=Math.min(min,num); &#125; int[] bucket=new int [max-min+1]; for(int num:nums)&#123; bucket[num-min]++; &#125; int count=0; for(int i=bucket.length-1;i&gt;=0;i--)&#123; count+=bucket[i]; if(count&gt;=k) return min+i; &#125; return -1; &#125;&#125;执行用时 :2 ms, 在所有 Java 提交中击败了99.61%的用户内存消耗 :37.8 MB, 在所有 Java 提交中击败了94.49%的用户]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 105.从前序与中序遍历序列构造二叉树]]></title>
    <url>%2FLeetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目根据一棵树的前序遍历与中序遍历构造出二叉树。注意:你可以假设树中没有重复的元素。例如，给出12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \9 20 / \ 15 7思路先序遍历：先根节点 后左子树 最后右子树中序遍历：先左子树 再根节点 最后右子树所以先序遍历的第一个数值为根节点，在中序遍历中找到根节点位置，前面为左子树的中序遍历，后面为右子树的中序遍历。Java代码如下:123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder==null || inorder==null) return null; if(preorder.length==0 || inorder.length==0)&#123; return null; &#125; if(preorder.length!=inorder.length)&#123; return null; &#125; TreeNode root = new TreeNode(preorder[0]); int len = preorder.length; for(int i=0; i&lt;len; i++)&#123; if(inorder[i]==preorder[0])&#123; root.left = buildTree(Arrays.copyOfRange(preorder,1,i+1), Arrays.copyOfRange(inorder,0,i)); root.right = buildTree(Arrays.copyOfRange(preorder,i+1,len),Arrays.copyOfRange(inorder,i+1,len)); &#125; &#125; return root; &#125;&#125;Python代码如下：1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ if not preorder: return None x = preorder.pop(0) node = TreeNode(x) idx = inorder.index(x) node.left = self.buildTree(preorder[:idx], inorder[:idx]) node.right = self.buildTree(preorder[idx:], inorder[idx+1:]) return node]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 101.对称二叉树]]></title>
    <url>%2FLeecode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \ 2 2 / \ / \3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \2 2 \ \ 3 3说明:如果你可以运用递归和迭代两种方法解决这个问题，会很加分。思路二叉树的一个典型套路就是递归求解。左右树分别对待。注意递归截止条件以及是否对称的判断条件。代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; return tryTree(root.left, root.right); &#125; public boolean tryTree(TreeNode left, TreeNode right)&#123; // 递归截止条件 if(right==null&amp;&amp;left==null) return true; if(left==null||right==null) return false; // 对称判断条件 if(left.val==right.val) return tryTree(left.left, right.right)&amp;&amp;tryTree(left.right, right.left); return false; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 48.旋转图像]]></title>
    <url>%2FLeecode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。示例1：12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]]示例2：123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]]思路如果可以拷贝矩阵，则可以每一行与每一列同时旋转。但是要求在原矩阵中操作，所以需要每一个元素进行位置旋转变换。一个4*4的矩阵如下图所示：顺时针旋转即相同颜色的元素进行依次替换。对于四阶矩阵，先从最外圈i=0开始，到里圈i=1结束。n+1阶矩阵从最外圈i=0开始，i=n/2里圈结束。每j圈依次从j行第i个元素开始，n-i个元素结束。四个元素互换条件：tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp;代码123456789101112131415161718class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length-1; int tmp; // 循环几圈 for(int i=0; i&lt;=n/2;i++)&#123; // 每一圈要交换几轮 for(int j=i;j&lt;n-i;j++)&#123; // 四个元素依次交换 tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; &#125; &#125; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 155.最小栈]]></title>
    <url>%2FLeecode-155-%E6%9C%80%E5%B0%8F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2.思路1可以用两个栈，一个栈用来维护当前栈内最小的元素，一个栈用来维度当前栈内的元素。属于投机取巧的方法。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.isEmpty() || x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; public void pop() &#123; // 注意，peek()方法返回的是Integer对象，而java在比较Integer时数据范围在-128~127用 == 比较是相等的，但是 // 超过这个范围就是不相等的。这是因为常量池范围内地Integer对象都是同一个，而 == 是比较对象是否为同一个对象 // 如果比较数值是否相等，应该采用Integer重写的equals()方法!!! if(stack.peek().equals(minStack.peek()))&#123; minStack.pop(); &#125; stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */思路2自己用数组实现元素栈与存储最小元素的栈。要点，数组的自动扩容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MinStack &#123; private int[] minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = new int[10]; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) resize(); data[index] = x; if(index==0 || x &lt;minValue[index-1])&#123; minValue[index]=x; &#125;else&#123; minValue[index] = minValue[index-1]; &#125; &#125; public void pop() &#123; index--; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue[index]; &#125; public void resize()&#123; int[] newdata = new int[data.length*2]; int[] newMinValue = new int[data.length*2]; System.arraycopy(data,0,newdata,0,data.length); System.arraycopy(minValue,0,newMinValue,0,minValue.length); data = newdata; minValue = newMinValue; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */或者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MinStack &#123; private int minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = Integer.MAX_VALUE; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) data = Arrays.copyOf(data, data.length*2); data[index] = x; if(x &lt; minValue)&#123; minValue = x; &#125; &#125; public void pop() &#123; index--; if(data[index+1]==minValue)&#123; minValue = Integer.MAX_VALUE; for(int i=0; i&lt;=index; i++)&#123; if(data[i]&lt;minValue)&#123; minValue = data[i]; &#125; &#125; &#125; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue; &#125; &#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 448.找到所有数组中消失的数字]]></title>
    <url>%2FLeecode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。示例：12345输入:[4,3,2,7,8,2,3,1]输出:[5,6]思路将出现数字位置的数置为负数。关键点：置负数时一定取绝对值后取负数，否则会出现负负得正的情况。例如：1[2,1,2,4]1[-2,-1,2,-1]代码123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]); &#125; for(int i=0;i&lt;len;i++)&#123; if(nums[i]&gt;0)&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 234.回文链表]]></title>
    <url>%2FLeecode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目请判断一个链表是否为回文链表。示例1：12输入: 1-&gt;2输出: false示例2：12输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？思路用 栈+快慢指针 或者 快慢指针+反转链表快慢指针是用来寻找中间节点。栈是用来反转链表。代码栈 + 快慢指针1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; // 栈用来反转链表 Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); ListNode fast = head; ListNode low = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; stack.push(low); low = low.next; // 奇数链表中间位置需要往后移动一位 if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; // 循环遍历前后链表是否相等 while(!stack.empty())&#123; if(stack.pop().val!=low.val) return false; low = low.next; &#125; return true; &#125;&#125;快慢指针 + 反转链表12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; ListNode fast = head; ListNode low = head; // 快慢指针找到中间点 while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; low = low.next; if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; ListNode compNode = reverseLinkedList(low); // 链表前后判断 while(compNode!=null)&#123; if(compNode.val!=head.val) return false; compNode = compNode.next; head = head.next; &#125; return true; &#125; // 反转链表 public ListNode reverseLinkedList(ListNode head)&#123; ListNode preNode = null; ListNode curNode = head; while(curNode!=null)&#123; ListNode temp = curNode.next; curNode.next = preNode; preNode = curNode; curNode = temp; &#125; return preNode; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 70.爬楼梯]]></title>
    <url>%2FLeecode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。示例1:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶示例2:123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶思路递归或者动态规划。第n阶楼梯的走法 = 第n-1阶楼梯走法 + 第n阶楼梯走法。边界条件，n&lt;=3。代码1234567891011121314// 动态规划class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; int[] dp = new int[n]; for(int i=0;i&lt;3;i++)&#123; dp[i] = i+1; &#125; for(int i=3; i&lt;n; i++)&#123; dp[i]=dp[i-2]+dp[i-1]; &#125; return dp[n-1]; &#125;&#125;1234567// 递归class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; return climbStairs(n-2) + climbStairs(n-1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 198.打家劫舍]]></title>
    <url>%2FLeecode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%2F</url>
    <content type="text"><![CDATA[题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例1：1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例2：1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。思路动态规划用一个数组维护截止到当前偷窃的最大值。更新条件：dp[i]=max(nums[i]+dp[i-1], dp[i-1])。代码123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if(len == 0) return 0; if(len == 1 ) return nums[0]; if(len == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i=2; i&lt;len; i++)&#123; dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); &#125; return dp[len-1]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 53.最大子序和]]></title>
    <url>%2FLeecode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例：123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。思路动态规划。用一个数组维护一个包含当前数字的最大子序列，取该数组的最大值即为结果。代码12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; int len = nums.length; int result = nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; for(int i=1; i&lt;len; i++)&#123; dp[i] = Math.max(dp[i-1]+nums[i], nums[i]); result = Math.max(dp[i], result); &#125; return result; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 538.二叉搜索树转换为累加树]]></title>
    <url>%2FLeecode-538-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。二叉搜索树：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。思路因为二叉搜索树左子树、根节点及右子树已经拍好顺序，所以只需遍历右子树计算累加值，然后对根节点与左子树分别累加。可采用递归或遍历方法。首先累加右子树数值，然后依次修改根节点与左子树的数值。代码1 递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; if(root == null) return null; convertBST(root.right); root.val +=sum; sum = root.val; convertBST(root.left); return root; &#125;&#125;代码2 遍历123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; rightNodeStack = new Stack&lt;TreeNode&gt;(); TreeNode node = root; while(node!=null || !rightNodeStack.isEmpty())&#123; while(node!=null)&#123; rightNodeStack.add(node); node = node.right; &#125; node = rightNodeStack.pop(); node.val += sum; sum = node.val; node = node.left; &#125; return root; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题-移动零]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:1. 必须在原数组上操作，不能拷贝额外的数组。2. 尽量减少操作次数。思路1采用双循环，当遇到零元素时，与后面序列中第一个非零元素交换。时间复杂度: $O(n!)$结果:执行用时 : 16 ms内存消耗 :37.4 MB代码12345678910111213141516class Solution &#123; public void moveZeroes(int[] nums) &#123; int len = nums.length; for(int i=0;i&lt;len-1;i++)&#123; if(nums[i]==0)&#123; int j =i+1; while(j&lt;len&amp;&amp;nums[j]==0)&#123; j++; &#125; if(j==len) break; nums[i]=nums[j]; nums[j]=0; &#125; &#125; &#125;&#125;思路2评论中高赞方法是采用双指针的方式。先将非零元素按照顺序紧密移动到前面，再按照零元素数量对数组后面元素补零。代码2123456789101112131415class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int len = nums.length; for(int j=0; j&lt;len; j++)&#123; if(nums[j]!=0)&#123; nums[i]=nums[j]; i++; &#125; &#125; for(; i&lt;len; i++)&#123; nums[i] = 0; &#125; &#125;&#125;结果执行用时 : 1 ms内存消耗 :39.3 MB题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题-合并两个有序链表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例1：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4思路1分为两步：第一步： 记录所有的链表的数值并排序。因为链表的长度未知，所以需要用 List 来存储。第二步： 按照排序后的链表数值，建立对应链表。代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null&amp;&amp;l2==null) return null; if(l1!=null&amp;&amp;l2==null) return l1; if(l1==null&amp;&amp;l2!=null) return l2; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(l1!=null)&#123; list.add(l1.val); l1=l1.next; &#125; while(l2!=null)&#123; list.add(l2.val); l2=l2.next; &#125; Collections.sort(list); int size = list.size(); ListNode result = new ListNode(list.get(0).intValue()); ListNode pev = result; for(int i=1;i&lt;size;i++)&#123; ListNode tmp = new ListNode(list.get(i).intValue()); pev.next = tmp; pev = tmp; &#125; return result; &#125;&#125;思路2官方题解：采用递归方法。终止条件：l1 = null 或者 l2 = null。判断条件：if(l1.val&lt;l2.val): mergeTwoLists(l1.next, l2)else: mergeTwoLists(l1, l2.next)代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125;思路3官方题解：采用递归。时间复杂度与空间复杂度最优。关键在于设计哨兵节点，记录前一个节点。代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; preNode.next = l1; l1 = l1.next; &#125;else&#123; preNode.next = l2; l2 = l2.next; &#125; preNode = preNode.next; &#125; preNode.next = l1==null?l2:l1; return preHead.next; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题：计算众数]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E8%AE%A1%E7%AE%97%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。示例1：12输入: [3,2,3]输出: 3示例2：12输入: [2,2,1,1,1,2,2]输出: 2思路 + 代码法1. 我的方法，超笨。用一个Map记录数字出现的次数，然后当次数大于n/2时返回。代码12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; if(map.get(nums[i])!=null)&#123; Integer num = map.get(nums[i]); map.put(nums[i], num+1); &#125;else&#123; map.put(nums[i], 1); &#125; if(map.get(nums[i])&gt;len/2) return nums[i]; &#125; return 0; &#125;&#125;法2. 先排序，后取中位数代码略法3. 用一个变量count计数，从0开始，遇到相同的+1，遇到不同的-1，变为零则重新计数。代码12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int len = nums.length; int num = nums[0]; for(int i=1; i&lt;len; i++)&#123; if(num==nums[i]) count++; else count--; if(count==0) &#123; num = nums[i]; count = 1; &#125; &#125; return num; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题：反转链表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述反转一个单链表。示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？思路方案1采用迭代方法，及循环迭代。用一个变量存储上一节点对象，一个变量存储当前节点对象，一个对象存储下一节点对象。代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while(curr!=null)&#123; ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125;&#125;方案2采用递归，先递归找到原链表尾巴作为头节点，再依次反转链表。head.next.next = head;head.next = null;代码1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题：子集]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[求一个数组的所有子集数组给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]思路从前往后遍历，新子集就是原子集加上新加的数。代码1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; List&lt;Integer&gt; inList = new ArrayList&lt;&gt;(); list.add(inList); for(int i=0; i&lt;len; i++)&#123; int size = list.size(); for(int j = 0; j&lt;size; j++)&#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list.get(j)); newList.add(nums[i]); list.add(newList); &#125; &#125; return list; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题：二叉树相关]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7思路递归算法，每棵树都由子树构成，根节点融合可以通过递归拆分成子树进行。代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125;二叉树最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。示例:给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \9 20 / \ 15 7返回它的最大深度 3 。思路同上，树划分成两棵树，递归求解。代码12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125;题目链接N叉树的最大深度给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。例如，给定一个 3叉树 :我们应返回其最大深度，3。说明:树的深度不会超过 1000。树的节点总不会超过 5000。思路+代码类比二叉树最大深度，迭代求解。12345678910111213141516171819202122232425/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public int maxDepth(Node root) &#123; if(root==null) return 0; int depth = 0; for(int i=0; i&lt;root.children.size(); i++)&#123; depth = Math.max(maxDepth(root.children.get(i)),depth); &#125; return depth+1; &#125;&#125;翻转二叉树翻转一棵二叉树。示例：输入:12345 4 / \ 2 7 / \ / \1 3 6 9输出:12345 4 / \ 7 2 / \ / \9 6 3 1备注:这个问题是受到 Max Howell 的 原问题 启发的 ：谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。思路so easy! 递归完事了。代码12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; TreeNode obj = root.left; root.left = root.right; root.right = obj; invertTree(root.right); invertTree(root.left); return root; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题：位运算相关]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例1:12输入: [2,2,1]输出: 1示例2:12输入: [4,1,2,1,2]输出: 4思路由于时间复杂度与空间复杂度的限制，这道题目解决办法一定是很巧妙的。答案是采用异或的方法。Java的异或^是位运算的一种，含义是相同的位数置 0 ，相异的位数置 1 。数字本身(相同数字)的异或结果为 0 ，0 与任何数字的异或结果为其本身。Hash Map中的hash码映射到数组位置就采用了异或的方法，(h=key.hashcode())^(h&gt;&gt;16);例如:0000 0000 0000 1011 ^0000 0000 0000 11110000 0000 0000 0100代码12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; int len = nums.length; for(int i=0; i&lt;len; i++)&#123; result = result^nums[i]; &#125; return result; &#125;&#125;汉明距离题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 231.示例：12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。思路先异或运算 ^ 将相同位置不同数字的置为 1 。再通过移位， 与 1 进行 与 &amp; 运算，计算出结果。代码1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x^y; int result = 0; // 计算二进制表示中 1 的数量 while(z&gt;0)&#123; if((z &amp; 1) == 1)&#123; result ++; &#125; z &gt;&gt;= 1; &#125; return result; &#125;&#125;计算m的n次方例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:m^1101 = m^0001 * m^0100 * m^1000。代码12345678910111213141516public class Pow &#123; public static int pow(int m, int n) &#123; int sum = 1; int tmp = m; while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; // 几个1乘几次 sum *= tmp; &#125; // 第二位乘两次，第三位乘四次... tmp *= tmp; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125;不用辅助变量交换两个数用异或运算 ^ ，相同的数异或为 0 ,且支持交换律与结合律。伪代码123x = x^y;y = x^y;x = x^y;比特位计数给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。示例1:12输入: 2输出: [0,1,1]示例2:12输入: 5输出: [0,1,1,2,1,2]进阶:给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。最容易想到方法12345678910111213141516class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=0; i&lt;=num; i++)&#123; int count = 0; int t = i; while(t &gt; 0)&#123; if((t &amp; 1) == 1) count++; t &gt;&gt;= 1; &#125; result[i] = count; &#125; return result; &#125;&#125;当前数字的比特位数量等于左移一位数字的比特位数量加上（当前数字&amp;1）123456789class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=1; i&lt;=num; i++)&#123; result[i] = result[i&gt;&gt;1] + (i &amp; 1); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm-排序算法]]></title>
    <url>%2FAlgorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[插入排序每次遍历都将对应位置的数字插入到合适的位置，当前位置之前的数据保持排序。代码12345678910111213141516public class InsertionSort &#123; public static int[] sort(int[] arr)&#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr, 0, A, 0, len); int i,j; for (i = 1; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j - 1] &gt; temp; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; return A; &#125;&#125;冒泡排序每次将最大的(或最小的)沉入数组最底层。代码123456789101112131415161718public class BubbleSort &#123; public static int[] sort(int[] arr) &#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr,0, A, 0, len); for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-i; j++) &#123; if(A[j]&gt;A[j+1])&#123; // 无需中介的数值互换方法 A[j] += A[j+1]; A[j+1] = A[j] - A[j+1]; A[j] -= A[j+1]; &#125; &#125; &#125; return A; &#125;&#125;转自知乎(插入、冒泡图片来源，侵删)快速排序每次找出一个基准，作为划分标准。方法类似于二分法，每次都把小于基准的数放于基准数组的左边，把大于基准的数放于数组的右边。算法不稳定，时间复杂度最好$O(nlog(n))$，最差$O(n^2)$当数组本来是排序好的，例如是顺序排列，此时要计算逆序排列，如果利用快排方法，则时间复杂度为$O(n^2)$，当然，此时的基准选取是头部或者尾部。所以基准的选取很重要，常见得有随机选取、取首或末端的数及三数中值法（取首末及中间位置三个数的中值）。理论上，选取的基准是所有数的中位数，则划分最均匀，用时最短。选取末尾值作为基准1234567891011121314151617181920212223242526272829303132333435363738394041public class QuickSort &#123; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = A[right]; int i = left; int j = right; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right] = A[i]; A[i] = criterion; return i; &#125;&#125;优化的快速排序采用三值法作为划分基准，并在数据量不大时采用插入排序，提高效率。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class QuickSort &#123; private int threshold = 4; QuickSort()&#123;&#125;; QuickSort(int i) &#123; this.threshold = i; &#125; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 小数据情况下递归方法需要调用栈，效率较低，此时采用插入排序方法 if(right-left&gt;4)&#123; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125;else &#123; insertionSort(A); &#125; &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = getMedianPivot(A, left, right); // 从第二个及倒数第二个开始，因为getMedianPivot已经对首末数值进行了排序 int i = left+1; int j = right-1; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right-1] = A[i]; A[i] = criterion; return i; &#125; private int getMedianPivot(int[]A, int left, int right)&#123; int center = (left+right)/2; // 对于首末及中间的数进行排序 if (A[left] &gt; A[center]) &#123; swap(A, left, center); &#125; if (A[center] &gt; A[right]) &#123; swap(A, center, right); &#125; if (A[left] &lt; A[right]) &#123; swap(A, left, right); &#125; //交换中间与倒数第二个数，因为经过排序，最后一个已经是最大 swap(A, center, right-1); return A[right-1]; &#125; private void swap(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; private void insertionSort(int[] A) &#123; int len = A.length; int i,j; for (i = 0; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j] &lt; A[j - 1]; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; &#125;&#125;1.参考资料 2.参考资料十大排序算法讲解推荐(快排图片来源，侵删)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux终端常用指令]]></title>
    <url>%2FLinux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令集指令作用pwd打印当前工作目录hostname获取我的计算机的网络名称mkdir创建目录cd更改目录ls列出目录下的文件rmdir删除目录pushdpush directorypopdpop directorycp复制文件或目录mv移动/重命名文件或目录less按页查看文件cat输出整个文件xargs执行参数find查找文件grep查找文件里面的东西man阅读帮助手册aproposfind what man page is appropriateenv查看计算机环境echo输出一些参数export设置一个新的环境变量exit退出终端sudo危险! 拥有超级用户权限!sudo rm –rf /*赶紧跑路吧！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题--买卖股票的最佳时机]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目1给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例11234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例212345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例3123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路贪心算法，通过计算局部最优，综合多个局部最优结果得到全局最优结果一次循环，只要第二天股票价格比当天高，就买入，否则不买入。计算当天买入跟第二天卖出的利润和，即为结果。并不一定要在最低值买入，在最高点卖出。因为每次低买高卖的累积和等于最低点与最高点之间的收益。代码1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int result = 0; for(int i=0; i&lt;=prices.length-2; i++)&#123; if(prices[i]&lt;prices[i+1])&#123; result += prices[i+1]-prices[i]; &#125; &#125; return result; &#125;&#125;题目链接题目2给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。示例 1：12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.注意 :1230 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000.思路简单DP问题当前的状态 i 共有两种，持有股票与不持有股票持有股票状态可能是 前一状态买入 或者 当前买入:收益方程：$buy_{profit}^i=max(buy_{profit}^{i-1}, sell_{profit}^{i-1}-prices[i])$不持有股票可能是 前一状态卖出 或者 当前卖出:收益方程：$sell_{profit}^i=max(sell_{profit}^{i-1}, prices[i]+buy_{profit}^i-fee)$代码1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len&lt;2) return 0; //没有stock的收益 int sell_profit = 0; //拥有stock的收益 int buy_profit = -prices[0]; for(int i=1; i&lt;len; i++)&#123; //今天卖了或者之前卖了的收益 sell_profit = Math.max(sell_profit, prices[i]+buy_profit-fee); //今天买了或者之前买了的收益 buy_profit = Math.max(buy_profit, sell_profit-prices[i]); &#125; //卖了股票的收益肯定大于持有股票的收益，因为持有股票是负收益 return sell_profit; &#125;&#125;题目链接题目3给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。示例1：1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例2：123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路动态规划问题。维护一个值，存储之前i-1天的最大利润，当前i天的最大利润为当前价格与前i-1天价格最小值的差值与i-1最大利润的较大值。代码123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len&lt;2) return 0; int result = -prices[0]; int min_price = prices[0]; for(int i=1; i&lt;len; i++)&#123; result = Math.max(result, prices[i]-min_price); if(prices[i]&lt;min_price) min_price = prices[i]; &#125; return result&lt;0?0:result; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Greedy Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum-Falling-Path-Sum]]></title>
    <url>%2FMinimum-Falling-Path-Sum%2F</url>
    <content type="text"><![CDATA[下降路径最小和题目细节给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。示例112输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12解释：可能的下降路径有：123[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。提示121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100思路典型的二维动态数组题目。创建一个二维的数组A[row][column]存储结果，每一个位置存储的是第一行到该位置最小的下降路径。一般情况1A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]);前后两列情况12第一列: A[i][j] += min(A[i-1][j],A[i-1][j+1]);最后一列: A[i][j] += min(A[i-1][j-1],A[i-1][j]);Algorithm123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minFallingPathSum(int[][] A) &#123; int row = A.length; int col = A[0].length; if(row==1)&#123; return A[0][0]; &#125; for(int i=1;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; if(j-1&lt;0)&#123; A[i][j] += min(A[i-1][j],A[i-1][j+1]); &#125; else if(j+1&gt;col-1)&#123; A[i][j] += min(A[i-1][j-1],A[i-1][j]); &#125; else&#123; A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]); &#125; &#125; &#125; int result = Integer.MAX_VALUE; for(int i=0;i&lt;col;++i)&#123; if (A[row-1][i] &lt; result) &#123; result = A[row-1][i]; &#125; &#125; return result; &#125; public int min(int a, int b)&#123; return (a&lt;=b?a:b); &#125;&#125;题目链接类似题目]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Third Maximum Number]]></title>
    <url>%2FAlgorithm-Third-Maximum-Number%2F</url>
    <content type="text"><![CDATA[1. Third Maximum NumberTitle DetailGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).Example 1:123Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:123Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:12Input: [2, 2, 3, 1]Output: 1Explanation:Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum.思路因为要求算法的时间复杂度为O(n)，所以不能用排序的方法。因为只求第三大的数，跟求第一大的数原理类似，只不过注意边界条件。Algorithm1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int thirdMax(int[] nums) &#123; if(nums.length==1) return nums[0]; if(nums.length==2) return Math.max(nums[0], nums[1]); int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; int max3 = Integer.MIN_VALUE; int flag = 0; boolean f = true; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;max1)&#123; max3=max2; max2=max1; max1=nums[i]; ++flag; continue; &#125; if(max1&gt;nums[i] &amp;&amp; nums[i]&gt;max2)&#123; max3=max2; max2=nums[i]; ++flag; continue; &#125; if(max2&gt;nums[i] &amp;&amp; nums[i]&gt;max3)&#123; max3=nums[i]; ++flag; continue; &#125; // 边界条件，如果有多个最小值，则只算一次 if(nums[i]==Integer.MIN_VALUE&amp;&amp;f)&#123; flag++; f = false; continue; &#125; &#125; return (flag&lt;3?max1:max3); &#125;&#125;题目链接2. Smallest Range ITitle DetailGiven an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i].After this process, we have some array B.Return the smallest possible difference between the maximum value of B and the minimum value of B.Example 1:123Input: A = [1], K = 0Output: 0Explanation: B = [1]Example 2:123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8]Example 3:123Input: A = [1,3,6], K = 3Output: 0Explanation: B = [3,3,3] or B = [4,4,4]Note:1231 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 100000 &lt;= K &lt;= 10000思路求出数组最大值与最小值的差值，比较差值与K/2的关系。Algorithm1234567891011121314151617class Solution &#123; public int smallestRangeI(int[] A, int K) &#123; if(A.length==0) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(int i=0; i&lt;A.length; i++)&#123; if(A[i]&lt;min) min = A[i]; if(A[i]&gt;=max) max = A[i]; &#125; int len = max-min; if(len&gt;2*K) return len-2*K; else return 0; &#125;&#125;题目链接3. 数组形式的整数加法题目细节对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。示例1：123输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234示例2：123输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455示例3：123输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021示例4：123输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000提示：12341 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 90 &lt;= K &lt;= 10000如果 A.length &gt; 1，那么 A[0] != 0思路最初思路是字符串转数字，相加后转字符串。但是最终没过，因为数据量太大，不允许。后又通过进位方式实现，老太太的裹脚布。Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int len = A.length; for(int i=len-1; i&gt;=0; --i) &#123; int temp = A[i] + K; if (temp &gt;= 10) &#123; A[i] = temp % 10; K = temp / 10; &#125; else &#123; A[i] = temp; K = temp /10; break; &#125; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (K!=0)&#123; String s = String.valueOf(K); for(char c: s.toCharArray()) result.add(c-'0'); &#125; for (int i : A) &#123; result.add(i); &#125; return result; &#125;&#125;官方答案123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int N = A.length; int cur = K; List&lt;Integer&gt; ans = new ArrayList(); int i = N; while (--i &gt;= 0 || cur &gt; 0) &#123; if (i &gt;= 0) cur += A[i]; ans.add(cur % 10); cur /= 10; &#125; Collections.reverse(ans); return ans; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java：List API]]></title>
    <url>%2FJava-ArrayList-API%2F</url>
    <content type="text"><![CDATA[Java List常用类型类型特征ArrayList随机访问元素快；中间插入与删除元素较慢；操作不是线程安全的LinkedList中间插入与删除操作代价较低，提供优化的顺序访问；随机访问元素慢ArrayListArrayList的UML类图如下所示：ArrayList 继承了 AbstractList, 直接实现了 Cloneable, Serializable，RandomAccess 类型标志接口。AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的 for 循环方式，并且执行效率上给迭代器方式更高。Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 clone 方法，实现 ArrayList 的拷贝。Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 serialVersionUID 属性值。ArrayList 常用 API方法描述boolean add(E object)再 ArrayList 尾存入对象void add(int location, E object)在 location 添加对象boolean addAll(Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入boolean addAll(int location, Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入locationboolean contains(Object object)是否包对象 objectboolean containsAll(Collection&lt;?&gt; collection)是否包含一个 Collection 对象boolean isEmpty()ArrayList 是否为空E get(int location)获取 location 的对象E set(int location, E object)将某个位置的元素替换成 objectint indexOf(Object object)获取某个对象的位置（顺序遍历第一个）int lastIndexOf(Object object)获取某个对象的位置（逆序遍历第一个）int size()返回 ArrayList 存储的对象数量boolean remove(Object object)删除存储的某个对象E remove(int lcoation)删除位于 location 的对象boolean removeAll(Collection&lt;?&gt; collection)删除存储的某个 Collection 对象Object [] toArray()ArrayList 转数组List&lt;’E’&gt; subList(int start, int end)获取位于 start 与 end 之间的 Listvoid clone()克隆ArrayListvoid clear()移除ArrayList中所有对象Iterator&lt;’E’&gt; iterator()获取该 ArrayList 对应的迭代器对象ArrayList 应用示例1. ArrayList与数组之间的转换1234567891011121314151617181920// 转数组List&lt;String&gt; list = new ArrayList&lt;&gt;();String[] strings = new String[list.size()];list.toArray(strings);// 或者String[] strings = (String[])list.toArray(new String[list.size()]);// 数组转List// 法1 快速，但是以视图形式返回，无法对数据进行删除及添加操作；// 可用 set() 方法修改元素，但是原始List数据会随之改变String[] s = &#123;"abc", "def", "ghi"&#125;;List&lt;String&gt; list = java.util.Arrays.asList(s);//法 2 慢，但是新生成一个ArrayList，可对List进行操作不会对原对象产生影响List&lt;String&gt; assertList = new ArrayList();Collections.addAll(assertList, strings);2. ArrayList遍历方式123456789101112131415161718192021222324List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));// 第一种，通过迭代器遍历。即通过Iterator去遍历。Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123;value = (Integer)iter.next();&#125;// 第二种，随机访问，通过索引值去遍历。Integer value = null;int size = list.size();for (int i=0; i &lt; size; i++) &#123;value = (Integer)list.get(i); &#125;// 第三种，for循环遍历。Integer value = null;for (Integer integer: list) &#123;value = integer;&#125;// 第四种，利用Stream API的 stream.forEach()方法依次获取。list.forEach(num -&gt; System.out.println(num));3. 初始化12345678910111213141516171819202122232425// 第一种方式 Arrays.asList()方法ArrayList&lt;Integer&gt; list = new Arraylist&lt;&gt;(Arrays.asList(1, 2, 3));// 第二种方法 常规方式ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);//或者List innerList = Arrays.asList(1, 2, 3);list.addAll(innerList);// 第三种方法 使用生成匿名内部类ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123; &#123; add(1); add(2); add(3); &#125;&#125;；// 第四种方式 使用Collection.nCopiesint element = 1;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Collections.nCopies(2, element)); //复制伍分到list中。4. 打印信息由于ArrayList内部实现了toString()方法，所以可以直接打印12ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));System.out.println(list);对于数组信息的打印123456789int[] A = &#123;1, 2, 3&#125;;// 方法一for(Integer i: A)&#123; System.out.println(i);&#125;//方法二System.out.println(Arrays.toString(A));5. 大量头部的增删操作ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 LinkedList 代替。由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。参考资料ArrayList源码剖析: http://www.spring4all.com/article/16262]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm：删除最外层的括号]]></title>
    <url>%2FAlgorithm-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[删除最外层括号题目有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。示例1输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。示例2输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。示例3输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。提示123S.length &lt;= 10000S[i] 为 "(" 或 ")"S 是一个有效括号字符串思路用一个数组模拟栈，发现 “(“ 使其进栈，发现 “)” 时使 “(“ 出栈。注意: 栈底的 “(“ 出栈不输出，当输出字符串中 “(“ 和 “)” 数量不相等时，才输出 “)” 。代码12345678910111213141516171819202122232425262728class Solution &#123; public String removeOuterParentheses(String S) &#123; // list作为栈，记录(数量 List&lt;Character&gt; list = new ArrayList(); StringBuilder bf = new StringBuilder(); int left = 0; // 记录输出的 ( 数量 int right = 0; //记录输出的 ) 数量 for(int i=0; i&lt;S.length(); i++)&#123; char c = S.charAt(i); if(c=='(') list.add(c); if(c==')')&#123; if(list.size()==1&amp;&amp;left==right) list.remove(0); if(list.size()&gt;1)&#123; while(list.size()!=1)&#123; bf.append("("); list.remove(list.size()-1); ++left; &#125; &#125; if(left!=right)&#123; bf.append(")"); ++right; &#125; &#125; &#125; return bf.toString(); &#125;&#125;更Niubility的code：123456789101112131415161718class Solution &#123; public String removeOuterParentheses(String S) &#123; StringBuilder bf = new StringBuilder(); int flag = 0; for(char c: S.toCharArray())&#123; if(c == '(')&#123; ++flag; if(flag == 1) continue; &#125; if(c==')')&#123; --flag; if(flag == 0) continue; &#125; bf.append(c); &#125; return bf.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Minimum path sum]]></title>
    <url>%2FAlgorithm-Minimum-path-sum%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingMinimum Path SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6思路动态规划 问题。用原来的grid矩阵存储路径和注意三种特殊情况，即矩阵初始位置、顶栏及左侧栏和求解。初始：grid[0][0] = grid[0][0]顶栏：grid[i][j] = grid[i][j-1]左侧栏：grid[i][j] = grid[i-1][j]其余位置：grid[i][j] = min(grid[i][j-1], grid[i-1][j])Algorithm12345678910111213141516171819202122class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; for(int i=0; i&lt;m;i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0&amp;&amp;j==0)&#123; continue; &#125; else if(i==0&amp;&amp;j!=0)&#123; grid[i][j] += grid[i][j-1]; &#125; else if(j==0&amp;&amp;i!=0)&#123; grid[i][j] += grid[i-1][j]; &#125;else&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Partition-array-for-maximum-sum]]></title>
    <url>%2FAlgorithm-partition-array-for-maximum-sum%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingPartition Array for Maximum SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6思路动态规划 问题。用一个长度为A.length的数组dp维护最终的加和结果。计算思想如下：dp[i] := max sum of A[0] ~ A[i]dp[i] = max{dp[i – k] + max(A[i+1-k:i]) * k}, 1 &lt;= k &lt;= min(i, K)最终返回结果dp[A.length-1]Algorithm1234567891011121314class Solution &#123; public int maxSumAfterPartitioning(int[] A, int K) &#123; int len = A.length; int[] dp = new int[len]; for(int i=0; i&lt;A.length; ++i)&#123; int max_num = A[i]; for(int k=1; k&lt;=K &amp;&amp; i+1-k&gt;=0; ++k)&#123; max_num = Math.max(max_num, A[i+1-k]); dp[i] = Math.max(dp[i], (i-k&gt;=0?dp[i-k]:0) + k*max_num); &#125; &#125; return dp[len-1]; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-for循环那些事]]></title>
    <url>%2FJava-for%E5%BE%AA%E7%8E%AF%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[Java for循环里面的 i++ 与 ++i在for循环里两者的作用是一样的i++12345for(int i=0; i&lt;5; i++)&#123; System.out.print(i + ",");&#125;&gt;&gt; 0, 1, 2, 3, 4++i12345for(int i=0; i&lt;5; ++i)&#123; System.out.print(i + ",");&#125;&gt;&gt; 0, 1, 2, 3, 4工作原理i++1234&#123; System.out.print(i + ","); i++;&#125;++i1234&#123; System.out.print(i + ","); ++i;&#125;区别在Java里面，i++ 需要开辟新的存储空间用于存储结果，++i 直接在原存储空间中存储结果。故 **++i 在 for 循环里面执行效率要高。** 可以作为代码优化的一部分。foreach 与 for循环的效率首先测试数组123456789101112131415161718192021// 测试for循环int[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(int i=0; i&lt;len; i++)&#123; res += A[i];&#125;long endTime = System.nanoTime();System.out.println("for循环: "+(endTime- startTime));// 测试foreachint[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(Integer i: A)&#123; res += i;&#125;long endTime = System.nanoTime();System.out.println("foreach循环: "+(endTime- startTime));结果12for循环: 37143324forecah循环: 75450311可见对于大数组采用for循环效率更高再测试ArrayList12345678910111213141516171819202122ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000); for(int i=0; i&lt;30000000; i++)&#123; list.add(i); &#125;// 测试for循环long startTime = System.nanoTime();int size = list.size();int res = 0;for(int i=0; i&lt;size; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println("for循环: "+(endTime- startTime));// 测试foreachlong startTime = System.nanoTime();int res = 0;for(Integer i: list)&#123; res += i; &#125;long endTime = System.nanoTime();System.out.println("foreach循环: "+(endTime- startTime));结果12for循环: 39368248forecah循环: 42177137可见对于ArrayList仍然是采用for循环效率更高！for循环小技巧关于数组循环嵌套采用小套大。原理跟复制几个大文件跟复制一堆小文件耗时一样。测试12345678910long startTime = System.nanoTime();int res = 0;// 大套小for(int i=0; i&lt;10000000; i++)&#123; for(int j=0; j&lt;100; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println("大套小: "+(endTime- startTime));12345678// 小套大for(int i=0; i&lt;100; i++)&#123; for(int j=0; j&lt;10000000; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println("小套大: "+(endTime- startTime));结果12大套小: 57934223小套大: 4918044数组复制时采用System.arraycopy()方法比for循环复制效率高。System.arraycopy()public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度关于ArrayList在循环时，首先把ArrayList长度size记录下来。测试1234567891011121314151617181920ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000);for(int i=0; i&lt;30000000; i++)&#123; list.add(i);&#125;long startTime = System.nanoTime();//先把长度保存下来int len = list.size();int res = 0;for(int i=0; i&lt;len; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println("保存size(): "+(endTime- startTime));//没有保存size()for(int i=0; i&lt;list.size(); i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println("没有保存size(): "+(endTime- startTime));结果12保存size(): 38973440没有保存size(): 39486862]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java：Map API]]></title>
    <url>%2FJava-Map-API%2F</url>
    <content type="text"><![CDATA[Java Map常用类型类型特征HashMap根据 HashCode 存储数据，访问速度快。至多允许一条记录键为 null;允许多条记录的值为 null；线程非同步TreeMap保存的记录按照键(key)排序，也可自定义排序规则。用生成的 Iterator 遍历 TreeMap 得到记录是排序后的。不允许记录的键为 null；线程非同步Hashtable用 HashMap 类似,不同的是键值都不允许为 null。 支持线程同步，但写入较慢LinkedHashMap保留记录的插入顺序，生成Iterator遍历顺序与插入顺序一致。遍历比HashMap慢，键值都允许为 null；线程非同步–&gt; HashMap剖析常用 API方法描述Object put(Object k, Object v)存入键值对Object get(Object k)返回键所映射的值；如果不存在该映射则返回 nullboolean containsKey(Object k)是否包含键 kboolean containsValue(Object v)是否包含值 vboolean isEmpty()Map 是否为空int size()返回 Map 的键值对数boolean remove(Object k)如果存在一个键映射关系，则删除此关系(映射关系不存在不会报错)void clear()移除Map中所有映射关系boolean equals(Object obj)比较指定对象于此 Map 是否相等void putAll(Map m)将指定 Map 的映射关系复制到此 Map 中Collection values()以 Collection 形式返回 Map 包含的值Set keySet()以 Set 形式返回 Map 包含的键Set entrySet()以 Set 形式返回 Map 的映射关系Map 应用示例123456789Map&lt;Integer, Character&gt; map = new HashMap&lt;&gt;();map.put(1, 'c');map.get(1);for(int i: map.keySet())&#123; System.out.println(map.get(i)); &#125;if(map.containsKey(1))&#123; map.remove(1);&#125;常用遍历方法1. 只获取键或值123456789// 获取键for(Integer key: map.keyset())&#123; System.out.println(key);&#125;// 获取值for(Integer value: map.value())&#123; System.out.println(value);&#125;2. 同时获取键和值1234567891011// 2.1 先取key再取value。不推荐for(Integer key:map.keySet())&#123; System.out.println(map.get(key));&#125;// 2.2 通过map entrySet遍历。性能优于上一种。for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; System.out.println(entry.getKey() + ":" + entry.getValue());&#125;3. Iterator上面的foreach都可以用Interator代替。foreach是对Set遍历,大小不能改变。如果改变map的大小，会报错。如果想要删除元素，还是要用Interator的方式删除。123456Interator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.enteySet().iterator();while(it.hasNext())&#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + ":" + entry.getValue()); // it.remove() 删除元素&#125;4. Lambda代码简洁，但是性能低于entrySet。123map.forEach((key, value)-&gt;&#123; System.out.println(key + ":" + value);&#125;)5. 性能测试用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap12345static&#123; for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125;&#125;测试结果如下：KeySet： 392Values： 320keySet get(key)： 552entrySet： 465entrySet Iterator：508Lambda： 536Map的遍历方法参考(侵删)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Coin Change]]></title>
    <url>%2FAlgorithm-Coin-Change%2F</url>
    <content type="text"><![CDATA[Dynamic ProgrammingCoin ChangeTitle DetailYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.Example 1:123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 1:12Input: coins = [2], amount = 3Output: -1Note:You may assume that you have an infinite number of each kind of coin.思路动态规划 问题。用一个 amount+1长度的数组 bp 维护不同面值金额需要最小的硬币数。bp[0]=0bp[1~amount]=amount+1位置0表示面值为零，最小需要0个硬币，初始为0.位置0~amount假设需要amount个硬币，因硬币类型为int，即代表无解。对于硬币类型coins[i]，寻找j=coins[i] ~j=amount对应面值金额的最小硬币数，即为min(dp[j], dp[j-coins[i]]+1)。dp[j-coins[i]]+1代表放入一个该类型硬币。前提： dp[j-coins[i]]面值的金额不是无解，因为如果无解，那么dp[j-coins[i]]+1对于当前面值金额也是无解。返回dp数组第amount位置数字，即为所求。Algorithm12345678910111213141516171819class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(coins.length==0) return -1; // 创建维护结果的数组 int[] dp=new int[amount+1]; Arrays.fill(dp,1,dp.length,amount+1); for(int i=0; i&lt;coins.length;i++)&#123; // 前提 for(int j=coins[i]; j&lt;=amount;j++)&#123; // 硬币数量统计 if(dp[j-coins[i]]!=amount+1)&#123; dp[j]=Math.min(dp[j], dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=amount+1) return dp[amount]; return -1; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Sqrt(x)]]></title>
    <url>%2FAlgorithm-Sqrt-x%2F</url>
    <content type="text"><![CDATA[Some Algorithm using Math AlgorithmAlgorithm-1 Sqrt(x)Title detailImplement int sqrt(int x)Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:12Input: 4Output: 2Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.思路牛顿迭代法公式： $x_{k+1} = \lfloor {x_k + n / {x_k}} \rfloor / 2$当$k \rightarrow \infty$ 时，${x_{k+1}}^2 \rightarrow n$Algorithm123456789101112class Solution &#123; public int mySqrt(int x) &#123; if(x&lt;=1) return x; long r=x; long t = x/r; while(r&gt;t)&#123; t = x/r; r = (r + t)/2; &#125; return (int)r; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algortthm--Jewels and Stones]]></title>
    <url>%2FAlgortthm-Jewels-and-Stones%2F</url>
    <content type="text"><![CDATA[Map的应用Jewels and StonesTitle DetailYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.Example 1:12Input: J = "aA", S = "aAAbbbb"Output: 3Example 2:12Input: J = "z", S = "ZZ"Output: 0Note:S and J will consist of letters and have length at most 50.The characters in J are distinct.思路使用Java里面的 Map。key键保存宝石类型，value键保存数量统计。Algorithm1234567891011121314151617181920class Solution &#123; public int numJewelsInStones(String J, String S) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;J.length(); i++)&#123; map.put(J.charAt(i), 0); &#125; for(int i=0; i&lt;S.length();i++)&#123; Character c = S.charAt(i); if(map.get(c)!=null)&#123; Integer freq =map.get(c); map.put(c, freq+1); &#125; &#125; int result = 0; for(Integer value: map.values())&#123; result += value; &#125; return result; &#125;&#125;法2 正则表达式123String a = "[^"+J+"]"; S = S.replaceAll(a, ""); return S.length();Python方法1return sum(S.count(i) for i in J)题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Fast and Slow Pointer]]></title>
    <url>%2FAlgorithm-Fase-and-Low-Pointer%2F</url>
    <content type="text"><![CDATA[快慢指针的应用判断链表是否存在环Title DetailGiven a linked list, determine if it has a cycle in it.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.Example 1:123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.思路利用快慢指针，快指针每次走两步，慢指针每次走一步。如果快指针能够追上慢指针，则链表存在环。Algorithm1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null || head.next.next==null) return false; ListNode fast = head; ListNode slow = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow)&#123; return true; &#125; &#125; return false; &#125;&#125;题目链接有序数组移除重复数字Title DetailGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 1:12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;思路前提是有序数组，可见排序是很基础且重要的算法！过程：初始，快慢指针指向第一个数字。当快慢指针指向的数字都相同，快指针往前移动一位。当快慢指针指向的数字不相同，慢指针往前移动一位，把快指针指向的数字赋予慢指针，快指针往前移动一位。慢指针移动的 位数+1 即为不同数字的数量。且数组从初始位置到慢指针指向的位置，数字都是排好序的。Algorithm1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int fast=0; int slow=0; while(fast&lt;nums.length)&#123; if(nums[fast]==nums[slow])&#123; fast++; &#125;else&#123; nums[++slow]=nums[fast++]; &#125; &#125; return slow+1; &#125;&#125;图片地址题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm--Find Common Characters]]></title>
    <url>%2FAlgorithm-Find-Common-Characters%2F</url>
    <content type="text"><![CDATA[Find Common CharactersTitle detailGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.You may return the answer in any order.Example 112Input: ["bella","label","roller"]Output: ["e","l","l"]Example 212Input: ["cool","lock","cook"]Output: ["c","o"]Note:1231 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 100A[i][j] is a lowercase letter思路统计每个字符串中26个字母的出现次数。每个字符串都出现的字母且统计次数最少的即为结果输出的字符。用int数组0-25位置表示0-26个字母，存储的整数代表出现总次数。Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; commonChars(String[] A) &#123; List&lt;String&gt; list = new ArrayList(); int[] res = new int[26]; for(int i=0; i&lt;A[0].length();i++)&#123; res[A[0].charAt(i) - 'a'] += 1; &#125; for(int i=0; i&lt;A.length;i++)&#123; int[] temp = new int[26]; for(int j=0; j&lt;A[i].length(); j++)&#123; temp[A[i].charAt(j) - 'a'] +=1; &#125; for(int m=0; m&lt;26; m++)&#123; res[m] = Math.min(res[m], temp[m]); &#125; &#125; for(int i=0; i&lt;26; i++)&#123; if(res[i] &gt; 0)&#123; for(int j=0; j&lt;res[i]; j++)&#123; list.add((char)('a'+i)+""); &#125; &#125; &#125; return list; &#125;&#125;题目链接]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Other Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux系统中同步更新我们的Github博客]]></title>
    <url>%2F%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[原理介绍类似于版本管理，我们把hexo博客文件系统在Github上建立一个分支，通过管理分支提交最新的博客文件系统，保证我们博客框架的更新。然后我们基于最新的博客框架，撰写文章，进行Github Pages网页的更新，即我们博客内容的更新。创建两个分支，一个用于存放博客静态资源，一个用于备份博客的部署文件。参考资料前期准备一台Linux系统的电脑（我的linux系统是Ubuntu 18.04.2 LTS）安装node.js 及 npm安装 ssh安装 git按照我们前面教程搭建好的博客创建Github 博客仓库分支首先在我们搭建Hexo博客的电脑上，创建我们博客仓库在Github上的分支。打开我们的博客仓库，选择setting：选择Branches,创建博客仓库的Hexo分支，并将其设置为默认分支。将该仓库克融到本地，并把本地博客的(所有Hexo目录下文件)全部拷贝进username.github.io文件目录中去。 然后把更新后的博客部署文件提交到Github的hexo分支中。依次执行123git add .git commit -m &apos;some info&apos;git push注意事项：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后我们的博客备份分支就创建好了。Linux 部署项目安装Node.js 与 npm安装gitlinux与Github建立联系把我们创建好的博客备份仓库clone到本机（linux）4.1 在要保存的位置执行语句 git clone git@github.com:your.github.io/your.github.io.git4.2 进入username.github.io目录，执行npm install (由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以要安装依赖)安装hexo插件sudo npm install hexo-cli -g撰写我们的博客文章，然后依次执行下面指令，更新我们的博客备份。12345hexo cleanhexo ggit add .git commit -m &apos;some info&apos;git push更新博客界面hexo d注意事项1. 每当撰写博客前，先 git pull，获取最新的博客备份。2. 写完博客后，先依次执行hexo clean 、 hexo g 、 git add . 、 git commit -m &#39;some info 、 git push&#39;进行博客备份部署文件更新。3. 最后执行 hexo d部署博客界面，实现博客更新。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows环境下Hexo+Github搭建个人博客教程]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言你是否也想拥有属于自己的博客？是否也想拥有跟我一样的博客空间？如果心动了，就赶紧往下看吧！教程炒鸡简单，炒鸡详细，而且博客搭建完全是Free of Charge!原理Github PagesGithub不仅可以让我们把代码托管在平台上，而且允许我们利用Github的服务器部署自定义网页对我们的项目作简介。这个网页就被称为Github Pages。这是我们可以利用Github搭建免费博客的基础啦~HexoHexo是一款轻量但高逼格的搭建博客快速工具，它是基于Node.js开发的。而Node.js…好了，扯远了…有兴趣的童鞋可以出门左转自己百度…准备知道了大致的原理，我们首先需要准备搭建博客的材料。如下：1. 一台windows系统的电脑2. 一个Github账号3. 安装Node.js4. 安装Git5. 安装Hexo开始申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)假设我们都有了Github账号，这是首先在右上角点击“+”号，选择New repository注意 仓库名一定是”你的Github用户名”+github.io !!!之后为我们的项目添加一个说明Pages！建好的项目顶部最右边有个Setting按钮，点击进入配置界面，下滑界面，直到看到Github Pages，这时你发现竟然自动生成了一个说明网页！因为Github说明网页的默认地址就是“你的Github用户名”+github.io，其它说明网页都是基于该地址的。 Ok! 到此为止，Gihub Pages的部分就结束了。搭建Hexo，把Github Pages修改为自己的博客界面！安装Git以及Node.js！因为我们需要通过Git把我们的Hexo生成的网页提交到Github pages上，而Node.js是我们Hexo插件运行的基础！下载安装Windows版Git下载安装Node.js验证：“Win”+R打开运行界面，输入”cmd”打开命令行窗口。是否安装Git:输入git version出现版本信息：1git version 2.19.1.windows.1是否安装Node.js:输入node -v出现版本信息：1v8.12.0安装及部署Hexo首先创建一个文件夹，用来放置我们的Hexo。然后进入我们的文件夹，例如我们文件夹路径为D:\blog则在终端依次输入并执行D: 、 cd blog 进入文件夹打开命令终端，利用Node.js的包管理器npm安装Hexo: npm install hexo-cli -g输入hexo -v验证是否安装成功输入hexo init初始化该文件夹输入npm install安装需要的组件输入npm g生成静态文件输入npm s启动服务器，现在在浏览器输入http://localhost:4000/打开我们的博客界面！是不是有点鸡冻！别急，我们还需要把页面推送到Github Pages上，步骤如下：1. 设置Git的user name和email在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;2. SSH 授权打开git bash，输入ssh-keygen -t rsa, 接着回车三下。最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去3. 上传项目首先用IDE(我用的是WebStorm)打开我们的Hexo文件夹，发现它的文档目录是这样的：12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- public|-- themes|-- .gitignore_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 –save 保存进去。scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;layout(布局)&gt; &lt;’title’&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用hexo clean 清除 db.json 和 public 文件夹下的所有文件。themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。打开配置文档_config.yml，修改deploy值（在末尾）:1234deploy: type: git repo: git@github.com:SUNYunZeng/SUNYunZeng.github.io.git branch: master安装在git上部署文章的扩展npm install hexo-deployer-git --save打开终端并进入到Hexo文件系统中，创建一篇新博客hexo new post &quot;博客名&quot;这时文件夹source/_posts文件夹里会出现博客名.md的博客文章源文件文件是markdown格式，书写方法有一套规范，下篇博客会讲到。PS:非常简单啦~编辑好博客内容后，一顿滚键盘，依次执行以下命令：hexo g 生成静态文件hexo d 部署到Github Pages就这样，你的第一篇博客就上传啦！更换Hexo主题由于默认的博客主题可能不能满足大家的需求，所以再提一下更换主题的方法。首先到Hexo官网中选择一款喜欢的主题这里我以我博客采用的主题为例，我采用的pure主题首先在Hexo系统文件夹中打开终端，然后输入git clone https://github.com/cofess/hexo-theme-pure.git themes/pure之后在系统目录theme文件夹下你会发现多出了pure命名的一个文件夹，这就是我们主题保存的位置,其中pure文件夹下的config.yml文件就是我们博客的配置文件，在里面可以自己对博客界面进行个性化配置，详情请参看网址在我们的Hexo系统配置文件config.yml中，修改theme为我们的pure主题1theme: pure然后进入文件夹 cd themes/pure把主题提交git pull重新生成博客静态文件，然后部署到Github Pageshexo ghexo d当当~我们的个性化博客就搭建完毕啦！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
</search>
