<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙云增的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunyunzeng.com/"/>
  <updated>2019-10-08T09:52:38.224Z</updated>
  <id>http://sunyunzeng.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer：二叉树和为某一值的路径</title>
    <link href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://sunyunzeng.com/剑指Offer：二叉树和为某一值的路径/</id>
    <published>2019-10-08T09:50:05.000Z</published>
    <updated>2019-10-08T09:52:38.224Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>递归求解，左右子树分别遍历（深度优先）。</p><p>遍历终止条件为节点为<strong>null</strong>或者是叶子节点且和为目标值。</p><p>否则回退列表，寻找更短的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        target = target - root.val;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;root.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一颗二叉树的
      
    
    </summary>
    
      <category term="Algorihm" scheme="http://sunyunzeng.com/categories/Algorihm/"/>
    
    
      <category term="Binary Tree" scheme="http://sunyunzeng.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer：二叉搜索树的后序遍历序列</title>
    <link href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://sunyunzeng.com/剑指Offer：二叉搜索树的后序遍历序列/</id>
    <published>2019-10-06T07:44:08.000Z</published>
    <updated>2019-10-06T07:49:05.812Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>二叉搜索树</strong>的左子树所有节点小于根节点，右子树的所有节点大于根节点。</p><p><strong>后序遍历</strong>是先访问左子树，后访问右子树。</p><p>因此，根节点永远在序列的最后位置。找到根节点数值后，根据前面节点数值与根节点的大小关系，找到<strong>左右子树的分割位置</strong>，递归求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span> || sequence.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 调用重写的辅助函数</span></span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 寻找分割节点</span></span><br><span class="line">        <span class="keyword">int</span> currentCutIndex = start;</span><br><span class="line">        <span class="keyword">while</span>(sequence[currentCutIndex]&lt;sequence[end])&#123;</span><br><span class="line">            currentCutIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右子树存在小于根节点的节点，则该序列不是二叉搜索树的后序遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=currentCutIndex; i&lt;end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&lt;sequence[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树递归寻找</span></span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBST(sequence, start, currentCutIndex-<span class="number">1</span>) &amp;&amp; </span><br><span class="line">            VerifySquenceOfBST(sequence, currentCutIndex, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个整数数组
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Binary Tree" scheme="http://sunyunzeng.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer：从上往下打印二叉树</title>
    <link href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://sunyunzeng.com/剑指Offer-从上往下打印二叉树/</id>
    <published>2019-10-06T02:00:41.000Z</published>
    <updated>2019-10-06T03:29:41.114Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>二叉树的层次遍历，用队列保存同一层次的树节点，然后依次遍历。</p><p>类似题目<u><a href="http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</a></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                root = queue.remove();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.left);</span><br><span class="line">                <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;从上往下打印出二
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Binary Tree" scheme="http://sunyunzeng.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer: 顺时针打印矩阵</title>
    <link href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://sunyunzeng.com/剑指Offer-顺时针打印矩阵/</id>
    <published>2019-09-30T12:14:36.000Z</published>
    <updated>2019-10-02T01:11:55.414Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>制造一个子函数，用来打印每一层。函数接收的参数是需要打印的<strong>行数跟列数</strong>，以及起始打印的位置（都是 n * n）。</p><p>特殊情况处理：<strong>打印行列错误、数组为空、单行或单列数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       printArr(matrix.length, matrix[<span class="number">0</span>].length, <span class="number">0</span>, matrix, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> I,<span class="keyword">int</span> J,<span class="keyword">int</span> s,<span class="keyword">int</span>[][] arr, ArrayList&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(I&lt;=<span class="number">0</span> || J&lt;=<span class="number">0</span> || arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span> || arr[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(I==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;J;i++)&#123;</span><br><span class="line">                res.add(arr[s][s+i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(J==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;I;i++)&#123;</span><br><span class="line">                res.add(arr[s+i][s]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;J;i++)&#123;</span><br><span class="line">            res.add(arr[s][s+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;I;i++)&#123;</span><br><span class="line">            res.add(arr[s+i][s+J-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=J-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            res.add(arr[s+I-<span class="number">1</span>][s+i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=I-<span class="number">1</span>; i&gt;<span class="number">1</span>; i--)&#123;</span><br><span class="line">            res.add(arr[s+i-<span class="number">1</span>][s]);</span><br><span class="line">        &#125;</span><br><span class="line">        printArr(I-<span class="number">2</span>,J-<span class="number">2</span>,s+<span class="number">1</span>,arr, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个矩阵，按
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Other Algorithm" scheme="http://sunyunzeng.com/tags/Other-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 树的子结构</title>
    <link href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://sunyunzeng.com/剑指Offer-树的子结构/</id>
    <published>2019-09-29T08:33:23.000Z</published>
    <updated>2019-10-02T01:11:55.413Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>涉及到二叉树相关的问题，首先想到递归。</p><p>由于二叉树是否为子树的判断，涉及到是否为 <font color="#f07c82">null</font>的判断，因此需要建立子判定函数，避免空树情况产生干扰。</p><p>判断条件：</p><p><strong>如果当前树节点与待判断树节点数值相同，则继续进行左右树的数值判断。直到两树中某一树为空。</strong></p><p><strong>否则分别对当前树的子树与右树跟带判断子树进行判定。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 不能只判断当前第一个节点，如果首节点是伪相等，就是错误的</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1, root2)||</span><br><span class="line">            isSubtree(root1.left, root2)||isSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> (isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right)); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSubtree(root1.left, root2) || isSubtree(root1.right, root2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;树的子结构&quot;&gt;&lt;a href=&quot;#树的子结构&quot; class=&quot;headerlink&quot; title=&quot;树的子结构&quot;&gt;&lt;/a&gt;树的子结构&lt;/h1
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Binary Tree" scheme="http://sunyunzeng.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>设计模式: Java泛型</title>
    <link href="http://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://sunyunzeng.com/设计模式-Java泛型/</id>
    <published>2019-09-28T14:17:08.000Z</published>
    <updated>2019-10-02T01:11:55.416Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="不要使用原始类型"><a href="#不要使用原始类型" class="headerlink" title="不要使用原始类型"></a>不要使用原始类型</h1><p><strong>原始类型</strong>是Java(5之前)的历史遗留问题，<strong>之前集合对于类型在编译期间不进行检查，而在运行期进行类型检查。</strong></p><p>这导致问题的定位困难，降低效率。</p><p>此后采用<strong>泛型</strong>解决这个问题，保证在编译期间进行检查。</p><p>例如<font color="#f07c82">List</font> 类型是原始类型，而<font color="#f07c82">List&lt; E &gt;</font>是泛型类型，指定了参数化类型为 <font color="#f07c82">E</font> 类型。</p><p><strong>List</strong>表明可以存储任何类型的对象，<font color="#f07c82">List&lt; E &gt; </font>是它的子类型，可以转化为<strong>List</strong>类型，但是丧失了安全性检查；而<font color="#f07c82">List&lt; E &gt; </font>却不是<font color="#f07c82">List&lt; Object &gt; </font>的子类型。<font color="#f07c82">List&lt; Object &gt; </font>只能是<font color="#f07c82">List&lt; Object &gt; </font>。</p><p>如果想实现类似于<strong>List等存储任何类型的对象</strong>， 可以利用<strong>无限制通配符类型（unbounded wildcard types）</strong>表示泛型类型，即<font color="#f07c82">List&lt; ? &gt; </font>。</p><p><strong>泛型的几个注意点：</strong></p><p><strong>1. 类字面常量不允许使用泛型</strong></p><p>数组<font color="#f07c82">String[].class</font>、基本类型<font color="#f07c82">int.class</font>、不带参数化类型的类<font color="#f07c82">List.class</font>可以使用。</p><p><strong>2. instanceof 只能对无限制通配符类型的参数化类型的类或接口使用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Set)&#123;</span><br><span class="line">    Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">术语</th><th align="center">中文含义</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">Parameterized type</td><td align="center">参数化类型</td><td align="center">List&lt; String &gt;</td></tr><tr><td align="center">Actual type parameter</td><td align="center">实际类型参数</td><td align="center">String</td></tr><tr><td align="center">Generic type</td><td align="center">泛型类型</td><td align="center">List&lt; E &gt;</td></tr><tr><td align="center">Formal type parameter</td><td align="center">形式类型参数</td><td align="center">E</td></tr><tr><td align="center">Unbounded wildcard type</td><td align="center">无限制通配符类型</td><td align="center">List&lt;?&gt;</td></tr><tr><td align="center">Raw type</td><td align="center">原始类型</td><td align="center">List</td></tr><tr><td align="center">Bounded type parameter</td><td align="center">限制类型参数</td><td align="center">&lt; E extends Number&gt;</td></tr><tr><td align="center">Recursive type bound</td><td align="center">递归类型限制</td><td align="center">&lt; T extends Comparable&lt; T &gt;&gt;</td></tr><tr><td align="center">Bounded wildcard type</td><td align="center">限制通配符类型</td><td align="center">List&lt;? extends Number&gt;</td></tr><tr><td align="center">Generic method</td><td align="center">泛型方法</td><td align="center">static &lt; E &gt; List&lt; E &gt; asList(E[] a)</td></tr><tr><td align="center">Type token</td><td align="center">类型令牌</td><td align="center">String.class</td></tr></tbody></table><h1 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h1><p>即<font color="#f07c82">List</font>优先于数组。</p><p>因为数组是<strong>协变类型</strong>的，所以下面代码编译期间是合法的, 但是运行期间是违法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">o[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>尽量使用<strong>列表</strong>来在编译过程中就确保安全性，虽然会损失掉一定的性能与简洁性。</p><p>下面代码运行有警告，因为java程序中的泛型信息在编译后会进行<strong>擦除</strong>（这意味着它们只在编译时执行类型约束，并在运行时丢弃它们的元素类型信息），为了与Java5之前的代码共存。</p><p>因此实际在运行中虚拟机并不知道返回数组具体类型，返回的类型是顶层类 Object, 在强制转换为<strong>T[]</strong>时会有问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">    choiceArray = (T[]) choices.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此最好采用List替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">    choiceList = <span class="keyword">new</span> ArrayList&lt;&gt;(choices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h1><p>一个简单实现的栈，原始版本 vs 添加泛型版本。</p><p><strong>原始版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">// 存储数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 元素桶</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object res = elements[--size];</span><br><span class="line">        <span class="comment">// 清除无用的引用</span></span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length==size)</span><br><span class="line">            elements = Arrays.copyOf(elements, size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的版本Stack每次取出元素都要进行强制类型转换。</p><p><strong>泛型版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 存储数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 元素桶</span></span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保强制转换是安全的。有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 强制类型转换，因为无法创建泛型数组 new E[DEFAULT_INITIAL_CAPACITY];</span></span><br><span class="line">        elements = (E)<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        E res = elements[--size];</span><br><span class="line">        <span class="comment">// 清除无用的引用</span></span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length==size)</span><br><span class="line">            elements = Arrays.copyOf(elements, size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="考虑泛型方法"><a href="#考虑泛型方法" class="headerlink" title="考虑泛型方法"></a>考虑泛型方法</h1><p>声明类型参数的<strong>类型参数列表</strong>位于方法的<strong>修饰符</strong>和<strong>返回类型</strong>之间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限定通配符增加API灵活性"><a href="#限定通配符增加API灵活性" class="headerlink" title="限定通配符增加API灵活性"></a>限定通配符增加API灵活性</h1><p><strong>PECS代表： producer-extends，consumer-super。</strong></p><p>如果一个参数化类型代表一个 <font color="#f07c82">T</font> 生产者，使用 <font color="#f07c82">&lt;? extends T&gt;</font>；如果它代表 <font color="#f07c82">T</font> 消费者，则使用 <font color="#f07c82">&lt;? super T&gt;</font>。 在我们的 <font color="#f07c82">Stack</font> 示例中，<font color="#f07c82">pushAll</font> 方法的 <font color="#f07c82">src</font> 参数生成栈使用的 <font color="#f07c82">E</font> 实例，因此 <font color="#f07c82">src</font> 的合适类型为 <font color="#f07c82">Iterable&lt;? extends E&gt;</font>；<font color="#f07c82">popAll</font> 方法的 <font color="#f07c82">dst</font> 参数消费 <font color="#f07c82">Stack</font> 中的 <font color="#f07c82">E</font> 实例，因此 <font color="#f07c82">dst</font> 的合适类型是 <font color="#f07c82">Collection &lt;? super E&gt;</font>。</p><p><strong>所有 <font color="#f07c82">Comparable</font> 和 <font color="#f07c82">Comparator</font> 都是消费者。</strong></p><h1 id="可变参数与泛型"><a href="#可变参数与泛型" class="headerlink" title="可变参数与泛型"></a>可变参数与泛型</h1><p>可变参数: 类型 <font color="#f07c82">T</font> 加<font color="#f07c82">…</font>构成，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String s: strs)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java用一个数组来保存变长的参数，但是<strong>可变参数的类型与泛型要注意混淆</strong>。</p><p>考虑一个<strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T ... t)&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">String[] strs = toArray(<span class="string">"abc"</span>, <span class="string">"def"</span>);</span><br></pre></td></tr></table></figure><p>上面的会报错，因为泛型传递的是非具体类型，也就是编译时的类型信息要多与运行时信息（由于擦除），因此可变参数的数组用 <font color="#f07c82">Object</font>类型存储，当<font color="#f07c82">Object</font>转为<font color="#f07c82">String</font>时，会报错<font color="#f07c82">ClassCastException</font>。</p><p><strong>另一个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;String&gt;... stringList)</span></span>&#123;</span><br><span class="line">    Object[] obj = stringList;</span><br><span class="line">    List&lt;Integer&gt; intList = List.of(<span class="number">15</span>); <span class="comment">// List.of生成一个不可变列表（不能用set设置数值）</span></span><br><span class="line">    obj[<span class="number">0</span>] = intList; <span class="comment">// 发成堆污染</span></span><br><span class="line">    String s = obj[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 出现警告，编译没错，但是运行报错 ClassCastException。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，可变参数中混淆了泛型，还是很容易产生类型转换的不安全性，但是Java并没有因此抛弃，而在<font color="#f07c82">Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)</font>中大量使用，说明<strong>只要保证可变参数中的泛型是安全的（以下三点），就可：</strong></p><p><strong>1. 可变参数数组不会存储跟修改。</strong><br><strong>2. 可变参数数组的引用不会转义。</strong><br><strong>3. 可变参数数组仅用来为方法传递可变参数。</strong></p><p>当然，可变参数数组可以变为列表，但同时降低了一定性能与可读性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">toArray</span><span class="params">(List&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">List&lt;String&gt; strs = toArray(<span class="string">"abc"</span>, <span class="string">"def"</span>);</span><br></pre></td></tr></table></figure><p><strong>可变参数的另一个用法</strong></p><p>因为可变参数数组的产生都会产生性能损耗，因此当 95％ 的调用是三个或更少的参数的方法，那么声明该方法的五个重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span>... rest)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h1 id="异构容器"><a href="#异构容器" class="headerlink" title="异构容器"></a>异构容器</h1><p>泛型中规定的可变类型数量总是有限的，例如单个类型约束<font color="#f07c82">&lt; T &gt;</font>以及Map的<font color="#f07c82">&lt; K , V&gt;</font>。</p><p>异构容器可以通过<strong>参数化键</strong>的方式，实现泛型设定数量的灵活性。例如在数据库查询中任意列值。</p><p>下面是一个异构容器的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用Class&lt;T&gt;存放未知的键</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, T&gt; favorites = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>&#123;</span><br><span class="line">        favorites.put(Object.requireNonNull(type), type.cast(instance));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Favorites f = <span class="keyword">new</span> Favorites();</span><br><span class="line">    f.put(String.class, <span class="string">"syz"</span>);</span><br><span class="line">    f.put(Integer.class, <span class="number">12</span>);</span><br><span class="line">    f,get(String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <font color="#f07c82">Column</font>Class 对象作为此类型安全异构容器的键。 以这种方式使用的 Class 对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的 <font color="#f07c82">DatabaseRow</font> 类型和一个泛型类型 <font color="#f07c82">Column&lt; T &gt;</font> 作为其键。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;不要使用原始类型&quot;&gt;&lt;a href=&quot;#不要使用原始类型&quot; class=&quot;headerlink&quot; title=&quot;不要使用原始类型&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://sunyunzeng.com/categories/Java/"/>
    
    
      <category term="Java设计模式" scheme="http://sunyunzeng.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Class文件长什么样</title>
    <link href="http://sunyunzeng.com/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/"/>
    <id>http://sunyunzeng.com/Class文件长什么样/</id>
    <published>2019-09-25T11:55:16.000Z</published>
    <updated>2019-10-02T01:11:55.191Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><font color="#f07c82">Class</font>文件是Java语言实现跨平台的原材料，<font color="#f07c82">JVM(Java Vritual Machine)</font>是实现跨平台的机器。</p><p>机器 + 原材料 = 跨平台。</p><p>不同的平台有自己的JVM，但是Class文件是一样的。</p><p>Class文件由java文件编译产生。</p><p><font color="#f07c82">Class文件是由8位字节构成的二进制流，用类似于C语言结构体的伪结构来存储数据。</font></p><p>Class文件由<font color="#f07c82">无符号数和表</font>组成。</p><p><strong>无符号数</strong>用<font color="#f07c82">u1 u2 u4 u8</font>来表示1 2 4 8个字节的无符号数。它用来表示数量值、数值、索引引用、按照UTF-8编码的字符串。</p><p><strong>表</strong>是一种特殊的数据结构，它由表及无符号数组成，习惯表以<font color="#f07c82">_info</font>结尾。</p><p><strong>Class文件就是一张表，用来描述唯一确定的类或接口。</strong></p><p>下面是从《深入了解JVM》中摘的Class文件的表结构。</p><img src="/Class文件长什么样/Class_info.PNG"><p><strong><center>图1 Class表结构</center></strong></p><h1 id="进入Class这张表"><a href="#进入Class这张表" class="headerlink" title="进入Class这张表"></a>进入Class这张表</h1><p>首先我们写一个简单的类，叫做<font color="#f07c82">HelloClass</font>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译生成 <font color="#f07c82">HelloClass.class</font>文件，我们用文本编辑器打开它，如下：</p><center><img src="/Class文件长什么样/class2.png"></center><p><strong><center>图2 编译后的class文件</center></strong></p><h2 id="最复杂的结构，常量池"><a href="#最复杂的结构，常量池" class="headerlink" title="最复杂的结构，常量池"></a>最复杂的结构，常量池</h2><p>由于Class本身就是一张表，而<font color="#f07c82">常量池</font>是嵌套在Class中的表，其结构最复杂。</p><p>常量池用来存储<strong>类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</strong></p><p>如<strong>图2</strong>所示，前四个字节的无符号数 <font color="#f07c82">u4</font>表示 Magic Number，是用来区分文件格式的，这样比文件名后缀更安全。</p><p><strong><font color="#f07c82">CAFE BABE</font></strong>是Java的Class文件的魔数，很魔性。</p><p>接着的<font color="#f07c82">u4</font>是版本号，即<strong>图1</strong>中的 <strong>00 00 00 34</strong>。</p><p>然后就是常量池了，先看常量池的项目类型：</p><center><img src="/Class文件长什么样/fig1.PNG"></center><center><img src="/Class文件长什么样/fig.2.PNG"></center><p><strong><center>图3 常量池的项目类型</center></strong></p><p>每个项目类型的第一位都是项目标志，唯一标识该类型。</p><p>常量池开始是容量说明，<font color="#f07c82">u2</font>类型，及 <strong>00 16</strong>，表示容量为 16+6=22-1=21，因为常量池容量计算是从1开始，0表示为空。</p><p>之后一个<font color="#f07c82">u1</font>类型是常量类型标志符，为 <strong>0A</strong>，为 10。查找<strong>图2</strong>表示该常量为 <strong>CONSTANT_Methodref_info</strong>，由两个<font color="#f07c82">u2</font>无符号类型组成，第一个指向 <strong>00 04</strong> 即第4个常量，为 <strong>CONSTANT_Class_info</strong> 类型；第二个指向 <strong>00 12</strong> 即第 16+2=18 个常量， 为 <strong>CONSTANT_NameAndType</strong> 类型。</p><p>依次类推，直到翻译完常量池。</p><p>我们可以通过<strong>javap</strong>工具的 <strong>-verbose</strong> 输出字节码内容，如下：</p><center><img src="/Class文件长什么样/javap.png"></center><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p><strong>访问标志(access_flags)</strong>用于识别类和接口的访问信息，诸如是否是public及抽象类等。</p><p>常量池后面是访问标志。</p><center><img src="/Class文件长什么样/access_flags.png"></center><p>不同访问标志求 <font color="#f07c82">|</font> 运算得到。</p><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><p>分别是一个 <strong>u2、u2</strong>和一组<strong>u2</strong>，因为java单继承，可实现多个接口。</p><p>各自指向一个 <strong>CONSTANT_Class_info</strong> 的类描述常量。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p><strong><font color="#f07c82">字段表(field_info)</font>用来描述接口或类中声明的变量，字段包括类级别变量以及实例级别变量。</strong>但不包括方法内部声明的局部变量。</p><p>字段需要用访问标志描述，<font color="#f07c82">包括作用域(public、protected、default、private)、实例变量还是类变量(static)、是否为final、并发可见性(volatile)、是否可序列化(transient)、类型(基本类型、对象及数组)以及字段名称。</font></p><center><img src="/Class文件长什么样/ziduan.PNG"></center><p>字段表的结果除了字段描述，还有字段的简单名称 <strong>name_index</strong> 及方法的描述符 <strong>discriptor_index</strong>、属性表统计 <strong>attributes_count</strong> 及属性表 <strong>attributes</strong>。</p><center><img src="/Class文件长什么样/attributes.png"></center><p>字段的简单名称及方法描述符都是对常量池引用。</p><p><strong>描述符是用来描述字段与方法的类型与返回参数的。</strong></p><p>基本数据类型用相应大写字母表示，对象类型用大写字母 <strong>L</strong>加对象全限定名表示。</p><center><img src="/Class文件长什么样/L.PNG"></center><p>其中数组类型用前面 <strong>[</strong>加类型表示，如 String[][],就表示为 <strong>[[Ljava/lang/String;</strong>。</p><p><strong>描述方法时，先参数列表，后返回类型。</strong>如 int i(), 表示为 <strong>（）I</strong></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>与字段表类似,只不过并发可见性(volatile)、是否可序列化(transient)不能修饰方法。</p><center><img src="/Class文件长什么样/fangfa.PNG"></center><p>方法中的代码描述，由编译器编译成字节指令后，存放在属性表<strong>attributes</strong> 的 <strong><font color="#f07c82">Code</font></strong>属性里。</p><h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p><font color="#f07c82">属性表(attributes_info)</font>在Class文件、属性表与方法表内都有出现，用于描述场景特殊信息。</p><p>属性表其它数据项目严格要求的顺序、长度和内容，它<strong>不再要求各个属性有严格的顺序，且只要不与已有属性名重复，任何实现的编译器都可向属性表中写入自己定义的属性信息；</strong>Java虚拟机在运行时会忽略掉不认识的属性。</p><p>《Java虚拟机规范(Java SE 7)》中，预定义的属性为：</p><center><img src="/Class文件长什么样/predefine1.PNG"></center><center><img src="/Class文件长什么样/predefine2.PNG"></center><p>其中每个属性表首先根据 <font color="#f07c82">attributes_name_index</font> 去常量池引用 <font color="#f07c82">CONSTANT_Class_info</font> 类型的名称，然后用一个 <font color="#f07c82">u4</font> 长度的属性说明属性表占用的长度 <font color="#f07c82">attribute_length</font> 即可。属性表中描述的信息单位是 <font color="#f07c82">u1</font>，共<font color="#f07c82">attribute_length</font>个。</p><p>属性表的结构如下：</p><center><img src="/Class文件长什么样/attributes_info.PNG"></center><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p><strong>java程序方法体内的代码通过编译成字节码后，存在Code属性中。</strong></p><p>Code属性存储在<strong>方法表的属性表集合</strong>中。</p><p>Code属性是Class文件中<strong>最重要的</strong>属性，是对代码的描述。其它信息可以看做是对元数据（类型、字段、方法及其他信息）的描述。</p><p>Code的属性表如下：</p><center><img src="/Class文件长什么样/code_info.PNG"></center><p>各部分的含义如下：</p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">attributes_name_index</td><td align="center">指向 CONSTANT_Class_info 常量索引，表示该属性表名称</td></tr><tr><td align="center">u1</td><td align="center">attribute_length</td><td align="center">属性表长度。由于属性名称索引 u2 加长属性名长度 u4，所以属性表长度为整个属性表长度减去 <strong>6</strong> 字节。</td></tr><tr><td align="center">u2</td><td align="center">max_stack</td><td align="center">栈的最大深度。<strong>Java虚拟机为该方法体分配栈针的操作栈深度</strong>。</td></tr><tr><td align="center">u2</td><td align="center">max_locals</td><td align="center">局部变量的最大存储空间。<strong>方法参数、显示异常处理的参数及方法体中定义的局部变量都需用局部变量表表示。</strong>局部变量中统计单位是 <strong>Slot</strong>。小于32位(boolean、short、char、int、float、returnAddress)的变量用一个 Slot 表示，double与long两个64位的用两个Slot表示。</td></tr><tr><td align="center">u4</td><td align="center">code_length</td><td align="center">字节码长度。实际是 u2 长度，即16个字节， 65535条字节码，超过改长度虚拟机将拒绝编译。</td></tr><tr><td align="center">u1</td><td align="center">code</td><td align="center">一些类的字节码指令，用于描述编译后的方法体内方法。</td></tr><tr><td align="center">u2</td><td align="center">exception_table_lenght</td><td align="center">显示异常处理表长度。</td></tr><tr><td align="center">excessption_info</td><td align="center">exception_table</td><td align="center">显示异常处理表</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">属性表数量</td></tr><tr><td align="center">attributes_info</td><td align="center">attributes</td><td align="center">属性表</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/6522893/" target="_blank" rel="noopener">深入理解java虚拟机</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;font co
      
    
    </summary>
    
      <category term="JVM" scheme="http://sunyunzeng.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://sunyunzeng.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 打印1到最大的n位数</title>
    <link href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>http://sunyunzeng.com/剑指Offer-打印1到最大的n位数/</id>
    <published>2019-09-24T13:23:35.000Z</published>
    <updated>2019-10-02T01:11:55.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>打印1到最大的n位数。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">打印 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>常规操作是<font color="#f07c82">暴力循环打印</font> 1 到 n 位数，但是大数问题，存在数值溢出。</p><p>采用<font color="#f07c82">字符串</font>或者<font color="#f07c82">数组</font>存储中间结果。</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>用一个 长度为 n 的数组存储，然后分别在最后一位计算，<font color="#f07c82">每次加一</font>，逢十进一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintToNNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 相加是否大于10</span></span><br><span class="line">        <span class="keyword">int</span> overflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> nSum = overflow + nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只在最后一位加</span></span><br><span class="line">            <span class="keyword">if</span>(i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                nSum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nSum &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                nums[i] = nSum;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &gt;= 10</span></span><br><span class="line">            <span class="comment">// 超出范围</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清楚掉数组前面的零</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span> isZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line">                isZero = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isZero) &#123;</span><br><span class="line">                System.out.print(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (increment(nums))&#123;</span><br><span class="line">            printArray(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>使用<font color="#f07c82">递归方法</font>，递归到组后一位，然后依次往前打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == index) &#123;</span><br><span class="line">            printArray(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            nums[index] = i;</span><br><span class="line">            recursive(nums, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        recursive(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;打印1到最大的n
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Other Algorithm" scheme="http://sunyunzeng.com/tags/Other-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 15.三数之和</title>
    <link href="http://sunyunzeng.com/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://sunyunzeng.com/LeetCode-15-三数之和/</id>
    <published>2019-09-24T01:27:20.000Z</published>
    <updated>2019-10-02T01:11:55.402Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>先<font color="#f07c82">排序</font>，然后三数之和等于零必定有<font color="#f07c82"> 1 到 2 </font>个小于零，<font color="#f07c82"> 1 到 2 </font>个大于零。</p><p>然后我们采用<font color="#f07c82">双指针</font>，先固定最小的一个数（负值）；然后双指针再后面区间寻找两个数，与前面数相加等于零。</p><p><font color="#f07c82">注意：</font>因为不能包含重复三元组，在遍历过程中注意去重。<font color="#f07c82">保证每次遍历的数字与前面不一样即可</font>（因为排序了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 排序求解</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 循环求解</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">// 此时没有满足条件的情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]+nums[k]==-nums[i])&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[j]);</span><br><span class="line">                    list.add(nums[k]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="comment">// 跳过重复的数字</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]==nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+nums[k]&lt;-nums[i])&#123;</span><br><span class="line">                    <span class="comment">// 左边负值大了</span></span><br><span class="line">                    j++;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 右边正值大了</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个包含 n
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Other Algorithm" scheme="http://sunyunzeng.com/tags/Other-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 674.最长连续子序列</title>
    <link href="http://sunyunzeng.com/Leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://sunyunzeng.com/Leetcode-674-最长连续子序列/</id>
    <published>2019-09-23T14:38:36.000Z</published>
    <updated>2019-10-02T01:11:55.405Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p><p><strong>示例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 最长连续递增序列是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], 长度为<span class="number">3</span>。</span><br><span class="line">尽管 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 也是升序的子序列, 但它不是连续的，因为<span class="number">5</span>和<span class="number">7</span>在原数组里被<span class="number">4</span>隔开。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 最长连续递增序列是 [<span class="number">2</span>], 长度为<span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>数组长度不会超过10000。</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>我的思路，用一个栈进行递增子序列长度的检查，用<font color="#f07c82">res</font>缓存结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        s.push(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                res = Math.max(res, s.size());</span><br><span class="line">                s.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, s.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>动态规划，用一个长度为n的数值维度维护每个位置的最大长度，然后取其中最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">               res = Math.max(dp[i], res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个未经排序
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="http://sunyunzeng.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：Java类和接口</title>
    <link href="http://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://sunyunzeng.com/设计模式：Java类和接口/</id>
    <published>2019-09-23T11:52:56.000Z</published>
    <updated>2019-10-02T01:11:55.426Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:57 GMT+0800 (中国标准时间) --><h1 id="使类与成员可访问性最小"><a href="#使类与成员可访问性最小" class="headerlink" title="使类与成员可访问性最小"></a>使类与成员可访问性最小</h1><h2 id="成员（类、接口、方法、字段）的访问级别"><a href="#成员（类、接口、方法、字段）的访问级别" class="headerlink" title="成员（类、接口、方法、字段）的访问级别"></a>成员（类、接口、方法、字段）的访问级别</h2><ul><li><p><font color="#f07c82">private</font> —— 该成员只能在声明它的顶级类内访问。</p></li><li><p><font color="#f07c82">package-private</font> —— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。</p></li><li><p><font color="#f07c82">protected</font> —— 成员可以从被声明的类的子类中访问（会受一些限制 [JLS, 6.6.2]），以及它声明的包中的任何类。</p></li><li><p><font color="#f07c82">public</font> —— 该成员可以从任何地方被访问。</p></li></ul><h2 id="公共类的实例字段很少情况下采用-public-修饰"><a href="#公共类的实例字段很少情况下采用-public-修饰" class="headerlink" title="公共类的实例字段很少情况下采用 public 修饰"></a>公共类的实例字段很少情况下采用 public 修饰</h2><p>如果需要<strong>调用私有成员</strong>，就<strong>写一个方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="公共类中使用访问方法而不是访问属性"><a href="#公共类中使用访问方法而不是访问属性" class="headerlink" title="公共类中使用访问方法而不是访问属性"></a>公共类中使用访问方法而不是访问属性</h1><p>虽然包内访问权限，如果只包内可见是可行的，也可以，同时可以避免视觉混乱，但是不提倡这样做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Degenerate classes like this should not be public!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提供提供方法与设置方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encapsulation of data by accessor methods and mutators</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">this</span>.y = y; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h1><p>不变类中<font color="#f07c82">所有实例的信息在生命周期中都是固定的</font>，因此是安全可靠的。</p><h2 id="不变类的设计规则"><a href="#不变类的设计规则" class="headerlink" title="不变类的设计规则"></a>不变类的设计规则</h2><ul><li><p><font color="#f07c82">不要提供修改对象状态的方法</font> （也称为 mutators）。</p></li><li><p><font color="#f07c82">确保这个类不能被继承。</font> 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。</p></li><li><p><font color="#f07c82">把所有属性设置为 final。</font> 通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为。</p></li><li><p><font color="#f07c82">把所有的属性设置为 private。</font> 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共 final 属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示。</p></li><li><p><font color="#f07c82">确保对任何可变组件的互斥访问。</font> 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法中进行防御性拷贝。</p></li></ul><h1 id="多使用组合而不是继承"><a href="#多使用组合而不是继承" class="headerlink" title="多使用组合而不是继承"></a>多使用组合而不是继承</h1><p>如果父类不是为了继承而专门设计，那么后面父类的修改可能会导致子类产生严重的bug。</p><p>明智的方法是多使用组合<font color="#f07c82">composition</font>。即在类内部使用其它类的引用。</p><p>一个<font color="#f07c82">新类</font>由一系列<font color="#f07c82">现有类</font>组成，<strong>新类的方法通过调用现有类的方法获取结果</strong>，成为<font color="#f07c82">转发 (farwarding)</font>。</p><h1 id="继承需要深思熟虑还要详细的设计文档"><a href="#继承需要深思熟虑还要详细的设计文档" class="headerlink" title="继承需要深思熟虑还要详细的设计文档"></a>继承需要深思熟虑还要详细的设计文档</h1><p>测试为继承而设计的类的唯一方法是<font color="#f07c82">编写子类</font>。</p><p><strong>构造方法绝不能直接或间接调用可重写的方法。</strong></p><p>For example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Broken - constructor invokes an overridable method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Blank final, set by constructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instant instant;</span><br><span class="line"></span><br><span class="line">    Sub() &#123;</span><br><span class="line">        instant = Instant.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overriding method invoked by superclass constructor</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        sub.overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述子类由于重写了方法，调用父类时 instant 成员没有指向任何一个对象，因此有问题。</p><p>专门为了继承而设计类是一件很辛苦的工作。你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。为了允许其他人能编写出高效的子类，还你必须导出一个或者多个受保护的方法。除非知道真正需要子类，否则最好通过将类声明为 <font color="#f07c82">final</font>，或者确保没有可访问的构造器来禁止类被继承。</p><h1 id="接口优先抽象类"><a href="#接口优先抽象类" class="headerlink" title="接口优先抽象类"></a>接口优先抽象类</h1><p>抽象类的实现只有继承，限制了<strong>混合类型</strong>的定义。</p><p>同时，对于非层次的类级关系，想要为类<strong>添加额外</strong>的功能，接口是一个很好的方法。</p><p><strong><font color="#f07c82">骨架抽象类</font></strong>，首先是一个<strong>抽象类</strong>，然后该抽象类<strong>实现了一个接口</strong>的基本方法，形成默认的方法实现，提供基础的功能。</p><p>用户可以自由的选择是选择<strong>继承该抽象类</strong>还是<strong>直接实现该抽象类实现的接口</strong>，从而保证灵活性。</p><p>骨架抽象类的例子：<font color="#f07c82">AbstractList、AbstractSet</font>等。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skeletal implementation class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries in a modifiable map must override this method</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implements the general contract of Map.Entry.equals</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(e.getKey(),  getKey())</span><br><span class="line">            &amp;&amp; Objects.equals(e.getValue(), getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implements the general contract of Map.Entry.hashCode</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey())</span><br><span class="line">             ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口用户定义类型"><a href="#接口用户定义类型" class="headerlink" title="接口用户定义类型"></a>接口用户定义类型</h1><h1 id="层次类优先于标签类"><a href="#层次类优先于标签类" class="headerlink" title="层次类优先于标签类"></a>层次类优先于标签类</h1><p><strong>标签类：</strong>是一个类，该类的实例根据<strong>构造方法传入标签</strong>的不同而不同。</p><pre><code>问题：代码可读性差，扩展性差，且内存负担大，因为类实例保存很多不属于它本身的字段。</code></pre><p><strong>层次类：</strong>即在顶层实现一个<strong>抽象类</strong>，该抽象类将属于<strong>公共的方法、字段及依赖于标签值的方法包括起来，提供实现样板</strong>。然后根据需求依次实现不同的<strong>子类</strong>，每个子类实现各自的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tagged class - vastly inferior to a class hierarchy!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Shape &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">          <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">          <span class="keyword">case</span> CIRCLE:</span><br><span class="line">            <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层次类</span></span><br><span class="line"><span class="comment">// Class hierarchy replacement for a tagged class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    Circle(<span class="keyword">double</span> radius) &#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.PI * (radius * radius); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width  = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length * width; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类之间的层次关系可读且灵活</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    Square(<span class="keyword">double</span> side) &#123;</span><br><span class="line">        <span class="keyword">super</span>(side, side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p><strong>嵌套类</strong>最好只存在于宿主类 (enclosing class) 中, 否则，就应将其设计为<strong>顶层类</strong>。</p><p><strong>四种嵌套类：</strong><font color="#f07c82">静态内部类</font>、<font color="#f07c82">非静态内部类</font>、<font color="#f07c82">匿名类</font>、<font color="#f07c82">局部类</font>。</p><p><strong>静态内部类：</strong>不与类的实例有关联，一个用法是提供类的帮助类。</p><p><strong>非静态内部类：</strong>确定<strong>与实例有关联</strong>才用，否则其默认将引用传给宿主类的实例，会占用存储空间与时间。最常用方法就是 Adapter 模式，可将外部类的实例视为某个不相关类的实例。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typical use of a nonstatic member class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名类：</strong> 只能在<strong>非静态上下文环境中</strong>使用时声明与实例化，<strong>在静态上下文环境</strong>，只能带有<strong>常量型变量</strong>（<font color="#f07c82">final</font>修饰的基本类型及初始化为 <font color="#f07c82">String</font>）。不能执行 <font color="#f07c82">instanceof</font> 方法测试，不能在运行外实例化，不能实现多个接口或继承一个类同时实现一个接口。常用：<strong>创建小函数对象和处理对象的首选方法。</strong></p><p><strong>局部类：</strong>非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。</p><h1 id="永远不要将多个顶级类或接口放在一个源文件中"><a href="#永远不要将多个顶级类或接口放在一个源文件中" class="headerlink" title="永远不要将多个顶级类或接口放在一个源文件中"></a>永远不要将多个顶级类或接口放在一个源文件中</h1><p><strong>保证在编译时不能有多个定义。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:57 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;使类与成员可访问性最小&quot;&gt;&lt;a href=&quot;#使类与成员可访问性最小&quot; class=&quot;headerlink&quot; title=&quot;使类与成员可访问
      
    
    </summary>
    
      <category term="Java" scheme="http://sunyunzeng.com/categories/Java/"/>
    
    
      <category term="Java设计模式" scheme="http://sunyunzeng.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：Java方法</title>
    <link href="http://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E6%96%B9%E6%B3%95/"/>
    <id>http://sunyunzeng.com/设计模式：Java方法/</id>
    <published>2019-09-22T13:14:07.000Z</published>
    <updated>2019-10-02T01:11:55.417Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="使用-try-with-resources调用用完需关闭的方法。"><a href="#使用-try-with-resources调用用完需关闭的方法。" class="headerlink" title="使用 try-with-resources调用用完需关闭的方法。"></a>使用 <font color="#f07c82">try-with-resources</font>调用用完需关闭的方法。</h1><p>实现了 <font color="#f07c82">AutoCloseable</font>接口（由一个返回为 <font color="#f07c82">void</font>的<font color="#f07c82">close</font>组成）的资源可以使用<font color="#f07c82">try-with-resources</font>方法。</p><p><font color="#f07c82">AutoCloseable</font>接口在Java的类库和第三方类库中许多类和接口都有实现或继承，例如 BufferedReader、InputStream、OutputStream 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(dst))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span>((n = in.read(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    OutputStream </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写equals方法规则"><a href="#重写equals方法规则" class="headerlink" title="重写equals方法规则"></a>重写<font color="#f07c82">equals</font>方法规则</h1><ol><li><p>使用 <strong>==</strong> 运算符检查参数是否为该对象的引用。如果是，返回 <strong>true</strong>。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。</p></li><li><p>使用 <strong>instanceof</strong> 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。</p></li><li><p>参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。</p></li><li><p>对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。</p></li></ol><ul><li><p>对于类型为<strong>非 float</strong> 或 <strong>double</strong> 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 <strong>Float.compare(float, float)</strong> 方法；对于 double 基本类型的属性，使用 <strong>Double.compare(double, double)</strong> 方法。由于存在 <strong>Float.NaN，-0.0f 和类似的 double 类型</strong>的值，所以需要对 float 和 double 属性进行特殊的处理；虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。</p></li><li><p>某些对象引用的属性可能合法地包含 <strong>null</strong>。 为避免出现 NullPointerException 异常，请使用静态方法 <strong>Objects.equals(Object, Object)</strong> 检查这些属性是否相等。</p></li></ul><h1 id="重写equals方法时一定重写hashCode方法。"><a href="#重写equals方法时一定重写hashCode方法。" class="headerlink" title="重写equals方法时一定重写hashCode方法。"></a>重写<font color="#f07c82">equals</font>方法时一定重写<font color="#f07c82">hashCode</font>方法。</h1><p>基于Hash值的散列数据结构，例如hashMap、HashSet等，需要基于Hash值判断两个是否相等，其实是根据<font color="#f07c82">equals</font>方法来判断。</p><p><font color="#f07c82">equals</font>方法改变，要想实例也能跟被基于hash的散列结构识别，需要将<font color="#f07c82">hashCode</font>方法重写。</p><h1 id="时刻重写toString方法。"><a href="#时刻重写toString方法。" class="headerlink" title="时刻重写toString方法。"></a>时刻重写<font color="#f07c82">toString</font>方法。</h1><h1 id="使用clone方法对于可变对象的克隆需要谨慎。"><a href="#使用clone方法对于可变对象的克隆需要谨慎。" class="headerlink" title="使用clone方法对于可变对象的克隆需要谨慎。"></a>使用clone方法对于<font color="#f07c82">可变对象</font>的克隆需要谨慎。</h1><p>克隆出来的对象的类型与原始对象的一致，并且<font color="#f07c82">x.clone != x</font>返回<font color="#f07c82">true</font>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashTable的克隆方法，需要深度克隆，保证克隆出来的对象是原先对象的深层拷贝，桶或链都拷贝一份</span></span><br><span class="line"><span class="comment">// Recursive clone method for class with complex mutable state</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key   = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively copy the linked list headed by this Entry</span></span><br><span class="line">        <span class="comment">//Entry deepCopy() &#123;</span></span><br><span class="line">        <span class="comment">//    return new Entry(key, value,</span></span><br><span class="line">        <span class="comment">//        next == null ? null : next.deepCopy());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 避免链表过长导致栈溢出错误</span></span><br><span class="line">        <span class="function">Entry <span class="title">deepCopy</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Entry result = <span class="keyword">new</span> Entry(key, value, next);</span><br><span class="line">            <span class="keyword">for</span>(Entry p = result; p!=<span class="keyword">null</span>; p=p.next)&#123;</span><br><span class="line">                 p.next = <span class="keyword">new</span> Entry(p.next.key, p.next.value, p.next.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> HashTable <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashTable result = (HashTable) <span class="keyword">super</span>.clone();</span><br><span class="line">            result.buckets = <span class="keyword">new</span> Entry[buckets.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (buckets[i] != <span class="keyword">null</span>)</span><br><span class="line">                    result.buckets[i] = buckets[i].deepCopy();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在可比较大小的类中考虑实验Comparable接口。"><a href="#在可比较大小的类中考虑实验Comparable接口。" class="headerlink" title="在可比较大小的类中考虑实验Comparable接口。"></a>在可比较大小的类中考虑实验<font color="#f07c82">Comparable</font>接口。</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<font color="#f07c82">conpareTo()</font>中比较大小时，避免使用<font color="#f07c82"> &lt; </font>或者<font color="#f07c82"> &gt; </font>,应该使用包装类中的<font color="#f07c82">compare()</font>方法或者自己实现<font color="#f07c82">Comparator</font>接口中的<font color="#f07c82">compare()</font>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator based on static compare method</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator based on Comparator construction method</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder =</span><br><span class="line">        Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure><p><strong>参考：</strong> <u><a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a></u></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;使用-try-with-resources调用用完需关闭的方法。&quot;&gt;&lt;a href=&quot;#使用-try-with-resources调用用完需
      
    
    </summary>
    
      <category term="Java" scheme="http://sunyunzeng.com/categories/Java/"/>
    
    
      <category term="Java设计模式" scheme="http://sunyunzeng.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：Java创建对象</title>
    <link href="http://sunyunzeng.com/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://sunyunzeng.com/Java创建对象设计模式/</id>
    <published>2019-09-20T13:20:39.000Z</published>
    <updated>2019-10-02T01:11:55.374Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="使用静态工厂方法代替构造方法"><a href="#使用静态工厂方法代替构造方法" class="headerlink" title="使用静态工厂方法代替构造方法"></a>使用静态工厂方法代替构造方法</h1><p>静态工厂方法是一个静态方法，用来生成实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="comment">// 私有方法防止在外调用创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为构造方法每次调用都需要<font color="#f07c82">新建一个对象</font>，有些情况下不能满我们的要求。</p><p>而静态工厂方法生成对象有以下几个好处：</p><p><strong>1. 名字更有意义。</strong></p><ul><li><font color="#f07c82">from</font> —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant);</li><li><font color="#f07c82">of</font> —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set faceCards = EnumSet.of(JACK, QUEEN, KING);</li><li><font color="#f07c82">valueOf</font> —— from 和 to 更为详细的替代 方式，例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</li><li><font color="#f07c82">instance 或 getinstance</font> —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：StackWalker luke = StackWalker.getInstance(options);</li><li><font color="#f07c82">create 或 newInstance</font> —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen);</li><li><font color="#f07c82">getType</font> —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：FileStore fs = Files.getFileStore(path);</li><li><font color="#f07c82">newType</font> —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：BufferedReader br = Files.newBufferedReader(path);</li><li><font color="#f07c82">type —— getType 和 newType</font> 简洁的替代方式，例如：List litany = Collections.list(legacyLitany);</li></ul><p><strong>2. 可以实现实例数量的控制。</strong></p><p>例如单例、不可实例化类的实现。</p><p><strong>3. 返回的对象可以根据参数不同而不同。</strong></p><p><strong>4. 返回的实例可以没有对应的对象类型。</strong></p><p>例如服务者提供框架，就是用到静态工厂方法。</p><p>服务接口，表示实现；提供者注册API，选择实现；服务访问API，客户端调用。服务提供者接口，描述生成服务接口实例的工厂对象。</p><p><font color="#f07c82">依赖注入框架</font>可以被看作强大的服务提供者。</p><h1 id="当构造函数多时使用builder模式"><a href="#当构造函数多时使用builder模式" class="headerlink" title="当构造函数多时使用builder模式"></a>当构造函数多时使用<strong>builder</strong>模式</h1><p>构造函数名字都与类名一样，区分不同构造函数依靠参数的顺序与数量。</p><p>当构造参数很多时，实例的生成非常麻烦，往往不知道调用哪个构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> calories;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> fat;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> calories)</span></span>&#123;</span><br><span class="line">            calories = calories;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> fat)</span></span>&#123;</span><br><span class="line">            fat = fat;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = builder.servingSize;</span><br><span class="line">        <span class="keyword">this</span>.calories = builder.calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NutritionFacts coca = NutritionFacts.Builder(<span class="number">10</span>).calories(<span class="number">40</span>).fat(<span class="number">0</span>).build();</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><p>当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式，线程不安全，不是严格意义上单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dog==<span class="keyword">null</span>)</span><br><span class="line">            dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式，线程安全，但易产生垃圾</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类方式，线程安全，但是序列化要保证单例，需要重写 readResolve()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化也保证一个单类</span></span><br><span class="line">    <span class="function">Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举模式，最简单，但不常用。线程安全，且保证序列化唯一性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Dog&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Dog.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用私有构造方法非实例化"><a href="#使用私有构造方法非实例化" class="headerlink" title="使用私有构造方法非实例化"></a>使用私有构造方法非实例化</h1><p>构造方法声明为私有方法，可以创建非实例化类。</p><p>该类存在的意义就是提供工具静态方法，例如 <font color="#f07c82">java.util.Arrays</font> 工具类等。</p><h1 id="简单依赖注入"><a href="#简单依赖注入" class="headerlink" title="简单依赖注入"></a>简单依赖注入</h1><p>通过构造方法把<strong>类依赖</strong>的<strong>客户端资源</strong>注入到类中，是依赖注入的一种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Chinese dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Chinese dictionary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = Object.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过依赖注入把同一子类的资源工厂当做参数。</p><p><font color="#f07c82">工厂就是可以被重复调用生产实例的对象。</font></p><p>Java 8的函数式接口<font color="#f07c82">Supplier<t></t></font>非常适合工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 用来提供对象</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mosaic <span class="title">create</span><span class="params">(Supplier&lt;T? extends Tile&gt; tileFactroy)</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure><h1 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h1><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line">Integer it = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建了1000000对象</span></span><br><span class="line">    it += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2</span></span><br><span class="line"><span class="comment">// 多创建了一个String</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"moreClass"</span>);</span><br></pre></td></tr></table></figure><p><font color="#f07c82">原则：</font></p><p><strong>尽量使用基本类型而不使用装箱的基本类型，即使自动装箱也要考虑。</strong></p><h1 id="消除过期的对象引用。"><a href="#消除过期的对象引用。" class="headerlink" title="消除过期的对象引用。"></a>消除过期的对象引用。</h1><p>如果对象引用是隐式存在，如果不需要，则置为<strong>null</strong>。</p><p>例如编写stack类pop()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; pop()&#123;</span><br><span class="line">    &lt;T&gt; result = bucket[--size];</span><br><span class="line">    bucket[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免使用Finalizer和Cleaner机制！"><a href="#避免使用Finalizer和Cleaner机制！" class="headerlink" title="避免使用Finalizer和Cleaner机制！"></a><strong>避免使用<font color="#f07c82">Finalizer</font>和<font color="#f07c82">Cleaner</font>机制！</strong></h1><p><strong>参考：</strong> <u><a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a></u></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;使用静态工厂方法代替构造方法&quot;&gt;&lt;a href=&quot;#使用静态工厂方法代替构造方法&quot; class=&quot;headerlink&quot; title=&quot;使用
      
    
    </summary>
    
      <category term="Java" scheme="http://sunyunzeng.com/categories/Java/"/>
    
    
      <category term="Java设计模式" scheme="http://sunyunzeng.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 33.搜索旋转排序数组</title>
    <link href="http://sunyunzeng.com/Leetcode%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://sunyunzeng.com/Leetcode搜索旋转排序数组/</id>
    <published>2019-09-15T12:50:03.000Z</published>
    <updated>2019-09-17T09:45:15.056Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p><strong>示例1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>时间复杂度要求是O(log n)，也就是二分法。于是我写了一个最基础的二分法…还是用递归..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> subSearch(nums, target, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(right-left==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        tmp=subSearch(nums, target, left, mid);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(tmp!=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        tmp=subSearch(nums, target, mid, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了答案之后… 我想说:****</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 左侧不包含旋转序列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右侧不包含旋转序列</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-rotated-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;假设按照升序排序
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Other Algorithm" scheme="http://sunyunzeng.com/tags/Other-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Servlet技术</title>
    <link href="http://sunyunzeng.com/Servlet%E6%8A%80%E6%9C%AF/"/>
    <id>http://sunyunzeng.com/Servlet技术/</id>
    <published>2019-09-11T10:56:49.000Z</published>
    <updated>2019-09-17T09:45:15.066Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="什么是Servet"><a href="#什么是Servet" class="headerlink" title="什么是Servet?"></a>什么是Servet?</h1><p>Servlet (Server Applet)，从字面上看，就是<font color="#f07c82">Java</font>服务器小程序的意思。它确实就像字面意思一样，是<font color="#f07c82">在服务中用于处理网络请求的小程序</font>。</p><p>在Web的世界中，客户端会提交各种请求到服务端，服务端如何处理客户端的请求呢？</p><p>常规的Java编程方法，好像很难完成这项任务，但是没有事情是难倒程序猿的。</p><p>于是，他们设计了<font color="#f07c82">Servlet规范</font>，用来处理网络的各种请求。</p><p>具体网络的请求呢，无非就是<font color="#f07c82">get、post等等</font>，这在<a href="http://sunyunzeng.com/categories/HTTP/">HTTP规范系列</a>里面有讲到。</p><p>Servlet规范也没有想象中的那么高大上，其实它就是一个<strong>Java接口</strong>，里面一共就定义了五个方法，如图：</p><img src="/Servlet技术/servlet_interface.PNG"><p>其中：</p><blockquote><ul><li>init() 规定了Servet如何初始化。</li><li>getServletConfig() 获取Sevvlet的配置。</li><li>service(ServletRequest, ServletResponse) 接收到请求怎么处理。</li><li>getServletInfo() 提供有关servlet的信息，如作者、版本、版权等。</li><li>destroy() 销毁Servlet。</li></ul></blockquote><h1 id="Servlet的运行"><a href="#Servlet的运行" class="headerlink" title="Servlet的运行"></a>Servlet的运行</h1><p>任何合理实现了Servlet接口的类都具有处理HTTP请求的能力，但是就像java类的运行需要在JVM环境中一样，Servlet的运行也要环境，这里称为<font color="#f07c82">容器</font>。</p><p>即Servlet的运行需要特定的容器，<strong>该容器负责实现对端口的监听，将请求内容解析，然后实例Servlet对象，给Servlet提供运行环境，然后将Servlet的处理结果发给客户端</strong>。</p><p><strong>Tomcat</strong>就是一个开源的Servlet的容器，它也是一个Web服务器。</p><p><font color="#f07c82">HttpServlet</font>就是已经实现好的一个Servlet类，他对一些方法进行了详细的补充，我们通过doGet()、doPost()等方法很方便地实现处理HTTP请求功能。</p><p>它的一些源码如下：</p><ol><li><p>service()实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取http request的method参数，其实就是html的form标签  </span></span><br><span class="line">        <span class="comment">//中method属性对应的字符串 </span></span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        <span class="keyword">long</span> errMsg;</span><br><span class="line">        <span class="comment">//判断请求方式</span></span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            <span class="comment">//获取最后被修改时间 </span></span><br><span class="line">            errMsg = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span>(errMsg == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">/**如果servlet不支持http request header的if-modified-since属性 </span></span><br><span class="line"><span class="comment">             * 则继续处理 </span></span><br><span class="line"><span class="comment">             **/</span>  </span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果支持这个属性 </span></span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">/** </span></span><br><span class="line"><span class="comment">                * 如果客户端的文件最后修改时间和服务器端的文件最后修改时间一致则返回304不需要修改状态 </span></span><br><span class="line"><span class="comment">                * 这样服务器就不返回html，浏览器读取本地缓存文件，否则重新获取服务器端的对应html文件 </span></span><br><span class="line"><span class="comment">                **/</span>  </span><br><span class="line">                <span class="keyword">if</span>(ifModifiedSince &lt; errMsg / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, errMsg);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">            errMsg = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, errMsg);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果请求不是以上的所有请求方式，该方法就会响应501错误，也就是不支持这种请求</span></span><br><span class="line">            String errMsg1 = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg1 = MessageFormat.format(errMsg1, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg1);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = (HttpServletRequest)req;</span><br><span class="line">            response = (HttpServletResponse)res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>doGet()实现：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取协议 </span></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        <span class="comment">//获取http.method_get_not_supported的国际化字符串</span></span><br><span class="line">        String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</span><br><span class="line">        <span class="keyword">if</span>(protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</span><br><span class="line">        <span class="comment">//如果是HTTP/1.1，返回405禁止访问方法错误</span></span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是HTTP/1.1，返回400错误的请求错误  </span></span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>doPost()实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">"http.method_post_not_supported"</span>);</span><br><span class="line">        <span class="keyword">if</span>(protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>其实在工业界，几乎没有直接利用Servlet开发Web应用的了，但是它是一个基础，很多开源框架都是基于Servlet开发的，如大名鼎鼎的<a href="https://spring.io/" target="_blank" rel="noopener">Spring</a></strong></p><h1 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h1><ol><li>首先我写一个Servlet类,作用是得到get()请求，然后返回“Hello Servlet!”与打印当前时间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"</span>);</span><br><span class="line">            response.getWriter().println(<span class="keyword">new</span> Date().toLocaleString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后配置web.xml文件，建立URL与Servlet处理类 <strong>HelloServlet</strong> 之间的关联关系。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">HelloServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">HelloServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">hello</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<strong>servlet-name</strong>是类名简写，<strong>servlet-class</strong> 是类名。</p><p><strong>servlet-mapping</strong>实现URL与类的映射，这里实现了访问路径 <a href="http://127.0.0.1//hello" target="_blank" rel="noopener">http://127.0.0.1//hello</a> 时调用HelloServlet类的相应方法。</p><p><a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a> 是一个监听地址，需要服务器实现监听，此时就需要Tomcat。</p><p>然后修改Tomcat的conf/server.xml的路径配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">docBase</span>=<span class="string">"F:\\eclipse-workspace\\j2ee\\web"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Servlet的特点"><a href="#Servlet的特点" class="headerlink" title="Servlet的特点"></a>Servlet的特点</h1><p><strong>1. Servlet是单实例多线程。</strong></p><blockquote><p>1) 当Web服务器启动或者用户请求抵达服务器时，Servlet被实例化且只存在一个实例。<br>2) 当请求抵达时，Servlet容器(如Tomcat)会调度线程 (Dispathchaer Thread)调度它管理下的线程池中等待执行的线程 (Worker Thread) 给请求者。<br>3) 线程执行Servlet中的sercive方法。<br>4) 请求结束，该线程放回线程池，等待被调用。</p></blockquote><p><strong>2. Servet使用标准API，可被更多Web服务器调用。</strong></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>由于Servlet是单实例多线程，当多个线程的用户同时访问共享资源时，就会出现<font color="#f07c82">线程安全的问题</font>。</p><p><strong>解决方法:</strong></p><p>首先，定义在 doPost() 和 doGet()里的方法由于是<strong>局部变量</strong>，再每个用户调用实例方法时都会初始化，所以<strong>不存在线程安全</strong>。（一些属性尽量定义在实例的局部方法中）</p><p>实在需要共享的资源，只需加<font color="#f07c82">synchronized同步机制</font>，在共享资源被某一线程占用后，该线程就拥有锁，其它线程只有等待该线程执行完毕才能使用该资源（抢占锁后一一执行）。</p><h1 id="Servlet的常用方法"><a href="#Servlet的常用方法" class="headerlink" title="Servlet的常用方法"></a>Servlet的常用方法</h1><p>在HttpServlet中sercive方法中，参数列表接受两个对象，一个是<font color="#f07c82">HttpServletResponse</font>对象，一个是<font color="#f07c82">HttpServletRequest</font>对象。</p><h2 id="HttpServletRequest常用方法"><a href="#HttpServletRequest常用方法" class="headerlink" title="HttpServletRequest常用方法"></a>HttpServletRequest常用方法</h2><p><strong>常见方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">request.getRequestURL()</td><td align="center">浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”</td></tr><tr><td align="center">request.getRequestURI()</td><td align="center">浏览器发出请求的资源名部分，去掉了协议和主机名”</td></tr><tr><td align="center">request.getQueryString()</td><td align="center">请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到</td></tr><tr><td align="center">request.getRemoteAddr()</td><td align="center">浏览器所处于的客户机的IP地址</td></tr><tr><td align="center">request.getRemoteHost()</td><td align="center">浏览器所处于的客户机的主机名</td></tr><tr><td align="center">request.getRemotePort()</td><td align="center">浏览器所处于的客户机使用的网络端口</td></tr><tr><td align="center">request.getLocalAddr()</td><td align="center">服务器的IP地址</td></tr><tr><td align="center">request.getLocalName()</td><td align="center">服务器的主机名</td></tr><tr><td align="center">request.getMethod()</td><td align="center">得到客户机请求方式一般是GET或者POST</td></tr></tbody></table><p><strong>获取参数</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">request.getParameter()</td><td align="center">是常见的方法，用于获取单值的参数</td></tr><tr><td align="center">request.getParameterValues()</td><td align="center">用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。</td></tr><tr><td align="center">request.getParameterMap()</td><td align="center">用于遍历所有的参数，并返回Map类型。</td></tr></tbody></table><p><strong>获取头信息</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">request.getHeader()</td><td align="center">获取浏览器传递过来的头信息。</td></tr><tr><td align="center">比如getHeader(“user-agent”)</td><td align="center">可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器</td></tr><tr><td align="center">request.getHeaderNames()</td><td align="center">获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</td></tr></tbody></table><p>头信息含义：</p><blockquote><p>host: 主机地址<br>user-agent: 浏览器基本资料<br>accept: 表示浏览器接受的数据类型<br>accept-language: 表示浏览器接受的语言<br>accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码<br>connection: 是否保持连接<br>cache-control: 缓存时限</p></blockquote><h2 id="HttpServletResponse常用方法"><a href="#HttpServletResponse常用方法" class="headerlink" title="HttpServletResponse常用方法"></a>HttpServletResponse常用方法</h2><ol><li><p>设置相应内容</p><p><font color="#f07c82">PrintWriter pw= response.getWriter();</font></p><p>通过<code>response.getWriter();</code> 获取一个PrintWriter 对象</p><p>可以使用<code>println()</code>,<code>append()</code>,<code>write()</code>,<code>format()</code>等等方法设置返回给浏览器的html内容。</p></li><li><p>设置相应内容</p><p><font color="#f07c82">response.setContentType(“text/html”);</font></p></li><li><p>设置相应编码</p><ul><li><p><code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code><br>不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文</p></li><li><p><code>response.setCharacterEncoding(&quot;UTF-8&quot;);</code><br>仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。</p></li></ul></li><li><p>301或者302客户端跳转</p><p>客户端有两种跳转:</p><ul><li><p>302 表示临时跳转<br><code>response.sendRedirect(&quot;fail.html&quot;);</code></p></li><li><p>301 表示永久性跳转<br><code>response.setStatus(301);</code><br><code>response.setHeader(&quot;Location&quot;, &quot;fail.html&quot;);</code></p></li></ul></li><li><p>设置不使用缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setDateHeader(<span class="string">"Expires"</span>,<span class="number">0</span> );</span><br><span class="line">response.setHeader(<span class="string">"Cache-Control"</span>,<span class="string">"no-cache"</span>);</span><br><span class="line">response.setHeader(<span class="string">"pragma"</span>,<span class="string">"no-cache"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>参考: <u><a href="http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere" target="_blank" rel="noopener">http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere</a></u></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;什么是Servet&quot;&gt;&lt;a href=&quot;#什么是Servet&quot; class=&quot;headerlink&quot; title=&quot;什么是Servet?&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://sunyunzeng.com/categories/Java/"/>
    
    
      <category term="Servlet" scheme="http://sunyunzeng.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="http://sunyunzeng.com/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://sunyunzeng.com/Git-常用命令/</id>
    <published>2019-09-11T04:31:05.000Z</published>
    <updated>2019-09-11T15:51:36.521Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是世界上<font color="#f07c82">最先进的</font><strong>分布式</strong>版本控制系统。</p><p>当时是为了帮助管理 <strong>linux</strong> 内核开发而开发的一个开源码版本控制系统。</p><img src="/Git-常用命令/git_priciple.jpg"><ul><li><p>Workspace：工作区</p></li><li><p>Index / Stage：暂存区</p></li><li><p>Repository：仓库区（或本地仓库）</p></li><li><p>Remote：远程仓库</p></li></ul><p>Git 是分布式版本控制系统，每个人的电脑上都有完整的版本库。</p><h1 id="常用命令列表"><a href="#常用命令列表" class="headerlink" title="常用命令列表"></a>常用命令列表</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:yeszao/dofiler.git         # 配置远程git版本库</span><br><span class="line">$ git pull origin master                                          # 下载代码及快速合并 </span><br><span class="line">$ git add .                       # 跟踪所有改动过的文件</span><br><span class="line">$ git add &lt;file&gt;                  # 跟踪指定的文件</span><br><span class="line">$ git commit -m “commit message”  # 提交所有更新过的文件</span><br><span class="line">$ git push origin master                                          # 上传代码及快速合并</span><br><span class="line">$ git fetch origin                                                # 从远程库获取代码</span><br><span class="line"></span><br><span class="line">$ git branch                                                      # 显示所有分支</span><br><span class="line">$ git checkout master                                             # 切换到master分支</span><br><span class="line">$ git checkout -b dev                                             # 创建并切换到dev分支</span><br><span class="line">$ git commit -m &quot;first version&quot;                                   # 提交</span><br><span class="line"></span><br><span class="line">$ git status                                                      # 查看状态</span><br><span class="line">$ git log                                                         # 查看提交历史</span><br><span class="line"></span><br><span class="line">$ git config --global core.editor vim                             # 设置默认编辑器为vim（git默认用nano）</span><br><span class="line">$ git config core.ignorecase false                                # 设置大小写敏感</span><br><span class="line">$ git config --global user.name &quot;YOUR NAME&quot;                       # 设置用户名</span><br><span class="line">$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;             # 设置邮箱</span><br></pre></td></tr></table></figure><h2 id="别名Alias"><a href="#别名Alias" class="headerlink" title="别名Alias"></a>别名Alias</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.br=&quot;branch&quot;                 # 创建/查看本地分支</span><br><span class="line">$ git config --global alias.co=&quot;checkout&quot;               # 切换分支</span><br><span class="line">$ git config --global alias.cb=&quot;checkout -b&quot;            # 创建并切换到新分支</span><br><span class="line">$ git config --global alias.cm=&quot;commit -m&quot;              # 提交</span><br><span class="line">$ git config --global alias.st=&quot;status&quot;                 # 查看状态</span><br><span class="line">$ git config --global alias.pullm=&quot;pull origin master&quot;  # 拉取分支</span><br><span class="line">$ git config --global alias.pushm=&quot;push origin master&quot;  # 提交分支</span><br><span class="line">$ git config --global alias.log=&quot;git log --oneline --graph --decorate --color=always&quot; # 单行、分颜色显示记录</span><br><span class="line">$ git config --global alias.logg=&quot;git log --graph --all --format=format:&apos;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)&apos; --abbrev-commit --date=relative&quot; # 复杂显示</span><br></pre></td></tr></table></figure><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt;                 # 克隆远程版本库</span><br><span class="line">$ git init                        # 初始化本地版本库</span><br></pre></td></tr></table></figure><h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status                      # 查看状态</span><br><span class="line">$ git diff                        # 查看变更内容</span><br><span class="line">$ git add .                       # 跟踪所有改动过的文件</span><br><span class="line">$ git add &lt;file&gt;                  # 跟踪指定的文件</span><br><span class="line">$ git mv &lt;old&gt; &lt;new&gt;              # 文件改名</span><br><span class="line">$ git rm &lt;file&gt;                   # 删除文件</span><br><span class="line">$ git rm --cached &lt;file&gt;          # 停止跟踪文件但不删除</span><br><span class="line">$ git commit -m “commit message”  # 提交所有更新过的文件</span><br><span class="line">$ git commit --amend              # 修改最后一次提交</span><br></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log                         # 查看提交历史</span><br><span class="line">$ git log -p &lt;file&gt;               # 查看指定文件的提交历史</span><br><span class="line">$ git blame &lt;file&gt;                # 以列表方式查看指定文件的提交历史</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD           # 撤消工作目录中所有未提交文件的修改内容</span><br><span class="line">$ git reset --hard &lt;version&gt;      # 撤销到某个特定版本</span><br><span class="line">$ git checkout HEAD &lt;file&gt;        # 撤消指定的未提交文件的修改内容</span><br><span class="line">$ git checkout -- &lt;file&gt;          # 同上一个命令</span><br><span class="line">$ git revert &lt;commit&gt;             # 撤消指定的提交</span><br></pre></td></tr></table></figure><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git branch                      # 显示所有本地分支</span><br><span class="line">$ git checkout &lt;branch/tag&gt;       # 切换到指定分支或标签</span><br><span class="line">$ git branch &lt;new-branch&gt;         # 创建新分支</span><br><span class="line">$ git branch -d &lt;branch&gt;          # 删除本地分支</span><br><span class="line">$ git tag                         # 列出所有本地标签</span><br><span class="line">$ git tag &lt;tagname&gt;               # 基于最新提交创建标签</span><br><span class="line">$ git tag -a &quot;v1.0&quot; -m &quot;一些说明&quot;  # -a指定标签名称，-m指定标签说明</span><br><span class="line">$ git tag -d &lt;tagname&gt;            # 删除标签</span><br><span class="line"></span><br><span class="line">$ git checkout dev                # 合并特定的commit到dev分支上</span><br><span class="line">$ git cherry-pick 62ecb3</span><br></pre></td></tr></table></figure><h2 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;              # 合并指定分支到当前分支</span><br><span class="line">$ git merge --abort               # 取消当前合并，重建合并前状态</span><br><span class="line">$ git merge dev -Xtheirs          # 以合并dev分支到当前分支，有冲突则以dev分支为准</span><br><span class="line">$ git rebase &lt;branch&gt;             # 衍合指定分支到当前分支</span><br></pre></td></tr></table></figure><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br><span class="line">$ git remote -v                   # 查看远程版本库信息</span><br><span class="line">$ git remote show &lt;remote&gt;        # 查看指定远程版本库信息</span><br><span class="line">$ git remote add &lt;remote&gt; &lt;url&gt;   # 添加远程版本库</span><br><span class="line">$ git remote remove &lt;remote&gt;      # 删除指定的远程版本库</span><br><span class="line">$ git fetch &lt;remote&gt;              # 从远程库获取代码</span><br><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;      # 下载代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;      # 上传代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; # 删除远程分支或标签</span><br><span class="line">$ git push --tags                 # 上传所有标签</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git archive --format=zip --output ../file.zip master    # 将master分支打包成file.zip文件，保存在上一级目录</span><br><span class="line">$ git archive --format=zip --output ../v1.2.zip v1.2      # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中</span><br><span class="line">$ git archive --format=zip v1.2 &gt; ../v1.2.zip             # 作用同上一条命令</span><br></pre></td></tr></table></figure><h2 id="远程与本地合并"><a href="#远程与本地合并" class="headerlink" title="远程与本地合并"></a>远程与本地合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git init                              # 初始化本地代码仓</span><br><span class="line">$ git add .                             # 添加本地代码</span><br><span class="line">$ git commit -m &quot;add local source&quot;      # 提交本地代码</span><br><span class="line">$ git pull origin master                # 下载远程代码</span><br><span class="line">$ git merge master                      # 合并master分支</span><br><span class="line">$ git push -u origin master             # 上传代码</span><br></pre></td></tr></table></figure><p>参考资料：<u><a href="https://www.cnblogs.com/ldj3/p/9172804.html" target="_blank" rel="noopener">https://www.cnblogs.com/ldj3/p/9172804.html</a></u><br><u><a href="https://www.zhihu.com/question/41667536/answer/486640083" target="_blank" rel="noopener">https://www.zhihu.com/question/41667536/answer/486640083</a></u></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h1
      
    
    </summary>
    
      <category term="Git" scheme="http://sunyunzeng.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://sunyunzeng.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://sunyunzeng.com/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://sunyunzeng.com/TCP-IP协议/</id>
    <published>2019-09-10T00:41:44.000Z</published>
    <updated>2019-09-11T15:51:36.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><h2 id="HTTP的来历"><a href="#HTTP的来历" class="headerlink" title="HTTP的来历"></a>HTTP的来历</h2><p>CERN(欧洲核子研究组织)的蒂姆 • 伯纳斯 - 李(Tim BernersLee)博士提出了一种能让远隔两地的研究者们共享知识的设想。</p><p>最初的设想是通过超文本(HyperText)标记,各地互联连接成可相互参阅的<font color="#f07c82">WWW(World Wide Web, 万维网)</font>。</p><p>目前WWW构建的关键技术为：</p><ul><li><p>基于SGML(Standard Generalized Markup Language,标准通用标记语言)的<font color="#f07c82">HTML （HyperText Markup Language, 超文本标记语言）</font>。</p></li><li><p>指定文档所在的地址<font color="#f07c82">URL (Uniform Resource Locator, 统一资源定位符) </font>。</p></li></ul><p>各个Web服务器通过万维网互相连接，以 HTML 标准编辑网页（存储信息），用 URL 实现信息的查找，最后通过Web浏览器实现界面的渲染。</p><h2 id="如何控制信息的传输？"><a href="#如何控制信息的传输？" class="headerlink" title="如何控制信息的传输？"></a>如何控制信息的传输？</h2><p>然而，Web服务器有各种各样的类型及硬件接口，显示平台也有各种各样的类型，如何实现平台之间信息的互相交流呢？ —— <font color="#f07c82">统一协议控制</font>。答案是通过统一的<font color="#f07c82">协议 (Protocol)</font>。</p><p>#　TCP/TP 协议簇</p><p>TCP/IP　有说法是专指TCP和IP协议。</p><p>这里指<font color="#f07c82">互联网相关的各类协议簇的总称</font>，例如：IP, PPPoE, TCP, FTP, HTTP, FDDI, IEEE 802.3, SNMP, UDP, DNS, ICMP　等等。</p><p>也就是说　HTTP　是　TCP/IP　协议的子集。</p><h2 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h2><p>在逻辑上，TCP/IP分为四个层次：<font color="#f07c82">应用层、传输层、网络层和数据链路层</font>。</p><table><thead><tr><th align="center">名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">客户端实现信息的封装与解析。该层使用的协议如 HTTP、DNS (Domain Name System, 域名系统)、FTP (File Transfer Protocol, 文件传输协议)等。</td></tr><tr><td align="center">传输层</td><td align="center">提供网络连接中两台计算机之间的数据传输。使用的协议：TCP (Transmission Control Protocol) 和 UDP (User Data Protocol, 用户数据协议)。</td></tr><tr><td align="center">网络层</td><td align="center">将网络中流动的数据包（网络传输最小数据单位）通过规定的路径（传输线路）到达对方的计算机，并把数据传给对方。</td></tr><tr><td align="center">数据链路层</td><td align="center">肉眼可见的硬件层，包括网卡、光纤等。</td></tr></tbody></table><img src="/TCP-IP协议/tcp.png"><h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><ol><li><p>用户根据HTTP协议发送一个数据请求（应用层）。</p></li><li><p>获得应用层数据后，传输层（TCP协议）为了方便，将数据（HTTP请求报文）进行分割，每个报文打上标记序号及端口号，然后转发给网络层。</p></li><li><p>网络层将通信目的地的DNS增加到数据中，然后转发给数据链路层。</p></li><li><p>数据链路层将数据发给目的地终端。</p></li></ol><img src="/TCP-IP协议/transform.png"><p>在解析数据时，按照数据包装的逆序层层解包（<strong>去除每一层打上的首部信息</strong>），最终获得请求的HTTP报头。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h1&gt;&lt;h2 id=&quot;HTT
      
    
    </summary>
    
      <category term="HTTP" scheme="http://sunyunzeng.com/categories/HTTP/"/>
    
    
      <category term="TCP/IP" scheme="http://sunyunzeng.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 岛屿最大的面积</title>
    <link href="http://sunyunzeng.com/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/"/>
    <id>http://sunyunzeng.com/Leetcode-岛屿最大的面积/</id>
    <published>2019-09-07T01:46:27.000Z</published>
    <updated>2019-09-07T14:31:25.977Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p><strong>示例1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p><p><strong>示例2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>对于上面这个给定的矩阵, 返回 0。</p><p><strong>注意:</strong> 给定的矩阵grid 的长度和宽度都不超过 50。</p><h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>一开始想的是动态规划，但是该题没有规律的求解方法，即岛屿的形状无法用统一的方法计算。</p><p>此题采用 <font color="#f07c82">DFS（深度优先遍历）</font>的方法求解。</p><p>DFS一般解体模板（<u><a href="https://blog.csdn.net/weixin_43272781/article/details/82959089" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43272781/article/details/82959089</a></u>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        判断边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(step+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题的解法：</p><ul><li><p>边界条件是二维矩阵的边界。</p></li><li><p>尝试每一种可能是上、下、左、右四个方向进行遍历。</p></li><li><p>check是是否为陆地（数值是否为1）。</p></li><li><p>标记是将遍历过的陆地变成海洋（置为1）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span> || col==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    res = Math.max(res, dfs(grid, i, j));   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>, x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dir = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//避免再次被选到</span></span><br><span class="line">        g[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">4</span>;s++)&#123;</span><br><span class="line">            x = i + dir[s][<span class="number">0</span>];</span><br><span class="line">            y = j + dir[s][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;row &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;col &amp;&amp; g[x][y]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum += dfs(g, x ,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目链接：<u><a href="https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/</a></u></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个包含了一
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="DFS Algorithm" scheme="http://sunyunzeng.com/tags/DFS-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Markdown文件中添加UML图</title>
    <link href="http://sunyunzeng.com/Markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0UML%E5%9B%BE/"/>
    <id>http://sunyunzeng.com/Markdown文件中添加UML图/</id>
    <published>2019-09-04T02:23:38.000Z</published>
    <updated>2019-09-05T15:09:41.390Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="UML图简介"><a href="#UML图简介" class="headerlink" title="UML图简介"></a>UML图简介</h1><p>UML(Unified Modeling Language)是统一建模语言的简写。</p><p>它可分为<font color="#f07c82">用例视图、设计视图、进程视图、实现视图和拓扑视图</font>，又可以静动分为静态视图和动态视图。静态图分为：<font color="#f07c82">用例图，类图，对象图，包图，构件图，部署图</font>。动态图分为：<font color="#f07c82">状态图，活动图，协作图，序列图</font>。</p><p>其中<font color="#f07c82"><strong>类图</strong></font> (Class Diagrams)是用来表示类的内部结构和类与类之间的关系的一种UML。常见的关系有：泛化 (Generalization)，实现 (Realization)，组合 (Composition)，聚合 (Aggregation)，关联 (Association)，依赖 (Dependency)。</p><p>各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><p><u><a href="https://www.cnblogs.com/jiangds/p/6596595.html" target="_blank" rel="noopener">参考教程</a></u></p><h1 id="UML类图的绘制及插入"><a href="#UML类图的绘制及插入" class="headerlink" title="UML类图的绘制及插入"></a>UML类图的绘制及插入</h1><p>我们利用在线的开源工具<u><a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="noopener">plantUML</a></u>实现UML图绘制。</p><p>具体的绘制方法可以参考官网<u><a href="http://plantuml.com/zh/" target="_blank" rel="noopener">plantUML</a></u>。</p><p>然后将网址中生成的UML图片地址插入到<strong>Markdown</strong>文件中。</p><img src="/Markdown文件中添加UML图/uml.png"><p><u><a href="https://www.heqiangfly.com/2017/07/08development-tool-markdown-plant-uml/" target="_blank" rel="noopener">参考教程</a></u></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;UML图简介&quot;&gt;&lt;a href=&quot;#UML图简介&quot; class=&quot;headerlink&quot; title=&quot;UML图简介&quot;&gt;&lt;/a&gt;UML图简介
      
    
    </summary>
    
      <category term="教程" scheme="http://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="网页" scheme="http://sunyunzeng.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 字符串的排列 (String 练习 03)</title>
    <link href="http://sunyunzeng.com/Leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97-String-%E7%BB%83%E4%B9%A0-03/"/>
    <id>http://sunyunzeng.com/Leetcode-字符串的排列-String-练习-03/</id>
    <published>2019-09-01T04:30:02.000Z</published>
    <updated>2019-09-01T15:31:39.845Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p><strong>示例1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = <span class="string">"ab"</span> s2 = <span class="string">"eidbaooo"</span></span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (<span class="string">"ba"</span>).</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1= <span class="string">"ab"</span> s2 = <span class="string">"eidboaoo"</span></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 输入的字符串只包含小写字母</span><br><span class="line"><span class="number">2</span>. 两个字符串的长度都在 [<span class="number">1</span>, <span class="number">10</span>,<span class="number">000</span>] 之间</span><br></pre></td></tr></table></figure><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h1><p>暴力法，滑动窗口依次判定。</p><p>但是<strong>超出时间限制！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len1&lt;=len2; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkSubString(s1, s2.substring(i, i+len1)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSubString</span><span class="params">(String subS1, String subS2)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(subS2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;subS1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.indexOf(subS1.charAt(i))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                s = s.replaceFirst(String.valueOf(subS1.charAt(i)), <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.isEmpty()?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O((len2-len1) * len1 * len2 * len2)</p><p>空间复杂度：O(1)</p><h1 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h1><p>也是滑动窗口法，不过不用内置的函数（使用过程中存在循环遍历），而利用数组存储各个字母出现的次数，进行子串是否匹配的判定依据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++)</span><br><span class="line">            temp1[s1.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len1&lt;=len2; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s1.length(); j++)&#123;</span><br><span class="line">                temp2[s2.charAt(i+j)-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(match(temp1, temp2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span>[] tmp1, <span class="keyword">int</span>[] tmp2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1[i]!=tmp2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(len1 + (len2-len1) * len1 * 26)</p><p>空间复杂度: O(1)</p><h1 id="思路-3"><a href="#思路-3" class="headerlink" title="思路 3"></a>思路 3</h1><p>基于思路2，继续进行优化。其实在滑动窗口中，每次只更新哈希表（数组）的第一个值及最后一个值，中间的不需要遍历。因此时间复杂度降低 len1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++)&#123;</span><br><span class="line">            temp1[s1.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">            temp2[s2.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(match(temp1, temp2))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len1&lt;len2; i++)&#123;</span><br><span class="line">            temp2[s2.charAt(i+len1)-<span class="string">'a'</span>]++;</span><br><span class="line">            temp2[s2.charAt(i)-<span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(match(temp1, temp2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span>[] tmp1, <span class="keyword">int</span>[] tmp2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1[i]!=tmp2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(len1 + (len2-len1) * 26)</p><p>空间复杂度: O(1)</p><p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 09 2019 10:38:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定两个字符串 
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://sunyunzeng.com/categories/Algorithm/"/>
    
    
      <category term="Other Algorithm" scheme="http://sunyunzeng.com/tags/Other-Algorithm/"/>
    
  </entry>
  
</feed>
