{"meta":{"title":"孙云增的博客","subtitle":null,"description":null,"author":null,"url":"http://sunyunzeng.com","root":"/"},"pages":[{"title":"关于","date":"2019-05-31","updated":"2019-05-31","comments":false,"path":"about/index.html","permalink":"http://sunyunzeng.com/about/index.html","excerpt":"","text":"年龄: 保密…身高: 保密…体重: 保密…状态: 武汉读研ing…兴趣: 篮球; 读书; Coding …座右铭: 生活极致简单，内涵极致丰富 …"},{"title":"书单","date":"2019-05-31","updated":"2019-05-31","comments":true,"path":"books/index.html","permalink":"http://sunyunzeng.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-01","updated":"2019-05-01","comments":false,"path":"categories/index.html","permalink":"http://sunyunzeng.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-05-01","updated":"2019-05-01","comments":true,"path":"links/index.html","permalink":"http://sunyunzeng.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-05-01","updated":"2019-05-01","comments":false,"path":"repository/index.html","permalink":"http://sunyunzeng.com/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-05-29","updated":"2019-05-29","comments":false,"path":"/404.html","permalink":"http://sunyunzeng.com//404.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-01","updated":"2019-05-01","comments":false,"path":"tags/index.html","permalink":"http://sunyunzeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode 105.从前序与中序遍历序列构造二叉树","slug":"Leetcode-105-从前序与中序遍历序列构造二叉树","date":"2019-07-01","updated":"2019-07-01","comments":true,"path":"Leetcode-105-从前序与中序遍历序列构造二叉树/","link":"","permalink":"http://sunyunzeng.com/Leetcode-105-从前序与中序遍历序列构造二叉树/","excerpt":"","text":"题目根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：123453 / \\ 9 20 / \\ 15 7思路先序遍历：先根节点 后左子树 最后右子树中序遍历：先左子树 再根节点 最后右子树所以先序遍历的第一个数值为根节点，在中序遍历中找到根节点位置，前面为左子树的中序遍历，后面为右子树的中序遍历。java代码太冗长了，不能很好地反映，所以采用更简洁的Python代码1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): \"\"\" :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode \"\"\" if not preorder: return None x = preorder.pop(0) node = TreeNode(x) idx = inorder.index(x) node.left = self.buildTree(preorder[:idx], inorder[:idx]) node.right = self.buildTree(preorder[idx:], inorder[idx+1:]) return node","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 101.对称二叉树","slug":"Leecode-101-对称二叉树","date":"2019-06-25","updated":"2019-07-01","comments":true,"path":"Leecode-101-对称二叉树/","link":"","permalink":"http://sunyunzeng.com/Leecode-101-对称二叉树/","excerpt":"","text":"题目给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3说明:如果你可以运用递归和迭代两种方法解决这个问题，会很加分。思路二叉树的一个典型套路就是递归求解。左右树分别对待。注意递归截止条件以及是否对称的判断条件。代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; return tryTree(root.left, root.right); &#125; public boolean tryTree(TreeNode left, TreeNode right)&#123; // 递归截止条件 if(right==null&amp;&amp;left==null) return true; if(left==null||right==null) return false; // 对称判断条件 if(left.val==right.val) return tryTree(left.left, right.right)&amp;&amp;tryTree(left.right, right.left); return false; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 48.旋转图像","slug":"Leecode-48-旋转图像","date":"2019-06-24","updated":"2019-07-01","comments":true,"path":"Leecode-48-旋转图像/","link":"","permalink":"http://sunyunzeng.com/Leecode-48-旋转图像/","excerpt":"","text":"题目给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。示例1：12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]]示例2：123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]]思路如果可以拷贝矩阵，则可以每一行与每一列同时旋转。但是要求在原矩阵中操作，所以需要每一个元素进行位置旋转变换。一个4*4的矩阵如下图所示：顺时针旋转即相同颜色的元素进行依次替换。对于四阶矩阵，先从最外圈i=0开始，到里圈i=1结束。n+1阶矩阵从最外圈i=0开始，i=n/2里圈结束。每j圈依次从j行第i个元素开始，n-i个元素结束。四个元素互换条件：tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; 代码123456789101112131415161718class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length-1; int tmp; // 循环几圈 for(int i=0; i&lt;=n/2;i++)&#123; // 每一圈要交换几轮 for(int j=i;j&lt;n-i;j++)&#123; // 四个元素依次交换 tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; &#125; &#125; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 155.最小栈","slug":"Leecode-155-最小栈","date":"2019-06-22","updated":"2019-07-01","comments":true,"path":"Leecode-155-最小栈/","link":"","permalink":"http://sunyunzeng.com/Leecode-155-最小栈/","excerpt":"","text":"题目设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2.思路1可以用两个栈，一个栈用来维护当前栈内最小的元素，一个栈用来维度当前栈内的元素。属于投机取巧的方法。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.isEmpty() || x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; public void pop() &#123; // 注意，peek()方法返回的是Integer对象，而java在比较Integer时数据范围在-128~127用 == 比较是相等的，但是 // 超过这个范围就是不相等的。这是因为常量池范围内地Integer对象都是同一个，而 == 是比较对象是否为同一个对象 // 如果比较数值是否相等，应该采用Integer重写的equals()方法!!! if(stack.peek().equals(minStack.peek()))&#123; minStack.pop(); &#125; stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */思路2自己用数组实现元素栈与存储最小元素的栈。要点，数组的自动扩容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MinStack &#123; private int[] minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = new int[10]; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) resize(); data[index] = x; if(index==0 || x &lt;minValue[index-1])&#123; minValue[index]=x; &#125;else&#123; minValue[index] = minValue[index-1]; &#125; &#125; public void pop() &#123; index--; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue[index]; &#125; public void resize()&#123; int[] newdata = new int[data.length*2]; int[] newMinValue = new int[data.length*2]; System.arraycopy(data,0,newdata,0,data.length); System.arraycopy(minValue,0,newMinValue,0,minValue.length); data = newdata; minValue = newMinValue; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */或者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MinStack &#123; private int minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = Integer.MAX_VALUE; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) data = Arrays.copyOf(data, data.length*2); data[index] = x; if(x &lt; minValue)&#123; minValue = x; &#125; &#125; public void pop() &#123; index--; if(data[index+1]==minValue)&#123; minValue = Integer.MAX_VALUE; for(int i=0; i&lt;=index; i++)&#123; if(data[i]&lt;minValue)&#123; minValue = data[i]; &#125; &#125; &#125; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue; &#125; &#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 448.找到所有数组中消失的数字","slug":"Leecode-448-找到所有数组中消失的数字","date":"2019-06-20","updated":"2019-07-01","comments":true,"path":"Leecode-448-找到所有数组中消失的数字/","link":"","permalink":"http://sunyunzeng.com/Leecode-448-找到所有数组中消失的数字/","excerpt":"","text":"题目给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。示例：12345输入:[4,3,2,7,8,2,3,1]输出:[5,6]思路将出现数字位置的数置为负数。关键点：置负数时一定取绝对值后取负数，否则会出现负负得正的情况。例如：1[2,1,2,4]1[-2,-1,2,-1]代码123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]); &#125; for(int i=0;i&lt;len;i++)&#123; if(nums[i]&gt;0)&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 234.回文链表","slug":"Leecode-234-回文链表","date":"2019-06-20","updated":"2019-07-01","comments":true,"path":"Leecode-234-回文链表/","link":"","permalink":"http://sunyunzeng.com/Leecode-234-回文链表/","excerpt":"","text":"题目请判断一个链表是否为回文链表。示例1：12输入: 1-&gt;2输出: false示例2：12输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？思路用 栈+快慢指针 或者 快慢指针+反转链表快慢指针是用来寻找中间节点。栈是用来反转链表。代码栈 + 快慢指针1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; // 栈用来反转链表 Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); ListNode fast = head; ListNode low = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; stack.push(low); low = low.next; // 奇数链表中间位置需要往后移动一位 if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; // 循环遍历前后链表是否相等 while(!stack.empty())&#123; if(stack.pop().val!=low.val) return false; low = low.next; &#125; return true; &#125;&#125;快慢指针 + 反转链表12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; ListNode fast = head; ListNode low = head; // 快慢指针找到中间点 while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; low = low.next; if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; ListNode compNode = reverseLinkedList(low); // 链表前后判断 while(compNode!=null)&#123; if(compNode.val!=head.val) return false; compNode = compNode.next; head = head.next; &#125; return true; &#125; // 反转链表 public ListNode reverseLinkedList(ListNode head)&#123; ListNode preNode = null; ListNode curNode = head; while(curNode!=null)&#123; ListNode temp = curNode.next; curNode.next = preNode; preNode = curNode; curNode = temp; &#125; return preNode; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 70.爬楼梯","slug":"Leecode-70-爬楼梯","date":"2019-06-19","updated":"2019-07-01","comments":true,"path":"Leecode-70-爬楼梯/","link":"","permalink":"http://sunyunzeng.com/Leecode-70-爬楼梯/","excerpt":"","text":"题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。示例1:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶示例2:123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶思路递归或者动态规划。第n阶楼梯的走法 = 第n-1阶楼梯走法 + 第n阶楼梯走法。边界条件，n&lt;=3。代码1234567891011121314// 动态规划class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; int[] dp = new int[n]; for(int i=0;i&lt;3;i++)&#123; dp[i] = i+1; &#125; for(int i=3; i&lt;n; i++)&#123; dp[i]=dp[i-2]+dp[i-1]; &#125; return dp[n-1]; &#125;&#125;1234567// 递归class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; return climbStairs(n-2) + climbStairs(n-1); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 198.打家劫舍","slug":"Leecode-198-打家劫舍","date":"2019-06-17","updated":"2019-07-01","comments":true,"path":"Leecode-198-打家劫舍/","link":"","permalink":"http://sunyunzeng.com/Leecode-198-打家劫舍/","excerpt":"","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例1：1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例2：1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。思路动态规划用一个数组维护截止到当前偷窃的最大值。更新条件：dp[i]=max(nums[i]+dp[i-1], dp[i-1])。代码123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if(len == 0) return 0; if(len == 1 ) return nums[0]; if(len == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i=2; i&lt;len; i++)&#123; dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); &#125; return dp[len-1]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 53.最大子序和","slug":"Leecode-53-最大子序和","date":"2019-06-17","updated":"2019-07-01","comments":true,"path":"Leecode-53-最大子序和/","link":"","permalink":"http://sunyunzeng.com/Leecode-53-最大子序和/","excerpt":"","text":"题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例：123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。思路动态规划。用一个数组维护一个包含当前数字的最大子序列，取该数组的最大值即为结果。代码12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; int len = nums.length; int result = nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; for(int i=1; i&lt;len; i++)&#123; dp[i] = Math.max(dp[i-1]+nums[i], nums[i]); result = Math.max(dp[i], result); &#125; return result; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 538.二叉搜索树转换为累加树","slug":"Leecode-538-二叉搜索树转换为累加树","date":"2019-06-17","updated":"2019-07-01","comments":true,"path":"Leecode-538-二叉搜索树转换为累加树/","link":"","permalink":"http://sunyunzeng.com/Leecode-538-二叉搜索树转换为累加树/","excerpt":"","text":"题目给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。二叉搜索树：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。思路因为二叉搜索树左子树、根节点及右子树已经拍好顺序，所以只需遍历右子树计算累加值，然后对根节点与左子树分别累加。可采用递归或遍历方法。首先累加右子树数值，然后依次修改根节点与左子树的数值。代码1 递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; if(root == null) return null; convertBST(root.right); root.val +=sum; sum = root.val; convertBST(root.left); return root; &#125;&#125;代码2 遍历123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; rightNodeStack = new Stack&lt;TreeNode&gt;(); TreeNode node = root; while(node!=null || !rightNodeStack.isEmpty())&#123; while(node!=null)&#123; rightNodeStack.add(node); node = node.right; &#125; node = rightNodeStack.pop(); node.val += sum; sum = node.val; node = node.left; &#125; return root; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"算法题-移动零","slug":"算法题-移动零","date":"2019-06-14","updated":"2019-06-26","comments":true,"path":"算法题-移动零/","link":"","permalink":"http://sunyunzeng.com/算法题-移动零/","excerpt":"","text":"题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:1. 必须在原数组上操作，不能拷贝额外的数组。 2. 尽量减少操作次数。 思路1采用双循环，当遇到零元素时，与后面序列中第一个非零元素交换。时间复杂度: $O(n!)$结果:执行用时 : 16 ms内存消耗 :37.4 MB代码12345678910111213141516class Solution &#123; public void moveZeroes(int[] nums) &#123; int len = nums.length; for(int i=0;i&lt;len-1;i++)&#123; if(nums[i]==0)&#123; int j =i+1; while(j&lt;len&amp;&amp;nums[j]==0)&#123; j++; &#125; if(j==len) break; nums[i]=nums[j]; nums[j]=0; &#125; &#125; &#125;&#125;思路2评论中高赞方法是采用双指针的方式。先将非零元素按照顺序紧密移动到前面，再按照零元素数量对数组后面元素补零。代码2123456789101112131415class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int len = nums.length; for(int j=0; j&lt;len; j++)&#123; if(nums[j]!=0)&#123; nums[i]=nums[j]; i++; &#125; &#125; for(; i&lt;len; i++)&#123; nums[i] = 0; &#125; &#125;&#125;结果执行用时 : 1 ms内存消耗 :39.3 MB题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题-合并两个有序链表","slug":"算法题-合并两个有序链表","date":"2019-06-13","updated":"2019-06-26","comments":true,"path":"算法题-合并两个有序链表/","link":"","permalink":"http://sunyunzeng.com/算法题-合并两个有序链表/","excerpt":"","text":"题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例1：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4思路1分为两步：第一步： 记录所有的链表的数值并排序。因为链表的长度未知，所以需要用 List 来存储。第二步： 按照排序后的链表数值，建立对应链表。代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null&amp;&amp;l2==null) return null; if(l1!=null&amp;&amp;l2==null) return l1; if(l1==null&amp;&amp;l2!=null) return l2; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(l1!=null)&#123; list.add(l1.val); l1=l1.next; &#125; while(l2!=null)&#123; list.add(l2.val); l2=l2.next; &#125; Collections.sort(list); int size = list.size(); ListNode result = new ListNode(list.get(0).intValue()); ListNode pev = result; for(int i=1;i&lt;size;i++)&#123; ListNode tmp = new ListNode(list.get(i).intValue()); pev.next = tmp; pev = tmp; &#125; return result; &#125;&#125;思路2官方题解：采用递归方法。终止条件：l1 = null 或者 l2 = null。判断条件：if(l1.val&lt;l2.val): mergeTwoLists(l1.next, l2)else: mergeTwoLists(l1, l2.next)代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125;思路3官方题解：采用递归。时间复杂度与空间复杂度最优。关键在于设计哨兵节点，记录前一个节点。代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; preNode.next = l1; l1 = l1.next; &#125;else&#123; preNode.next = l2; l2 = l2.next; &#125; preNode = preNode.next; &#125; preNode.next = l1==null?l2:l1; return preHead.next; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题：计算众数","slug":"算法题-计算众数","date":"2019-06-05","updated":"2019-06-26","comments":true,"path":"算法题-计算众数/","link":"","permalink":"http://sunyunzeng.com/算法题-计算众数/","excerpt":"","text":"题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。示例1：12输入: [3,2,3]输出: 3示例2：12输入: [2,2,1,1,1,2,2]输出: 2思路 + 代码法1. 我的方法，超笨。用一个Map记录数字出现的次数，然后当次数大于n/2时返回。代码12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; if(map.get(nums[i])!=null)&#123; Integer num = map.get(nums[i]); map.put(nums[i], num+1); &#125;else&#123; map.put(nums[i], 1); &#125; if(map.get(nums[i])&gt;len/2) return nums[i]; &#125; return 0; &#125;&#125;法2. 先排序，后取中位数代码略法3. 用一个变量count计数，从0开始，遇到相同的+1，遇到不同的-1，变为零则重新计数。代码12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int len = nums.length; int num = nums[0]; for(int i=1; i&lt;len; i++)&#123; if(num==nums[i]) count++; else count--; if(count==0) &#123; num = nums[i]; count = 1; &#125; &#125; return num; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题：反转链表","slug":"算法题-反转链表","date":"2019-06-03","updated":"2019-06-10","comments":true,"path":"算法题-反转链表/","link":"","permalink":"http://sunyunzeng.com/算法题-反转链表/","excerpt":"","text":"题目描述反转一个单链表。示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？思路方案1采用迭代方法，及循环迭代。用一个变量存储上一节点对象，一个变量存储当前节点对象，一个对象存储下一节点对象。代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while(curr!=null)&#123; ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125;&#125;方案2采用递归，先递归找到原链表尾巴作为头节点，再依次反转链表。head.next.next = head;head.next = null;代码1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Recursion","slug":"Recursion","permalink":"http://sunyunzeng.com/tags/Recursion/"}]},{"title":"算法题：子集","slug":"算法题-子集","date":"2019-05-31","updated":"2019-06-10","comments":true,"path":"算法题-子集/","link":"","permalink":"http://sunyunzeng.com/算法题-子集/","excerpt":"","text":"求一个数组的所有子集数组给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]思路从前往后遍历，新子集就是原子集加上新加的数。代码1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; List&lt;Integer&gt; inList = new ArrayList&lt;&gt;(); list.add(inList); for(int i=0; i&lt;len; i++)&#123; int size = list.size(); for(int j = 0; j&lt;size; j++)&#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list.get(j)); newList.add(nums[i]); list.add(newList); &#125; &#125; return list; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题：二叉树相关","slug":"算法题-二叉树相关","date":"2019-05-30","updated":"2019-06-10","comments":true,"path":"算法题-二叉树相关/","link":"","permalink":"http://sunyunzeng.com/算法题-二叉树相关/","excerpt":"","text":"合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:1234567891011121314输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7思路递归算法，每棵树都由子树构成，根节点融合可以通过递归拆分成子树进行。代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125;二叉树最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。示例:给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \\9 20 / \\ 15 7返回它的最大深度 3 。思路同上，树划分成两棵树，递归求解。代码12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125;题目链接翻转二叉树翻转一棵二叉树。示例：输入:12345 4 / \\ 2 7 / \\ / \\1 3 6 9输出:12345 4 / \\ 7 2 / \\ / \\9 6 3 1备注:这个问题是受到 Max Howell 的 原问题 启发的 ：谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。思路so easy! 递归完事了。代码12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; TreeNode obj = root.left; root.left = root.right; root.right = obj; invertTree(root.right); invertTree(root.left); return root; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"算法题：位运算相关","slug":"算法题-位运算相关","date":"2019-05-28","updated":"2019-06-26","comments":true,"path":"算法题-位运算相关/","link":"","permalink":"http://sunyunzeng.com/算法题-位运算相关/","excerpt":"","text":"只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例1:12输入: [2,2,1]输出: 1示例2:12输入: [4,1,2,1,2]输出: 4思路由于时间复杂度与空间复杂度的限制，这道题目解决办法一定是很巧妙的。答案是采用异或的方法。Java的异或^是位运算的一种，含义是相同的位数置 0 ，相异的位数置 1 。数字本身(相同数字)的异或结果为 0 ，0 与任何数字的异或结果为其本身。Hash Map中的hash码映射到数组位置就采用了异或的方法，(h=key.hashcode())^(h&gt;&gt;16);例如:0000 0000 0000 1011 ^0000 0000 0000 11110000 0000 0000 0100代码12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; int len = nums.length; for(int i=0; i&lt;len; i++)&#123; result = result^nums[i]; &#125; return result; &#125;&#125;汉明距离题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 231.示例：12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。思路先异或运算 ^ 将相同位置不同数字的置为 1 。再通过移位， 与 1 进行 与 &amp; 运算，计算出结果。代码1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x^y; int result = 0; // 计算二进制表示中 1 的数量 while(z&gt;0)&#123; if((z &amp; 1) == 1)&#123; result ++; &#125; z &gt;&gt;= 1; &#125; return result; &#125;&#125;计算m的n次方例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:m^1101 = m^0001 m^0100 m^1000。代码12345678910111213141516public class Pow &#123; public static int pow(int m, int n) &#123; int sum = 1; int tmp = m; while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; // 几个1乘几次 sum *= tmp; &#125; // 第二位乘两次，第三位乘四次... tmp *= tmp; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125;不用辅助变量交换两个数用异或运算 ^ ，相同的数异或为 0 ,且支持交换律与结合律。伪代码123x = x^y;y = x^y;x = x^y;比特位计数给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。示例1:12输入: 2输出: [0,1,1]示例2:12输入: 5输出: [0,1,1,2,1,2]进阶:给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。最容易想到方法12345678910111213141516class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=0; i&lt;=num; i++)&#123; int count = 0; int t = i; while(t &gt; 0)&#123; if((t &amp; 1) == 1) count++; t &gt;&gt;= 1; &#125; result[i] = count; &#125; return result; &#125;&#125;当前数字的比特位数量等于左移一位数字的比特位数量加上（当前数字&amp;1）123456789class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=1; i&lt;=num; i++)&#123; result[i] = result[i&gt;&gt;1] + (i &amp; 1); &#125; return result; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm-排序算法","slug":"Algorithm-排序算法","date":"2019-05-27","updated":"2019-06-10","comments":true,"path":"Algorithm-排序算法/","link":"","permalink":"http://sunyunzeng.com/Algorithm-排序算法/","excerpt":"","text":"插入排序每次遍历都将对应位置的数字插入到合适的位置，当前位置之前的数据保持排序。代码12345678910111213141516public class InsertionSort &#123; public static int[] sort(int[] arr)&#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr, 0, A, 0, len); int i,j; for (i = 1; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j - 1] &gt; temp; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; return A; &#125;&#125;冒泡排序每次将最大的(或最小的)沉入数组最底层。代码123456789101112131415161718public class BubbleSort &#123; public static int[] sort(int[] arr) &#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr,0, A, 0, len); for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-i; j++) &#123; if(A[j]&gt;A[j+1])&#123; // 无需中介的数值互换方法 A[j] += A[j+1]; A[j+1] = A[j] - A[j+1]; A[j] -= A[j+1]; &#125; &#125; &#125; return A; &#125;&#125;转自知乎(插入、冒泡图片来源，侵删)快速排序每次找出一个基准，作为划分标准。方法类似于二分法，每次都把小于基准的数放于基准数组的左边，把大于基准的数放于数组的右边。算法不稳定，时间复杂度最好$O(nlog(n))$，最差$O(n^2)$当数组本来是排序好的，例如是顺序排列，此时要计算逆序排列，如果利用快排方法，则时间复杂度为$O(n^2)$，当然，此时的基准选取是头部或者尾部。所以基准的选取很重要，常见得有随机选取、取首或末端的数及三数中值法（取首末及中间位置三个数的中值）。理论上，选取的基准是所有数的中位数，则划分最均匀，用时最短。选取末尾值作为基准1234567891011121314151617181920212223242526272829303132333435363738394041public class QuickSort &#123; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = A[right]; int i = left; int j = right; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right] = A[i]; A[i] = criterion; return i; &#125;&#125;优化的快速排序采用三值法作为划分基准，并在数据量不大时采用插入排序，提高效率。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class QuickSort &#123; private int threshold = 4; QuickSort()&#123;&#125;; QuickSort(int i) &#123; this.threshold = i; &#125; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 小数据情况下递归方法需要调用栈，效率较低，此时采用插入排序方法 if(right-left&gt;4)&#123; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125;else &#123; insertionSort(A); &#125; &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = getMedianPivot(A, left, right); // 从第二个及倒数第二个开始，因为getMedianPivot已经对首末数值进行了排序 int i = left+1; int j = right-1; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right-1] = A[i]; A[i] = criterion; return i; &#125; private int getMedianPivot(int[]A, int left, int right)&#123; int center = (left+right)/2; // 对于首末及中间的数进行排序 if (A[left] &gt; A[center]) &#123; swap(A, left, center); &#125; if (A[center] &gt; A[right]) &#123; swap(A, center, right); &#125; if (A[left] &lt; A[right]) &#123; swap(A, left, right); &#125; //交换中间与倒数第二个数，因为经过排序，最后一个已经是最大 swap(A, center, right-1); return A[right-1]; &#125; private void swap(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; private void insertionSort(int[] A) &#123; int len = A.length; int i,j; for (i = 0; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j] &lt; A[j - 1]; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; &#125;&#125;1.参考资料 2.参考资料十大排序算法讲解推荐(快排图片来源，侵删)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://sunyunzeng.com/tags/Sort/"}]},{"title":"Linux终端常用指令","slug":"Linux终端常用指令","date":"2019-05-27","updated":"2019-06-10","comments":true,"path":"Linux终端常用指令/","link":"","permalink":"http://sunyunzeng.com/Linux终端常用指令/","excerpt":"","text":"常用指令集指令作用pwd打印当前工作目录hostname获取我的计算机的网络名称mkdir创建目录cd更改目录ls列出目录下的文件rmdir删除目录pushdpush directorypopdpop directorycp复制文件或目录mv移动/重命名文件或目录less按页查看文件cat输出整个文件xargs执行参数find查找文件grep查找文件里面的东西man阅读帮助手册aproposfind what man page is appropriateenv查看计算机环境echo输出一些参数export设置一个新的环境变量exit退出终端sudo危险! 拥有超级用户权限!sudo rm –rf /*赶紧跑路吧！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://sunyunzeng.com/categories/Linux/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"算法题--买卖股票的最佳时机","slug":"算法题-买卖股票的最佳时机","date":"2019-05-26","updated":"2019-06-26","comments":true,"path":"算法题-买卖股票的最佳时机/","link":"","permalink":"http://sunyunzeng.com/算法题-买卖股票的最佳时机/","excerpt":"","text":"题目1给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例11234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例212345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例3123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路贪心算法，通过计算局部最优，综合多个局部最优结果得到全局最优结果一次循环，只要第二天股票价格比当天高，就买入，否则不买入。计算当天买入跟第二天卖出的利润和，即为结果。并不一定要在最低值买入，在最高点卖出。因为每次低买高卖的累积和等于最低点与最高点之间的收益。代码1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int result = 0; for(int i=0; i&lt;=prices.length-2; i++)&#123; if(prices[i]&lt;prices[i+1])&#123; result += prices[i+1]-prices[i]; &#125; &#125; return result; &#125;&#125;题目链接题目2给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。示例 1：12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.注意 :1230 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000.思路简单DP问题当前的状态 i 共有两种，持有股票与不持有股票持有股票状态可能是 前一状态买入 或者 当前买入:收益方程：$buy_{profit}^i=max(buy_{profit}^{i-1}, sell_{profit}^{i-1}-prices[i])$不持有股票可能是 前一状态卖出 或者 当前卖出:收益方程：$sell_{profit}^i=max(sell_{profit}^{i-1}, prices[i]+buy_{profit}^i-fee)$代码1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len&lt;2) return 0; //没有stock的收益 int sell_profit = 0; //拥有stock的收益 int buy_profit = -prices[0]; for(int i=1; i&lt;len; i++)&#123; //今天卖了或者之前卖了的收益 sell_profit = Math.max(sell_profit, prices[i]+buy_profit-fee); //今天买了或者之前买了的收益 buy_profit = Math.max(buy_profit, sell_profit-prices[i]); &#125; //卖了股票的收益肯定大于持有股票的收益，因为持有股票是负收益 return sell_profit; &#125;&#125;题目链接题目3给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。示例1：1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例2：123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路动态规划问题。维护一个值，存储之前i-1天的最大利润，当前i天的最大利润为当前价格与前i-1天价格最小值的差值与i-1最大利润的较大值。代码123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len&lt;2) return 0; int result = -prices[0]; int min_price = prices[0]; for(int i=1; i&lt;len; i++)&#123; result = Math.max(result, prices[i]-min_price); if(prices[i]&lt;min_price) min_price = prices[i]; &#125; return result&lt;0?0:result; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"},{"name":"Greedy Algorithm","slug":"Greedy-Algorithm","permalink":"http://sunyunzeng.com/tags/Greedy-Algorithm/"}]},{"title":"Minimum-Falling-Path-Sum","slug":"Minimum-Falling-Path-Sum","date":"2019-05-25","updated":"2019-05-29","comments":true,"path":"Minimum-Falling-Path-Sum/","link":"","permalink":"http://sunyunzeng.com/Minimum-Falling-Path-Sum/","excerpt":"","text":"下降路径最小和题目细节给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。示例112输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12解释：可能的下降路径有：123[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。提示121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100思路典型的二维动态数组题目。创建一个二维的数组A[row][column]存储结果，每一个位置存储的是第一行到该位置最小的下降路径。一般情况1A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]);前后两列情况12第一列: A[i][j] += min(A[i-1][j],A[i-1][j+1]);最后一列: A[i][j] += min(A[i-1][j-1],A[i-1][j]);Algorithm123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minFallingPathSum(int[][] A) &#123; int row = A.length; int col = A[0].length; if(row==1)&#123; return A[0][0]; &#125; for(int i=1;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; if(j-1&lt;0)&#123; A[i][j] += min(A[i-1][j],A[i-1][j+1]); &#125; else if(j+1&gt;col-1)&#123; A[i][j] += min(A[i-1][j-1],A[i-1][j]); &#125; else&#123; A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]); &#125; &#125; &#125; int result = Integer.MAX_VALUE; for(int i=0;i&lt;col;++i)&#123; if (A[row-1][i] &lt; result) &#123; result = A[row-1][i]; &#125; &#125; return result; &#125; public int min(int a, int b)&#123; return (a&lt;=b?a:b); &#125;&#125;题目链接类似题目","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Algorithm--Third Maximum Number","slug":"Algorithm-Third-Maximum-Number","date":"2019-05-23","updated":"2019-05-31","comments":true,"path":"Algorithm-Third-Maximum-Number/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Third-Maximum-Number/","excerpt":"","text":"1. Third Maximum NumberTitle DetailGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).Example 1:123Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:123Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:12Input: [2, 2, 3, 1]Output: 1Explanation:Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum.思路因为要求算法的时间复杂度为O(n)，所以不能用排序的方法。因为只求第三大的数，跟求第一大的数原理类似，只不过注意边界条件。Algorithm1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int thirdMax(int[] nums) &#123; if(nums.length==1) return nums[0]; if(nums.length==2) return Math.max(nums[0], nums[1]); int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; int max3 = Integer.MIN_VALUE; int flag = 0; boolean f = true; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;max1)&#123; max3=max2; max2=max1; max1=nums[i]; ++flag; continue; &#125; if(max1&gt;nums[i] &amp;&amp; nums[i]&gt;max2)&#123; max3=max2; max2=nums[i]; ++flag; continue; &#125; if(max2&gt;nums[i] &amp;&amp; nums[i]&gt;max3)&#123; max3=nums[i]; ++flag; continue; &#125; // 边界条件，如果有多个最小值，则只算一次 if(nums[i]==Integer.MIN_VALUE&amp;&amp;f)&#123; flag++; f = false; continue; &#125; &#125; return (flag&lt;3?max1:max3); &#125;&#125;题目链接2. Smallest Range ITitle DetailGiven an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i].After this process, we have some array B.Return the smallest possible difference between the maximum value of B and the minimum value of B.Example 1:123Input: A = [1], K = 0Output: 0Explanation: B = [1]Example 2:123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8]Example 3:123Input: A = [1,3,6], K = 3Output: 0Explanation: B = [3,3,3] or B = [4,4,4]Note:1231 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 100000 &lt;= K &lt;= 10000思路求出数组最大值与最小值的差值，比较差值与K/2的关系。Algorithm1234567891011121314151617class Solution &#123; public int smallestRangeI(int[] A, int K) &#123; if(A.length==0) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(int i=0; i&lt;A.length; i++)&#123; if(A[i]&lt;min) min = A[i]; if(A[i]&gt;=max) max = A[i]; &#125; int len = max-min; if(len&gt;2*K) return len-2*K; else return 0; &#125;&#125;题目链接3. 数组形式的整数加法题目细节对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。示例1：123输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234示例2：123输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455示例3：123输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021示例4：123输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000提示：12341 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 90 &lt;= K &lt;= 10000如果 A.length &gt; 1，那么 A[0] != 0思路最初思路是字符串转数字，相加后转字符串。但是最终没过，因为数据量太大，不允许。后又通过进位方式实现，老太太的裹脚布。Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int len = A.length; for(int i=len-1; i&gt;=0; --i) &#123; int temp = A[i] + K; if (temp &gt;= 10) &#123; A[i] = temp % 10; K = temp / 10; &#125; else &#123; A[i] = temp; K = temp /10; break; &#125; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (K!=0)&#123; String s = String.valueOf(K); for(char c: s.toCharArray()) result.add(c-'0'); &#125; for (int i : A) &#123; result.add(i); &#125; return result; &#125;&#125;官方答案123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int N = A.length; int cur = K; List&lt;Integer&gt; ans = new ArrayList(); int i = N; while (--i &gt;= 0 || cur &gt; 0) &#123; if (i &gt;= 0) cur += A[i]; ans.add(cur % 10); cur /= 10; &#125; Collections.reverse(ans); return ans; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Java ArrayList Handbook","slug":"Java-ArrayList-API","date":"2019-05-21","updated":"2019-05-31","comments":true,"path":"Java-ArrayList-API/","link":"","permalink":"http://sunyunzeng.com/Java-ArrayList-API/","excerpt":"","text":"Java List常用类型类型特征ArrayList随机访问元素快；中间插入与删除元素较慢；操作不是线程安全的LinkedList中间插入与删除操作代价较低，提供优化的顺序访问；随机访问元素慢ArrayList 常用 API方法描述boolean add(E object)再 ArrayList 尾存入对象void add(int location, E object)在 location 添加对象boolean addAll(Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入boolean addAll(int location, Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入locationboolean contains(Object object)是否包对象 objectboolean containsAll(Collection&lt;?&gt; collection)是否包含一个 Collection 对象boolean isEmpty()ArrayList 是否为空E get(int location)获取 location 的对象E set(int location, E object)将某个位置的元素替换成 objectint indexOf(Object object)获取某个对象的位置（顺序遍历第一个）int lastIndexOf(Object object)获取某个对象的位置（逆序遍历第一个）int size()返回 ArrayList 存储的对象数量boolean remove(Object object)删除存储的某个对象E remove(int lcoation)删除位于 location 的对象boolean removeAll(Collection&lt;?&gt; collection)删除存储的某个 Collection 对象Object [] toArray()ArrayList 转数组List&lt;’E’&gt; subList(int start, int end)获取位于 start 与 end 之间的 Listvoid clone()克隆ArrayListvoid clear()移除ArrayList中所有对象Iterator&lt;’E’&gt; iterator()获取该 ArrayList 对应的迭代器对象ArrayList 应用示例ArrayList与数组之间的转换1234567891011121314151617181920// 转数组List&lt;String&gt; list = new ArrayList&lt;&gt;();String[] strings = new String[list.size()];list.toArray(strings);// 或者String[] strings = (String[])list.toArray(new String[list.size()]);// 数组转List// 法1 快速，但是以视图形式返回，无法对数据进行删除及添加操作；// 可用 set() 方法修改元素，但是原始List数据会随之改变String[] s = &#123;\"abc\", \"def\", \"ghi\"&#125;;List&lt;String&gt; list = java.util.Arrays.asList(s);//法 2 慢，但是新生成一个ArrayList，可对List进行操作不会对原对象产生影响List&lt;String&gt; assertList = new ArrayList();Collections.addAll(assertList, strings);ArrayList遍历方式12345678910111213141516171819// 第一种，通过迭代器遍历。即通过Iterator去遍历。Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125;// 第二种，随机访问，通过索引值去遍历。Integer value = null;int size = list.size();for (int i=0; i &lt; size; i++) &#123; value = (Integer)list.get(i); &#125;// 第三种，for循环遍历。Integer value = null;for (Integer integer: list) &#123; value = integer;&#125;初始化12345678910111213141516171819202122232425// 第一种方式 Arrays.asList()方法ArrayList&lt;Integer&gt; list = new Arraylist&lt;&gt;(Arrays.asList(1, 2, 3));// 第二种方法 常规方式ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);//或者List innerList = Arrays.asList(1, 2, 3);list.addAll(innerList);// 第三种方法 使用生成匿名内部类ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123; &#123; add(1); add(2); add(3); &#125;&#125;；// 第四种方式 使用Collection.nCopiesint element = 1;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Collections.nCopies(2, element)); //复制伍分到list中。打印信息由于ArrayList内部实现了toString()方法，所以可以直接打印12ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));System.out.println(list);对于数组信息的打印123456789int[] A = &#123;1, 2, 3&#125;;// 方法一for(Integer i: A)&#123; System.out.println(i);&#125;//方法二System.out.println(Arrays.toString(A));","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Algorithm：删除最外层的括号","slug":"Algorithm-删除最外层的括号","date":"2019-05-21","updated":"2019-05-31","comments":true,"path":"Algorithm-删除最外层的括号/","link":"","permalink":"http://sunyunzeng.com/Algorithm-删除最外层的括号/","excerpt":"","text":"删除最外层括号题目有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。示例1输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。示例2输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。示例3输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。提示123S.length &lt;= 10000S[i] 为 \"(\" 或 \")\"S 是一个有效括号字符串思路用一个数组模拟栈，发现 “(“ 使其进栈，发现 “)” 时使 “(“ 出栈。注意: 栈底的 “(“ 出栈不输出，当输出字符串中 “(“ 和 “)” 数量不相等时，才输出 “)” 。代码12345678910111213141516171819202122232425262728class Solution &#123; public String removeOuterParentheses(String S) &#123; // list作为栈，记录(数量 List&lt;Character&gt; list = new ArrayList(); StringBuilder bf = new StringBuilder(); int left = 0; // 记录输出的 ( 数量 int right = 0; //记录输出的 ) 数量 for(int i=0; i&lt;S.length(); i++)&#123; char c = S.charAt(i); if(c=='(') list.add(c); if(c==')')&#123; if(list.size()==1&amp;&amp;left==right) list.remove(0); if(list.size()&gt;1)&#123; while(list.size()!=1)&#123; bf.append(\"(\"); list.remove(list.size()-1); ++left; &#125; &#125; if(left!=right)&#123; bf.append(\")\"); ++right; &#125; &#125; &#125; return bf.toString(); &#125;&#125;更Niubility的code：123456789101112131415161718class Solution &#123; public String removeOuterParentheses(String S) &#123; StringBuilder bf = new StringBuilder(); int flag = 0; for(char c: S.toCharArray())&#123; if(c == '(')&#123; ++flag; if(flag == 1) continue; &#125; if(c==')')&#123; --flag; if(flag == 0) continue; &#125; bf.append(c); &#125; return bf.toString(); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm--Minimum path sum","slug":"Algorithm-Minimum-path-sum","date":"2019-05-21","updated":"2019-05-29","comments":true,"path":"Algorithm-Minimum-path-sum/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Minimum-path-sum/","excerpt":"","text":"Dynamic ProgrammingMinimum Path SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6思路动态规划 问题。用原来的grid矩阵存储路径和注意三种特殊情况，即矩阵初始位置、顶栏及左侧栏和求解。初始：grid[0][0] = grid[0][0]顶栏：grid[i][j] = grid[i][j-1]左侧栏：grid[i][j] = grid[i-1][j]其余位置：grid[i][j] = min(grid[i][j-1], grid[i-1][j])Algorithm12345678910111213141516171819202122class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; for(int i=0; i&lt;m;i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0&amp;&amp;j==0)&#123; continue; &#125; else if(i==0&amp;&amp;j!=0)&#123; grid[i][j] += grid[i][j-1]; &#125; else if(j==0&amp;&amp;i!=0)&#123; grid[i][j] += grid[i-1][j]; &#125;else&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Algorithm--Partition-array-for-maximum-sum","slug":"Algorithm-partition-array-for-maximum-sum","date":"2019-05-21","updated":"2019-05-29","comments":true,"path":"Algorithm-partition-array-for-maximum-sum/","link":"","permalink":"http://sunyunzeng.com/Algorithm-partition-array-for-maximum-sum/","excerpt":"","text":"Dynamic ProgrammingPartition Array for Maximum SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6思路动态规划 问题。用一个长度为A.length的数组dp维护最终的加和结果。计算思想如下：dp[i] := max sum of A[0] ~ A[i]dp[i] = max{dp[i – k] + max(A[i+1-k:i]) * k}, 1 &lt;= k &lt;= min(i, K)最终返回结果dp[A.length-1]Algorithm1234567891011121314class Solution &#123; public int maxSumAfterPartitioning(int[] A, int K) &#123; int len = A.length; int[] dp = new int[len]; for(int i=0; i&lt;A.length; ++i)&#123; int max_num = A[i]; for(int k=1; k&lt;=K &amp;&amp; i+1-k&gt;=0; ++k)&#123; max_num = Math.max(max_num, A[i+1-k]); dp[i] = Math.max(dp[i], (i-k&gt;=0?dp[i-k]:0) + k*max_num); &#125; &#125; return dp[len-1]; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Java-for循环那些事","slug":"Java-for循环那些事","date":"2019-05-21","updated":"2019-05-29","comments":true,"path":"Java-for循环那些事/","link":"","permalink":"http://sunyunzeng.com/Java-for循环那些事/","excerpt":"","text":"Java for循环里面的 i++ 与 ++i在for循环里两者的作用是一样的i++12345for(int i=0; i&lt;5; i++)&#123; System.out.print(i + \",\");&#125;&gt;&gt; 0, 1, 2, 3, 4++i12345for(int i=0; i&lt;5; ++i)&#123; System.out.print(i + \",\");&#125;&gt;&gt; 0, 1, 2, 3, 4工作原理i++1234&#123; System.out.print(i + \",\"); i++;&#125;++i1234&#123; System.out.print(i + \",\"); ++i;&#125;区别在Java里面，i++ 需要开辟新的存储空间用于存储结果，++i 直接在原存储空间中存储结果。故 ++i 在 for 循环里面执行效率要高。 可以作为代码优化的一部分。foreach 与 for循环的效率首先测试数组123456789101112131415161718192021// 测试for循环int[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(int i=0; i&lt;len; i++)&#123; res += A[i];&#125;long endTime = System.nanoTime();System.out.println(\"for循环: \"+(endTime- startTime));// 测试foreachint[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(Integer i: A)&#123; res += i;&#125;long endTime = System.nanoTime();System.out.println(\"foreach循环: \"+(endTime- startTime));结果12for循环: 37143324forecah循环: 75450311可见对于大数组采用for循环效率更高再测试ArrayList12345678910111213141516171819202122ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000); for(int i=0; i&lt;30000000; i++)&#123; list.add(i); &#125;// 测试for循环long startTime = System.nanoTime();int size = list.size();int res = 0;for(int i=0; i&lt;size; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(\"for循环: \"+(endTime- startTime));// 测试foreachlong startTime = System.nanoTime();int res = 0;for(Integer i: list)&#123; res += i; &#125;long endTime = System.nanoTime();System.out.println(\"foreach循环: \"+(endTime- startTime));结果12for循环: 39368248forecah循环: 42177137可见对于ArrayList仍然是采用for循环效率更高！for循环小技巧关于数组循环嵌套采用小套大。原理跟复制几个大文件跟复制一堆小文件耗时一样。测试12345678910long startTime = System.nanoTime();int res = 0;// 大套小for(int i=0; i&lt;10000000; i++)&#123; for(int j=0; j&lt;100; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println(\"大套小: \"+(endTime- startTime));12345678// 小套大for(int i=0; i&lt;100; i++)&#123; for(int j=0; j&lt;10000000; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println(\"小套大: \"+(endTime- startTime));结果12大套小: 57934223小套大: 4918044数组复制时采用System.arraycopy()方法比for循环复制效率高。System.arraycopy()public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 关于ArrayList在循环时，首先把ArrayList长度size记录下来。测试1234567891011121314151617181920ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000);for(int i=0; i&lt;30000000; i++)&#123; list.add(i);&#125;long startTime = System.nanoTime();//先把长度保存下来int len = list.size();int res = 0;for(int i=0; i&lt;len; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(\"保存size(): \"+(endTime- startTime));//没有保存size()for(int i=0; i&lt;list.size(); i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(\"没有保存size(): \"+(endTime- startTime));结果12保存size(): 38973440没有保存size(): 39486862","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Java--Map API","slug":"Java-Map-API","date":"2019-05-19","updated":"2019-06-10","comments":true,"path":"Java-Map-API/","link":"","permalink":"http://sunyunzeng.com/Java-Map-API/","excerpt":"","text":"Java Map常用类型类型特征HashMap根据 HashCode 存储数据，访问速度快。至多允许一条记录键为 null;允许多条记录的值为 null；线程非同步TreeMap保存的记录按照键(key)排序，也可自定义排序规则。用生成的 Iterator 遍历 TreeMap 得到记录是排序后的。不允许记录的键为 null；线程非同步Hashtable用 HashMap 类似,不同的是键值都不允许为 null。 支持线程同步，但写入较慢LinkedHashMap保留记录的插入顺序，生成Iterator遍历顺序与插入顺序一致。遍历比HashMap慢，键值都允许为 null；线程非同步–&gt; HashMap剖析常用 API方法描述Object put(Object k, Object v)存入键值对Object get(Object k)返回键所映射的值；如果不存在该映射则返回 nullboolean containsKey(Object k)是否包含键 kboolean containsValue(Object v)是否包含值 vboolean isEmpty()Map 是否为空int size()返回 Map 的键值对数boolean remove(Object k)如果存在一个键映射关系，则删除此关系(映射关系不存在不会报错)void clear()移除Map中所有映射关系boolean equals(Object obj)比较指定对象于此 Map 是否相等void putAll(Map m)将指定 Map 的映射关系复制到此 Map 中Collection values()以 Collection 形式返回 Map 包含的值Set keySet()以 Set 形式返回 Map 包含的键Set entrySet()以 Set 形式返回 Map 的映射关系List 应用示例123456789Map&lt;Integer, Character&gt; map = new HashMap&lt;&gt;();map.put(1, 'c');map.get(1);for(int i: map.keySet())&#123; System.out.println(map.get(i)); &#125;if(map.containsKey(1))&#123; map.remove(1);&#125;常用遍历方法1. 只获取键或值123456789// 获取键for(Integer key: map.keyset())&#123; System.out.println(key);&#125;// 获取值for(Integer value: map.value())&#123; System.out.println(value);&#125;2. 同时获取键和值1234567891011// 2.1 先取key再取value。不推荐for(Integer key:map.keySet())&#123; System.out.println(map.get(key));&#125;// 2.2 通过map entrySet遍历。性能优于上一种。for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; System.out.println(entry.getKey() + \":\" + entry.getValue());&#125;3. Iterator上面的foreach都可以用Interator代替。foreach是对Set遍历,大小不能改变。如果改变map的大小，会报错。如果想要删除元素，还是要用Interator的方式删除。123456Interator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.enteySet().iterator();while(it.hasNext())&#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + \":\" + entry.getValue()); // it.remove() 删除元素&#125;4. Lambda代码简洁，但是性能低于entrySet。123map.forEach((key, value)-&gt;&#123; System.out.println(key + \":\" + value);&#125;)5. 性能测试用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap12345static&#123; for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125;&#125;测试结果如下：KeySet： 392Values： 320keySet get(key)： 552entrySet： 465entrySet Iterator：508Lambda： 536Map的遍历方法参考(侵删)","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Algorithm--Coin Change","slug":"Algorithm-Coin-Change","date":"2019-05-19","updated":"2019-05-29","comments":true,"path":"Algorithm-Coin-Change/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Coin-Change/","excerpt":"","text":"Dynamic ProgrammingCoin ChangeTitle DetailYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.Example 1:123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 1:12Input: coins = [2], amount = 3Output: -1Note:You may assume that you have an infinite number of each kind of coin.思路动态规划 问题。用一个 amount+1长度的数组 bp 维护不同面值金额需要最小的硬币数。bp[0]=0bp[1~amount]=amount+1位置0表示面值为零，最小需要0个硬币，初始为0.位置0~amount假设需要amount个硬币，因硬币类型为int，即代表无解。对于硬币类型coins[i]，寻找j=coins[i] ~j=amount对应面值金额的最小硬币数，即为min(dp[j], dp[j-coins[i]]+1)。dp[j-coins[i]]+1代表放入一个该类型硬币。前提： dp[j-coins[i]]面值的金额不是无解，因为如果无解，那么dp[j-coins[i]]+1对于当前面值金额也是无解。返回dp数组第amount位置数字，即为所求。Algorithm12345678910111213141516171819class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(coins.length==0) return -1; // 创建维护结果的数组 int[] dp=new int[amount+1]; Arrays.fill(dp,1,dp.length,amount+1); for(int i=0; i&lt;coins.length;i++)&#123; // 前提 for(int j=coins[i]; j&lt;=amount;j++)&#123; // 硬币数量统计 if(dp[j-coins[i]]!=amount+1)&#123; dp[j]=Math.min(dp[j], dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=amount+1) return dp[amount]; return -1; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Algorithm--Sqrt(x)","slug":"Algorithm-Sqrt-x","date":"2019-05-19","updated":"2019-05-31","comments":true,"path":"Algorithm-Sqrt-x/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Sqrt-x/","excerpt":"","text":"Some Algorithm using Math AlgorithmAlgorithm-1 Sqrt(x)Title detailImplement int sqrt(int x)Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:12Input: 4Output: 2Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.思路牛顿迭代法公式： $x_{k+1} = \\lfloor {x_k + n / {x_k}} \\rfloor / 2$当$k \\rightarrow \\infty$ 时，${x_{k+1}}^2 \\rightarrow n$Algorithm123456789101112class Solution &#123; public int mySqrt(int x) &#123; if(x&lt;=1) return x; long r=x; long t = x/r; while(r&gt;t)&#123; t = x/r; r = (r + t)/2; &#125; return (int)r; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algortthm--Jewels and Stones","slug":"Algortthm-Jewels-and-Stones","date":"2019-05-19","updated":"2019-05-31","comments":true,"path":"Algortthm-Jewels-and-Stones/","link":"","permalink":"http://sunyunzeng.com/Algortthm-Jewels-and-Stones/","excerpt":"","text":"Map的应用Jewels and StonesTitle DetailYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.Example 1:12Input: J = \"aA\", S = \"aAAbbbb\"Output: 3Example 2:12Input: J = \"z\", S = \"ZZ\"Output: 0Note:S and J will consist of letters and have length at most 50.The characters in J are distinct.思路使用Java里面的 Map。key键保存宝石类型，value键保存数量统计。Algorithm1234567891011121314151617181920class Solution &#123; public int numJewelsInStones(String J, String S) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;J.length(); i++)&#123; map.put(J.charAt(i), 0); &#125; for(int i=0; i&lt;S.length();i++)&#123; Character c = S.charAt(i); if(map.get(c)!=null)&#123; Integer freq =map.get(c); map.put(c, freq+1); &#125; &#125; int result = 0; for(Integer value: map.values())&#123; result += value; &#125; return result; &#125;&#125;法2 正则表达式123String a = \"[^\"+J+\"]\"; S = S.replaceAll(a, \"\"); return S.length();Python方法1return sum(S.count(i) for i in J)题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm--Fast and Slow Pointer","slug":"Algorithm-Fase-and-Low-Pointer","date":"2019-05-17","updated":"2019-05-31","comments":true,"path":"Algorithm-Fase-and-Low-Pointer/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Fase-and-Low-Pointer/","excerpt":"","text":"快慢指针的应用判断链表是否存在环Title DetailGiven a linked list, determine if it has a cycle in it.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.Example 1:123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.思路利用快慢指针，快指针每次走两步，慢指针每次走一步。如果快指针能够追上慢指针，则链表存在环。Algorithm1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null || head.next.next==null) return false; ListNode fast = head; ListNode slow = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow)&#123; return true; &#125; &#125; return false; &#125;&#125;题目链接有序数组移除重复数字Title DetailGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 1:12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;思路前提是有序数组，可见排序是很基础且重要的算法！过程：初始，快慢指针指向第一个数字。当快慢指针指向的数字都相同，快指针往前移动一位。当快慢指针指向的数字不相同，慢指针往前移动一位，把快指针指向的数字赋予慢指针，快指针往前移动一位。慢指针移动的 位数+1 即为不同数字的数量。且数组从初始位置到慢指针指向的位置，数字都是排好序的。Algorithm1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int fast=0; int slow=0; while(fast&lt;nums.length)&#123; if(nums[fast]==nums[slow])&#123; fast++; &#125;else&#123; nums[++slow]=nums[fast++]; &#125; &#125; return slow+1; &#125;&#125;图片地址题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm--Find Common Characters","slug":"Algorithm-Find-Common-Characters","date":"2019-05-17","updated":"2019-05-31","comments":true,"path":"Algorithm-Find-Common-Characters/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Find-Common-Characters/","excerpt":"","text":"Find Common CharactersTitle detailGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.You may return the answer in any order.Example 112Input: [\"bella\",\"label\",\"roller\"]Output: [\"e\",\"l\",\"l\"]Example 212Input: [\"cool\",\"lock\",\"cook\"]Output: [\"c\",\"o\"]Note:1231 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 100A[i][j] is a lowercase letter思路统计每个字符串中26个字母的出现次数。每个字符串都出现的字母且统计次数最少的即为结果输出的字符。用int数组0-25位置表示0-26个字母，存储的整数代表出现总次数。Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; commonChars(String[] A) &#123; List&lt;String&gt; list = new ArrayList(); int[] res = new int[26]; for(int i=0; i&lt;A[0].length();i++)&#123; res[A[0].charAt(i) - 'a'] += 1; &#125; for(int i=0; i&lt;A.length;i++)&#123; int[] temp = new int[26]; for(int j=0; j&lt;A[i].length(); j++)&#123; temp[A[i].charAt(j) - 'a'] +=1; &#125; for(int m=0; m&lt;26; m++)&#123; res[m] = Math.min(res[m], temp[m]); &#125; &#125; for(int i=0; i&lt;26; i++)&#123; if(res[i] &gt; 0)&#123; for(int j=0; j&lt;res[i]; j++)&#123; list.add((char)('a'+i)+\"\"); &#125; &#125; &#125; return list; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"在Linux系统中同步更新我们的Github博客","slug":"在Linux系统中同步更新我们的Github博客","date":"2019-04-28","updated":"2019-05-31","comments":true,"path":"在Linux系统中同步更新我们的Github博客/","link":"","permalink":"http://sunyunzeng.com/在Linux系统中同步更新我们的Github博客/","excerpt":"","text":"原理介绍类似于版本管理，我们把hexo博客文件系统在Github上建立一个分支，通过管理分支提交最新的博客文件系统，保证我们博客框架的更新。然后我们基于最新的博客框架，撰写文章，进行Github Pages网页的更新，即我们博客内容的更新。创建两个分支，一个用于存放博客静态资源，一个用于备份博客的部署文件。参考资料前期准备一台Linux系统的电脑（我的linux系统是Ubuntu 18.04.2 LTS）安装node.js 及 npm安装 ssh安装 git按照我们前面教程搭建好的博客创建Github 博客仓库分支首先在我们搭建Hexo博客的电脑上，创建我们博客仓库在Github上的分支。打开我们的博客仓库，选择setting：选择Branches,创建博客仓库的Hexo分支，并将其设置为默认分支。将该仓库克融到本地，并把本地博客的(所有Hexo目录下文件)全部拷贝进username.github.io文件目录中去。 然后把更新后的博客部署文件提交到Github的hexo分支中。依次执行123git add .git commit -m &apos;some info&apos;git push注意事项：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后我们的博客备份分支就创建好了。Linux 部署项目安装Node.js 与 npm安装gitlinux与Github建立联系把我们创建好的博客备份仓库clone到本机（linux）4.1 在要保存的位置执行语句 git clone git@github.com:your.github.io/your.github.io.git4.2 进入username.github.io目录，执行npm install (由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以要安装依赖)安装hexo插件sudo npm install hexo-cli -g撰写我们的博客文章，然后依次执行下面指令，更新我们的博客备份。12345hexo cleanhexo ggit add .git commit -m &apos;some info&apos;git push更新博客界面hexo d注意事项1. 每当撰写博客前，先 git pull，获取最新的博客备份。2. 写完博客后，先依次执行hexo clean 、 hexo g 、 git add . 、 git commit -m &#39;some info 、 git push&#39;进行博客备份部署文件更新。3. 最后执行 hexo d部署博客界面，实现博客更新。","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"System","slug":"System","permalink":"http://sunyunzeng.com/tags/System/"}]},{"title":"Windows环境下Hexo+Github搭建个人博客教程","slug":"博客搭建教程","date":"2019-04-23","updated":"2019-05-01","comments":true,"path":"博客搭建教程/","link":"","permalink":"http://sunyunzeng.com/博客搭建教程/","excerpt":"","text":"前言你是否也想拥有属于自己的博客？是否也想拥有跟我一样的博客空间？如果心动了，就赶紧往下看吧！教程炒鸡简单，炒鸡详细，而且博客搭建完全是Free of Charge!原理Github PagesGithub不仅可以让我们把代码托管在平台上，而且允许我们利用Github的服务器部署自定义网页对我们的项目作简介。这个网页就被称为Github Pages。这是我们可以利用Github搭建免费博客的基础啦~HexoHexo是一款轻量但高逼格的搭建博客快速工具，它是基于Node.js开发的。而Node.js…好了，扯远了…有兴趣的童鞋可以出门左转自己百度…准备知道了大致的原理，我们首先需要准备搭建博客的材料。如下：1. 一台windows系统的电脑2. 一个Github账号3. 安装Node.js4. 安装Git5. 安装Hexo开始申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)假设我们都有了Github账号，这是首先在右上角点击“+”号，选择New repository注意 仓库名一定是”你的Github用户名”+github.io !!!之后为我们的项目添加一个说明Pages！建好的项目顶部最右边有个Setting按钮，点击进入配置界面，下滑界面，直到看到Github Pages，这时你发现竟然自动生成了一个说明网页！因为Github说明网页的默认地址就是“你的Github用户名”+github.io，其它说明网页都是基于该地址的。Ok! 到此为止，Gihub Pages的部分就结束了。搭建Hexo，把Github Pages修改为自己的博客界面！安装Git以及Node.js！因为我们需要通过Git把我们的Hexo生成的网页提交到Github pages上，而Node.js是我们Hexo插件运行的基础！下载安装Windows版Git下载安装Node.js验证：“Win”+R打开运行界面，输入”cmd”打开命令行窗口。是否安装Git:输入git version出现版本信息：1git version 2.19.1.windows.1是否安装Node.js:输入node -v出现版本信息：1v8.12.0安装及部署Hexo首先创建一个文件夹，用来放置我们的Hexo。然后进入我们的文件夹，例如我们文件夹路径为D:\\blog则在终端依次输入并执行D: 、 cd blog 进入文件夹打开命令终端，利用Node.js的包管理器npm安装Hexo:npm install hexo-cli -g输入hexo -v验证是否安装成功输入hexo init初始化该文件夹输入npm install安装需要的组件输入npm g生成静态文件输入npm s启动服务器，现在在浏览器输入http://localhost:4000/打开我们的博客界面！是不是有点鸡冻！别急，我们还需要把页面推送到Github Pages上，步骤如下：1. 设置Git的user name和email在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;2. SSH 授权打开git bash，输入ssh-keygen -t rsa, 接着回车三下。最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去3. 上传项目首先用IDE(我用的是WebStorm)打开我们的Hexo文件夹，发现它的文档目录是这样的：12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- public|-- themes|-- .gitignore_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 –save 保存进去。scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;layout(布局)&gt; &lt;’title’&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用hexo clean 清除 db.json 和 public 文件夹下的所有文件。themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。打开配置文档_config.yml，修改deploy值（在末尾）:1234deploy: type: git repo: git@github.com:SUNYunZeng/SUNYunZeng.github.io.git branch: master安装在git上部署文章的扩展npm install hexo-deployer-git --save打开终端并进入到Hexo文件系统中，创建一篇新博客hexo new post &quot;博客名&quot;这时文件夹source/_posts文件夹里会出现博客名.md的博客文章源文件文件是markdown格式，书写方法有一套规范，下篇博客会讲到。PS:非常简单啦~编辑好博客内容后，一顿滚键盘，依次执行以下命令：hexo g 生成静态文件hexo d 部署到Github Pages就这样，你的第一篇博客就上传啦！更换Hexo主题由于默认的博客主题可能不能满足大家的需求，所以再提一下更换主题的方法。首先到Hexo官网中选择一款喜欢的主题这里我以我博客采用的主题为例，我采用的pure主题首先在Hexo系统文件夹中打开终端，然后输入git clone https://github.com/cofess/hexo-theme-pure.git themes/pure之后在系统目录theme文件夹下你会发现多出了pure命名的一个文件夹，这就是我们主题保存的位置,其中pure文件夹下的config.yml文件就是我们博客的配置文件，在里面可以自己对博客界面进行个性化配置，详情请参看网址在我们的Hexo系统配置文件config.yml中，修改theme为我们的pure主题1theme: pure然后进入文件夹 cd themes/pure把主题提交git pull重新生成博客静态文件，然后部署到Github Pageshexo ghexo d当当~我们的个性化博客就搭建完毕啦！","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"网页","slug":"网页","permalink":"http://sunyunzeng.com/tags/网页/"}]}]}