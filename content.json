{"meta":{"title":"孙云增的博客","subtitle":null,"description":null,"author":null,"url":"http://sunyunzeng.com","root":"/"},"pages":[{"title":"关于","date":"2019-05-31","updated":"2019-05-31","comments":false,"path":"about/index.html","permalink":"http://sunyunzeng.com/about/index.html","excerpt":"","text":"年龄: 保密… 身高: 保密… 体重: 保密… 状态: 武汉读研ing… 兴趣: 篮球; 读书; Coding … 座右铭: 生活极致简单，内涵极致丰富 …"},{"title":"书单","date":"2019-05-31","updated":"2019-05-31","comments":true,"path":"books/index.html","permalink":"http://sunyunzeng.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-01","updated":"2019-05-01","comments":false,"path":"categories/index.html","permalink":"http://sunyunzeng.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-05-01","updated":"2019-05-01","comments":false,"path":"repository/index.html","permalink":"http://sunyunzeng.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-05-01","updated":"2019-05-01","comments":true,"path":"links/index.html","permalink":"http://sunyunzeng.com/links/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-05-29","updated":"2019-05-29","comments":false,"path":"/404.html","permalink":"http://sunyunzeng.com//404.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-01","updated":"2019-05-01","comments":false,"path":"tags/index.html","permalink":"http://sunyunzeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"D3实现多对多关联关系弧线图","slug":"D3实现多对多关联关系弧线图","date":"2020-03-22","updated":"2020-03-22","comments":true,"path":"D3实现多对多关联关系弧线图/","link":"","permalink":"http://sunyunzeng.com/D3实现多对多关联关系弧线图/","excerpt":"","text":"多对多关联关系基于D3实现的多对多关联关系：github地址各人员之间的互动关系、各公司上下游企业的关联关系、各地之间的交互关系等等，都是多对多关联关系的表达，他们之间可以通过矩阵图的形式来表达, 如下图所示 (用python的heatmap：而利用 D3库函数可以实现更为酷炫的弧线,如下图所示：要画多方关系图，首先需要确定绘制的数据，是一个 N * N 的矩阵。1234567891011121314matrix = [ const matrix = [ [1, 41, 0, 0, 8, 4, 2, 0, 5, 5], [6, 0, 1, 1, 1, 0, 4, 1, 0, 1], [1, 12, 0, 0, 3, 0, 1, 0, 1, 3], [0, 11, 3, 0, 4, 1, 1, 0, 0, 2], [1, 1, 0, 0, 1, 0, 0, 2, 2, 0], [4, 0, 4, 0, 0, 0, 0, 1, 0, 1], [0, 6, 0, 0, 1, 1, 0, 0, 1, 0], [1, 4, 2, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 1, 0], ]]然后对 i 行 j 列对应的数据设计一个对象字典检索其对应的名字：123456789101112131415161718192021222324const nameByIndex = &#123; 0: 332, 1: 229, 2: 333, 3: 343, 4: 313, 5: 357, 6: 344, 7: 318, 8: 312, 9: 329 &#125;; const indexByName = &#123; 332: 0, 229: 1, 333: 2, 343: 3, 313: 4, 357: 5, 344: 6, 318: 7, 312: 8, 329: 9 &#125;;定义好 svg 图片的长和宽。利用D3绘制svg，核心代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243if (!this.d3 || !this.config || !this.matrix || !this.nameByIndex || !this.indexByName) &#123; console.error('initial error!'); &#125; let color = this.d3.scaleOrdinal(this.d3.schemeCategory10); let outerRadius = Math.min(this.width, this.height) * 0.5; let innerRadius = outerRadius - 124; let ribbon = this.d3.ribbon().radius(innerRadius); let arc = this.d3.arc().innerRadius(innerRadius).outerRadius(innerRadius + 20); let chord = this.d3.chord().padAngle(.04).sortSubgroups(this.d3.descending).sortChords(this.d3 .descending); let svg = this.d3.select(\"svg\").attr(\"viewBox\", [-this.width / 2, -this.height / 2, this.width, this .height ]) .attr(\"font-size\", this.font_size); const chords = chord(this.matrix); const group = svg.append(\"g\").selectAll(\"g\").data(chords.groups).join(\"g\"); group.append(\"path\").attr(\"fill\", d =&gt; color(d.index)).attr(\"stroke\", d =&gt; color(d.index)).attr(\"d\", arc); group.append(\"text\").each(d =&gt; &#123; d.angle = (d.startAngle + d.endAngle) / 2; &#125;) .attr(\"dy\", \".35em\") .attr(\"transform\", d =&gt; ` rotate($&#123;(d.angle * 180 / Math.PI - 90)&#125;) translate($&#123;innerRadius + 26&#125;) $&#123;d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"&#125;`) .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null) .text(d =&gt; this.nameByIndex[d.index]); svg.append(\"g\") .attr(\"fill-opacity\", 0.67) .selectAll(\"path\") .data(chords) .join(\"path\") .attr(\"stroke\", d =&gt; this.d3.rgb(color(d.source.index)).darker()) .attr(\"fill\", d =&gt; color(d.source.index)) .attr(\"d\", ribbon); this.svg = svg; return svg;html代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script src=\"https://d3js.org/d3.v5.min.js\"&gt;&lt;/script&gt;&lt;script src=\"ChordDependencyChart.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;body&gt; &lt;svg style=\"width: 1000px; height:1000px\"&gt;&lt;/svg&gt;&lt;/body&gt;&lt;script&gt; const matrix = [ [1, 41, 0, 0, 8, 4, 2, 0, 5, 5], [6, 0, 1, 1, 1, 0, 4, 1, 0, 1], [1, 12, 0, 0, 3, 0, 1, 0, 1, 3], [0, 11, 3, 0, 4, 1, 1, 0, 0, 2], [1, 1, 0, 0, 1, 0, 0, 2, 2, 0], [4, 0, 4, 0, 0, 0, 0, 1, 0, 1], [0, 6, 0, 0, 1, 1, 0, 0, 1, 0], [1, 4, 2, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 1, 0], ] const nameByIndex = &#123; 0: 332, 1: 229, 2: 333, 3: 343, 4: 313, 5: 357, 6: 344, 7: 318, 8: 312, 9: 329 &#125;; const indexByName = &#123; 332: 0, 229: 1, 333: 2, 343: 3, 313: 4, 357: 5, 344: 6, 318: 7, 312: 8, 329: 9 &#125;; let config = &#123; matrix: matrix, nameByIndex: nameByIndex, indexByName: indexByName, width: 1000, height: 1000 &#125; let chart = new Chart(d3, config); let svg = chart.draw(); chart.saveAsPng(svg, name = \"local\");&lt;/script&gt;&lt;/html&gt;其中 d3 是 D3 库函数依赖，可以使用离线包或者在线引用的方式。ChordDependencyChart是我自定义的一个库函数，可以实现多对多关联关系弧线图绘制，并可以保存为 png 图片，效果如下：github地址","categories":[{"name":"Web可视化","slug":"Web可视化","permalink":"http://sunyunzeng.com/categories/Web可视化/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://sunyunzeng.com/tags/D3/"}]},{"title":"JS实现图片的懒加载","slug":"JS实现图片的懒加载","date":"2020-03-16","updated":"2020-03-16","comments":true,"path":"JS实现图片的懒加载/","link":"","permalink":"http://sunyunzeng.com/JS实现图片的懒加载/","excerpt":"","text":"场景需求在长博客、商品网站上经常见到大量的图片，而同时加载如此多的图片会导致服务器响应慢、页面卡顿，用户体验不佳。而图片懒加载就是应对这个痛点。图片懒加载技术就是根据图片在可视区域的位置对图片进行逐步加载，利用 DOM对象元素属性、分流等技术实现。 实现原理 步骤一 隐藏懒加载图片的 src 属性我们首先需要确定懒加载的图片资源，对于 img 标签，首先把src 属性用自定义的属性如 data-src 代替，等到图片需要加载时我们将 data-src 的网址赋予 src 属性即可。1&lt;img data-src='./dzq.jpg' alt=\"dzq\"&gt; 步骤二 判断待加载图片是否位于视窗范围内DOM 元素拥有一个方法 element.getBoundingClientRect()，可以获取该元素的大小及其相对于视口的位置，方法返回的是一个 DOMRect 对象，其 left, top, right, bottom 属性解释了相对于视口位置，如下所示。然后利用 img.getBoundingClientRect().top &lt; document.documentElement.clientHeight 对图片位置进行判断。 步骤三 对加载到视口内的元素进行显示通过对 windows.scroll 进行监听，然后 img 元素新建 src 属性，并将 data-src 的地址赋予该属性。 优化而我们在监听windows.scroll 事件过程中，对于 img 元素的操作一致在进行，这就浪费了很多计算资源。为了绕开这个问题，我们使用节流技术手段。 节流对于高频事件，我们希望处理函数仅在固定的频率响应。例如，对于窗口滑动事件，可能每 20ms 就触发一次，而我们希望每 200ms 处理函数只响应一次，这样就节约了很多不必要的计算资源。1234567891011121314151617// 节流函数定义function throttle(fn, wait)&#123; let timer; return function()&#123; let that = this; let args = arguments; if(!timer)&#123; timer = setTimeOut(function()&#123; fn.apply(that, args); timer = null; &#125;,wait) &#125; &#125;&#125;// 节流函数使用widow.addEventListener(\"scroll\", throttle(showImg, 200)); 防抖另一个类似的技术手段就是防抖，是在高频事件触发后一定时间内使处理函数响应。它与节流函数的区别是，如果高频事件一直触发，那么处理函数一直得不到响应。12345678910111213function debounce(fn, wait)&#123; let timer; return function()&#123; let that = this; let args = arguments; if(!timer)&#123; clearTimeOut(timer); &#125; timer = setTimeOut(function()&#123; fn.apply(that, args); &#125;, wait); &#125;&#125; demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; html, body&#123; height: 100%; width: 100%; padding: 0; margin: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"upContext\" style=\"height: 100%; width: 100%; position: relative; background-color: aquamarine;\"&gt;?&lt;/div&gt; &lt;div style=\"display:flex; position: relative; align-items: center; justify-content: center;\"&gt; &lt;img d-src=\"./dzq.jpg\" alt=\"图片\" id=\"img1\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let img = document.getElementById('img1'); let showImg = function()&#123; if(img.getBoundingClientRect().top &lt; document.documentElement.clientHeight)&#123; img.setAttribute('src', img.getAttribute('d-src')); &#125; &#125; function throttle(fn, wait)&#123; let timer; return function()&#123; let that = this; let args = arguments; if(!timer)&#123; timer = setTimeout(function()&#123; fn.apply(that, args); timer = null; &#125;, wait); &#125; &#125; &#125; window.addEventListener(\"scroll\", throttle(showImg, 200)); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"背包问题","slug":"背包问题","date":"2020-03-13","updated":"2020-03-13","comments":true,"path":"背包问题/","link":"","permalink":"http://sunyunzeng.com/背包问题/","excerpt":"","text":"01 背包有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 viv_ivi​，价值是 wiw_iwi​。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。接下来有 N 行，每行两个整数 vi,wiv_i,w_ivi​,wi​，用空格隔开，分别表示第 i 件物品的体积和价值。输出格式输出一个整数，表示最大价值。数据范围0&lt;N,V≤10000&lt; N,V ≤ 10000&lt;N,V≤10000&lt;vi,wi≤10000&lt; v_i,w_i ≤ 10000&lt;vi​,wi​≤1000输入样例123454 51 22 43 44 5输出样例：18 思路+方法f[i][j]表示面对第 i 件物品时，体积为 j 的背包的最大总价值。两种选择：1. 不放入第 i 件物品。 2. 放入第 i 件物品。状态转移方程：f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])优化：f[j]=max(f[j],f[j−w[i]]+v[i])。此时 j 要从大到小遍历，保证第 i 件物品只能选择一次。否则 f[i][j] 会由 f[i][j−w[i]]+v[i]决定，与题意不符，而顺序遍历却是完全背包的解决方案。1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner reader = new Scanner(System.in); int N = reader.nextInt(); int V = reader.nextInt(); int[] v = new int[N]; int[] w = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = reader.nextInt(); w[i] = reader.nextInt(); &#125; reader.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; for(int j=V; j&gt;=v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125; System.out.println(dp[V]); &#125;&#125;时间复杂度 O(VN) 完全背包完全背包题目与01背包大体相似，只不过每件物品可以无限选择。 思路 + 代码状态转移方程：f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])。1234567891011121314151617181920212223import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner in = new Scanner(System.in); int N = in.nextInt(); int V = in.nextInt(); int[] w = new int[N]; int[] v = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = in.nextInt(); w[i] = in.nextInt(); &#125; in.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; for(int j=v[i]; j&lt;=V; j++)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125; System.out.println(dp[V]); &#125;&#125;时间复杂度 O(VN) 多重背包多重背包是每个物品指定了数量。有 N 种物品和一个容量是 V 的背包。第 i 种物品最多有 sis_isi​ 件，每件体积是 viv_ivi​，价值是 wiw_iwi​。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。输入格式第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。接下来有 N 行，每行三个整数 vi,wi,siv_i,w_i,s_ivi​,wi​,si​，用空格隔开，分别表示第 i 种物品的体积、价值和数量。输出格式输出一个整数，表示最大价值。数据范围0&lt;N,V≤1000&lt;vi,wi,si≤1000&lt;v_i,w_i,s_i≤1000&lt;vi​,wi​,si​≤100输入样例123454 51 2 32 4 13 4 34 5 2输出样例：110 思路 + 代码将多重背包转化为 01背包问题，即将有限量的物品划分为互相独立的部分，每个独立的部分物品可以看作01背包问题，继续采用01背包的思想解决。状态转移方程：f[i][j]=max(f[i−1][j],f[i−1][j−k*w[i]]+k*v[i])。将第 i 种物品转化为 p[i]件物品，每件物品的系数分别为 1，2,4,...,2k−1,p[i]−2k+1&gt;01，2, 4, ..., 2^{k-1}, p[i]-2^k+1 &gt; 01，2,4,...,2k−1,p[i]−2k+1&gt;0, k是满足 p[i]−2k+1&gt;0p[i]-2^k+1 &gt; 0p[i]−2k+1&gt;0 的最大整数。123456789101112131415161718192021222324252627282930import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int[] v = new int[N]; int[] w = new int[N]; int[] s = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = sc.nextInt(); w[i] = sc.nextInt(); s[i] = sc.nextInt(); &#125; sc.close(); int[]dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; int num = Math.min(s[i], V/v[i]); for(int k=1; num&gt;0; k &lt;&lt;= 1)&#123; if(k&gt;num) k = num; num -= k; for(int j=V; j&gt;=k*v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-k*v[i]]+k*w[i]); &#125; &#125; &#125; System.out.println(dp[V]); &#125;&#125;时间复杂度 O(V∑log(p(i))\\sum{log(p(i))}∑log(p(i))) 混合背包混合背包其实是 01背包、多重背包和完全背包的混合体。有 N 种物品和一个容量是 V 的背包。物品一共有三类：第一类物品只能用1次（01背包）；第二类物品可以用无限次（完全背包）；第三类物品最多只能用 sis_isi​ 次（多重背包）；每种体积是 viv_ivi​，价值是 wiw_iwi​。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。输入格式第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。接下来有 N 行，每行三个整数 vi,wi,siv_i,w_i,s_ivi​,wi​,si​，用空格隔开，分别表示第 i 种物品的体积、价值和数量。sis_isi​=−1 表示第 i 种物品只能用1次；sis_isi​=0 表示第 i 种物品可以用无限次；sis_isi​&gt;0 表示第 i 种物品可以使用 sis_isi​ 次；输出格式输出一个整数，表示最大价值。数据范围$ 0&lt;N,V≤1000 0&lt;v_i,w_i≤1000 −1≤s_i≤1000 $输入样例123454 51 2 -12 4 13 4 04 5 2输出样例：18 思路 + 代码加入if-else判断。123456789// p[i]:每个物品的件数，0代表无穷个for (int i = 1; i &lt;= n; i++) if (p[i] == 0) for (int j = w[i]; j &lt;= V; j++) f[j] = max(f[j], f[j - w[i]] + v[i]); else for (int k = 1; k &lt;= p[i]; k++) for (int j = V; j &gt;= w[i]; j--) f[j] = max(f[j], f[j - w[i]] + v[i]);12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int[] v = new int[N]; int[] w = new int[N]; int[] s = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = sc.nextInt(); w[i] = sc.nextInt(); s[i] = sc.nextInt(); &#125; sc.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; if(s[i] == -1)&#123; for(int j=V; j&gt;=v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125;else if(s[i]==0)&#123; for(int j=v[i]; j&lt;=V; j++)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125;else&#123; int num = Math.min(s[i], V/v[i]); for(int k=1; num&gt;0; k &lt;&lt;=1)&#123; if(k&gt;num) k=num; num -= k; for(int j=V; j&gt;=k*v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-k*v[i]]+k*w[i]); &#125; &#125; &#125; &#125; System.out.println(dp[V]); &#125;&#125; 二维背包物品的约束条件除了体积外，增加了重量一维，其余跟01背包一样。有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。每件物品只能用一次。体积是 viv_ivi​，重量是 mim_imi​，价值是 wiw_iwi​。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。输入格式第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。接下来有 N 行，每行三个整数 vi,mi,wiv_i,m_i,w_ivi​,mi​,wi​，用空格隔开，分别表示第 i 件物品的体积、重量和价值。输出格式输出一个整数，表示最大价值。数据范围0&lt;N≤10000&lt;N≤10000&lt;N≤10000&lt;V,M≤1000&lt;V,M≤1000&lt;V,M≤1000&lt;vi,mi≤1000&lt;v_i,m_i≤1000&lt;vi​,mi​≤1000&lt;wi≤10000&lt;w_i≤10000&lt;wi​≤1000输入样例123454 5 61 2 32 4 43 4 54 5 6输出样例：18 思路 + 代码跟01背包类似，只不过两个状态。状态转移方程：f[j][k]=max(f[j][k],f[j−w[i]][k-m[i]]+k*v[i])。12345678910111213141516171819202122232425262728import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int M = sc.nextInt(); int[] v = new int[N]; int[] m = new int[N]; int[] w = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = sc.nextInt(); m[i] = sc.nextInt(); w[i] = sc.nextInt(); &#125; sc.close(); int[][] dp = new int[V+1][M+1]; for(int i=0; i&lt;N; i++)&#123; for(int j=V; j&gt;=v[i]; j--)&#123; for(int k=M; k&gt;=m[i]; k--)&#123; dp[j][k] = Math.max(dp[j][k], dp[j-v[i]][k-m[i]]+w[i]); &#125; &#125; &#125; System.out.println(dp[V][M]); &#125;&#125; 分组背包在01背包的基础上，对不同物品进行了分组，每组只能选取一件物品。有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vijv_ijvi​j，价值是 wijw_ijwi​j，其中 i 是组号，j 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。输入格式第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。接下来有 N 组数据：每组数据第一行有一个整数 SiS_iSi​，表示第 i 个物品组的物品数量；每组数据接下来有 SiS_iSi​ 行，每行有两个整数 vij,wijv_ij,w_ijvi​j,wi​j，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；输出格式输出一个整数，表示最大价值。数据范围0&lt;N,V≤1000&lt;N,V≤1000&lt;N,V≤1000&lt;Si≤1000&lt;S_i≤1000&lt;Si​≤1000&lt;vij,wij≤1000&lt;v_ij,w_ij≤1000&lt;vi​j,wi​j≤100输入样例123456783 521 22 413 414 5输出样例：18 思路 + 代码状态转移方程：1234for i in (每一种分组): for j in range(V,0,-1): for k in 分组[i]: dp[j] = max(dp[j], dp[j-分组[i][0]]+分组[i][1])12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;import java.util.HashMap;import java.util.ArrayList;class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int K = sc.nextInt(); int V = sc.nextInt(); int N = 0; HashMap&lt;Integer, ArrayList&lt;int[]&gt;&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;K; i++)&#123; int s = sc.nextInt(); N += s; ArrayList&lt;int[]&gt; arr = new ArrayList&lt;&gt;(); for(int j=0; j&lt;s;j++)&#123; int[] tmp = new int[2]; tmp[0] = sc.nextInt(); tmp[1] = sc.nextInt(); arr.add(tmp); map.put(i, arr); &#125; &#125; sc.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;K; i++)&#123; ArrayList&lt;int[]&gt; arr = map.get(i); for(int j=V; j&gt;=0; j--)&#123; for(int k=0; k&lt;arr.size();k++)&#123; if(j&gt;=arr.get(k)[0]) dp[j] = Math.max(dp[j], dp[j-arr.get(k)[0]]+arr.get(k)[1]); &#125; &#125; &#125; System.out.println(dp[V]); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"CSS 布局知识","slug":"CSS-布局知识","date":"2020-02-22","updated":"2020-02-29","comments":true,"path":"CSS-布局知识/","link":"","permalink":"http://sunyunzeng.com/CSS-布局知识/","excerpt":"","text":"CSS实现垂直水平居中对于父元素 parent 与 子元素 child，如何实现子元素在父元素内部的水平垂直居中？元素的 html 代码如下：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; &#125; .child&#123; width: 200px; height: 200px; background-color: coral; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex 布局123456789101112131415&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; display: flex; align-items: center; justify-content: center; &#125; .child&#123; width: 200px; height: 200px; background-color: coral; &#125;&lt;/style&gt; 行内元素居中text-algin 与 vertical-algin 只对行内元素起作用，可以实现行内元素的的垂直于水平居中，此时可以利用 display: inline-block 使子元素具有行内元素的属性，实现子元素垂直水平居中 (需设置 line-height 使垂直居中有对齐的基准)。12345678910111213141516&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; vertical-algin: middle; text-algin: center; line-height: 300px; &#125; .child&#123; display: inline-block; width: 200px; height: 200px; background-color: coral; &#125;&lt;/style&gt; 绝对定位 + 元素自身移动通过 left: 50% 以及 top: 50% 只使得子元素的左上角位于父元素的中心，此时需要通过 transform: translate(-50%, -50%) 移动子元素。translate(x,y) 括号的百分比数据，会以本身的长宽做参考，比如，本身的长为100px，高为100px. 那填(50%,50%)就是向右，向下移动50px，添加负号就是向着相反的方向移动50%1234567891011121314151617&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; position: relative; &#125; .child&#123; position: absolute; width: 200px; height: 200px; left: 50%; top: 50%; background-color: coral; transform: translate(-50%, -50%); &#125;&lt;/style&gt;1234567891011121314151617&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; position: relative; &#125; .child&#123; position: absolute; width: 200px; height: 200px; left: 50%; top: 50%; background-color: coral; margin: -100px -100px; &#125;&lt;/style&gt; 利用 margin12345678910111213141516171819&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; position: relative; &#125; .child&#123; position: absolute; width: 200px; height: 200px; background-color: coral; left: 0; top: 0; right: 0; bottom: 0; margin: auto; &#125;&lt;/style&gt; CSS实现三栏布局所谓的三栏布局，既是指左右两栏固定宽度，中间一栏宽度自适应的布局方式。下面列出五种实现三栏布局的方式，分别是绝对定位、float方式、flex布局、圣杯布局、双飞翼布局。 绝对定位利用绝对定位将左右两栏确定位置，中间一栏通过 margin 属性调整位置。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; &#125; .left&#123; position: absolute; height: 100%; width: 200px; left: 0; top: 0; background-color: coral; &#125; .middle&#123; height: 100%; margin: 0 200px 0 200px; background-color: blueviolet; &#125; .right&#123; position: absolute; height: 100%; width: 200px; right: 0; top: 0; background-color: crimson; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"middle\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; float布局float定位实现三栏布局的思想是：利用float将左右两栏固定位置，并利用margin控制中间一栏的边距，从而使其宽度自适应。123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; &#125; .left&#123; height: 100%; width: 200px; float: left; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; float: right; background-color: crimson; &#125; .middle&#123; height: 100%; margin: 0 200px 0 200px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"middle\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex布局flex布局实现三栏布局的思想是：利用flex:0 0 200px固定左右两栏的位置，同时确保其不随浏览器的高度和宽度而放大缩小。 flex参数参照:https://www.w3cschool.cn/cssref/css3-pr-flex.html123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; &#125; .parent&#123; display: flex; &#125; .left&#123; height: 100%; width: 200px; flex: 0 0 200px; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; flex: 0 0 200px; background-color: crimson; &#125; .middle&#123; height: 100%; width: 100%; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"middle\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 圣杯布局圣杯布局的原理是通过左、中、右列同向浮动，中间列宽度设置为100%实现宽度自适应，左右两列宽度宽度固定并通过位置控制实现分列左右两端。该布局可以实现中间布局的优先渲染，因为DOM结构上 middle 元素位于 left 和 right 元素的上层。1. 首先父级元素设置内边距1234.parent&#123; padding-left: 200px; padding-right: 200px;&#125;2. 各自设置浮动方式及页面宽度123456789101112.left&#123; width: 200px; float: left;&#125;.right&#123; width: 200px; float: left;&#125;.middle&#123; width: 100%; float: left;&#125;3. 左栏控制位置12345.left&#123; margin-left: -200px; position: relative; left: -100%;&#125;4. 右栏控制位置123.right&#123; margin-right: -200px;&#125;5. 设置左右两栏的最小宽度最小宽度并不是 200px + 200px = 400px，因为 left 元素采用了相对定位，其在 middle 元素上方还占有 200px 位置，所以页面的 min-width 参数为 400px + 200px = 600px。123body&#123; min-width: 600px;&#125;全部代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; min-width: 600px; &#125; .parent&#123; padding-left: 200px; padding-right: 200px; &#125; .left&#123; height: 100%; width: 200px; float: left; margin-left: -100%; position: relative; left: -200px; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; float: left; margin-right: -200px; background-color: crimson; &#125; .middle&#123; height: 100%; width: 100%; float: left; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"middle\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局双飞翼布局与圣杯布局的区别是：双飞翼布局的 parent 元素只包裹 middle 元素，left 元素与 right 元素通过控制与 parent的相对位置关系实现三栏布局。1. 首先用 parent 仅包裹 middle 元素123&lt;div class=\"parent\"&gt; &lt;div class=\"middle\"&gt;&lt;/div&gt;&lt;/div&gt;2. 所有元素设置宽度与浮动123456789101112131415161718.parent&#123; width: 100%; float: left;&#125;.left&#123; height: 100%; width: 200px; float: left;&#125;.right&#123; height: 100%; width: 200px; float: left;&#125;.middle&#123; padding-left: 200px; padding-right: 200px;&#125;3. 设置左栏位置1margin-left: -100%;4. 设置右栏位置1margin-right: -200px;5. 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; min-width: 600px; &#125; .parent&#123; width: 100%; float: left; background-color: blueviolet; &#125; .left&#123; height: 100%; width: 200px; float: left; margin-left: -100%; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; float: left; margin-left: -200px; background-color: crimson; &#125; .middle&#123; padding-left: 200px; padding-right: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"middle\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://sunyunzeng.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://sunyunzeng.com/tags/CSS/"}]},{"title":"CSS 知识要点","slug":"CSS-知识要点","date":"2020-02-18","updated":"2020-02-29","comments":true,"path":"CSS-知识要点/","link":"","permalink":"http://sunyunzeng.com/CSS-知识要点/","excerpt":"","text":"选择元素基本元素选择12/* 把段落文本设置成红色，12像素大，粗体 */p &#123;color:red; font-size:12px; font-weight:bold;&#125;上下文选择12/* 选择祖先元素为 article 标签的所有段落 p 后代 */article p &#123;color:red; font-size:12px; font-weight:bold;&#125;特殊上下文选择子选择符12/* 将 section 的 h2 子元素的字体设置为 italic */section &gt; h2 &#123;font-style:italic;&#125;紧邻同胞选择12/* 将紧邻着 h2 的元素同胞 p 选择设置 */h2 + p &#123;font-style:italic;&#125;一般同胞选择12/* 将 h2 与 p 之间的同胞全部选择 */h2 ~ p &#123;font-style:italic;&#125;通用选择1234/* 全文所有字体颜色（包括文本框）设置为黑色 */* &#123;color: black&#125;/* 只把 p 元素中所有元素文本设置为红色 */p *&#123;color: red&#125;类选择12/* 把属于 specialtext 类的元素设置字体类型 */.specialtext &#123;font-style:italic;&#125;标签带类选择12/* 把 p元素中属于 specialtext 类的元素设置字体类型 */p.specialtext &#123;font-style:italic;&#125;ID选择123456789/*把 ID 为 mainmenu 元素中的 a 元素的字体颜色修改*/#mainmenu a &#123;color:orange;&#125;``` **属性名选择**```css/*将带有 title 属性的 HTML img 元素显示 2 像素宽的蓝色边框*/img[title] &#123;&#123;border:2px solid blue;&#125;&#125;伪类选择伪类就是当 HTML 元素在某种状态时触发显示相应的 CSS 样式，伪类的用法是 元素名:状态 {属性名: 值}例如：1a:link &#123;color:black;&#125;主要的伪类状态有以下几种：状态名描述link链接初始状态visited链接被点击过状态hover鼠标悬浮上去状态active鼠标正在被点击的状态focus表单获取焦点时状态target对于设置为目标的元素被选择时的状态first-child一组同胞元素的第一个元素last-child一组同胞元素中最后一个元素nth-child一组同胞元素中第 n 个元素伪元素选择两个冒号后面加伪元素状态，常用的有 ::first-letter (首字母状态)、::first-line (首行状态)、::before与::after (特定元素前后添加特殊内容)。1&lt;p class=\"age\"&gt;25&lt;/p&gt;1234p.age::before &#123;content:\"Age: \";&#125; p.age::after &#123;content:\" years.\";&#125;/* 显示如下：Age: 25 years.*/ CSS样式叠加顺序CSS 样式叠加遵循以下四个规则：1. 首先找到各元素所有的 CSS 声明。2. 按照以下顺序层叠显示，越靠后的 CSS 定义方式显示级别越高。浏览器默认样式用户自定义样式链接样式 （&lt;link href=&quot;style.css&quot; rel=stylesheet type=&quot;text/css&quot; /&gt;）嵌入样式1234567&lt;head&gt;&lt;!-- 其他 head 元素（如 meta、title）放在这里 --&gt; &lt;style type=\"text/css\"&gt; h1 &#123;font-size:16px;&#125; p &#123;color:blue;&#125; &lt;/style&gt; &lt;/head&gt;行内样式123&lt;p style=\"font-size: 12px; font-weight:bold; font-style:italic; color:red;\"&gt;By adding inline CSS styling to this paragraph, you override the default styles.&lt;/p&gt;如果 css 里面的权重定义是 !important，则不考虑 CSS样式的优先级规则，优先使用。3. 按照特指度确定显示优先级特指度指的是说明元素信息的详细程度，例如 元素 p 的特指度就要低于某一 css 类的特指度。计算规则：I-C-EI-C-E 表示 ID、Class、Element三个维度的得分三位数，初始为 0-0-0。如果样式里指明一个 ID，I 代表的数字 +1。如果样式里指明一个 类 class，C 代表的数字 +1。如果样式里指明一个 元素 Element，E代表的数字 +1。例如：123456p 0-0-1 特指度=1 p.largetext 0-1-1 特指度=11 p#largetext 1-0-1 特指度=101body p#largetext 1-0-2 特指度=102body p#largetext ul.mylist 1-1-3 特指度=113 body p#largetext ul.mylist li 1-1-4 特指度=1144. 特指度相同的情况下按照叠加顺序 盒模型令人困惑的盒子属性。每个元素就是一个盒子，其有对应的形状，对应的属性有三组：边框（border）、内边距（padding）及外边距 （margin）。1. 垂直方向的外边距取最大值。如果有两个段落 p，其CSS样式如下：1p &#123;height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px; margin-bottom:30px;&#125;那么它们之间的距离为 **50px，**而不是 50px + 30px= 80px。2. 水平方向外边距叠加。3. 盒子的大小视 width 属性而定。在 width 没有指定情况下，元素的宽度与父元素一致。此时设置盒子的 border 及 padding 会向内拓展，不改变盒子大小。设置 margin 会使元素宽度相对父元素的宽度减去两倍的外边距。在指定了 width 宽度大小情况下，元素宽度会拓展。此时设置盒子的 border 及 padding 会向外拓展，使盒子变大。添加 box-sizing:border-box 属性，使盒子在指定宽度 width 同时，也能像未指定一样工作。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://sunyunzeng.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://sunyunzeng.com/tags/CSS/"}]},{"title":"自己实现简单版Vue--3. 实现数据的双向绑定和Proxy代理","slug":"自己实现简单版Vue-3-实现数据的双向绑定和Proxy代理","date":"2020-02-01","updated":"2020-02-01","comments":true,"path":"自己实现简单版Vue-3-实现数据的双向绑定和Proxy代理/","link":"","permalink":"http://sunyunzeng.com/自己实现简单版Vue-3-实现数据的双向绑定和Proxy代理/","excerpt":"","text":"数据的双向绑定之前我们已经实现数据影响视图，即数据更新调用setter()方法里绑定的方法，通过Dev通知Watcher更新视图。然后我们需要实现视图影响数据进而再影响视图。通过为input节点利用Object.addEventListener()绑定事件监听，再调用数据更新方法更新数据。数据更改后由于之前已经实现了数据更改后页面的自动更新，由此数据自然驱动视图。12345678910111213141516// 编译模版具体执行const compileUtil = &#123; // ... 省略 model(node, expr, vm) &#123; const value = this.getValue(expr, vm); // v-model绑定对应的 Watcher, 数据驱动视图 new Watcher(expr, vm, (newVal)=&gt;&#123; this.updater.modelUpdater(node, newVal); &#125;); // 视图 =&gt; 数据 =&gt; 视图 node.addEventListener('input', (e)=&gt;&#123; this.setVal(expr, vm, e.target.value); &#125;) this.updater.modelUpdater(node, value); &#125;&#125; this.$data的代理我们可以通过在vm对象中使用this.person.name直接修改数据，而不是通过this.$data.person.name实现。利用this.$data的代理实现。123456789101112131415161718192021&lt;script&gt; let vm = new MVue(&#123; el: '#app', data: &#123; person: &#123; name: '海贼——王路飞', age: 18, fav: 'film' &#125;, msg: '最简单的插值', htmlStr: '&lt;h3&gt;这是v-html&lt;/h3&gt;' &#125;, methods:&#123; handleClick: function()&#123; console.log('这是一个处理点击事件的方法'); // 使用代理的方式可以直接这样修改数据 this.person.name = '海贼王——路飞' &#125; &#125; &#125;); &lt;/script&gt;123456789101112131415161718192021222324252627class MVue &#123; constructor(options) &#123; // 初始元素与数据通过options对象绑定 this.$el = options.el; this.$data = options.data; this.$options = options; // 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法 if (this.$el) &#123; // ... 省略 // 通过数据代理实现 this.person.name = '海贼王——路飞'功能，而不是this.$data.person.name = '海贼王——路飞' this.proxyData(this.$data); &#125; &#125; //用vm代理vm.$data proxyData(data)&#123; for(let key in data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return data[key]; &#125;, set(newVal)&#123; data[key] = newVal; &#125; &#125;) &#125; &#125;&#125; 项目地址https://github.com/SUNYunZeng/ImitateVue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"自己实现简单版Vue--2. 实现数据绑定视图","slug":"自己实现简单版Vue-2-定义Observer实现对象属性劫持","date":"2020-01-31","updated":"2020-02-01","comments":true,"path":"自己实现简单版Vue-2-定义Observer实现对象属性劫持/","link":"","permalink":"http://sunyunzeng.com/自己实现简单版Vue-2-定义Observer实现对象属性劫持/","excerpt":"","text":"利用Object.defineProperty()方法实现数据的监听Object.defineProperty()方法可以具体参考链接：http://sunyunzeng.com/JavaScript中的对象/#访问器属性该方法可以定义对象数据在访问操作时的一些约定。定义 Observer 对象123456789101112131415161718192021222324252627282930313233class Observer&#123; constructor(data)&#123; this.observe(data); &#125; // data是一个对象，可能嵌套其它对象，需要采用递归遍历的方式进行观察者绑定 observe(data)&#123; if(data &amp;&amp; typeof data === 'object')&#123; Object.keys(data).forEach(key =&gt;&#123; this.defineReactive(data, key, data[key]); &#125;) &#125; &#125; // 通过 object.defineProperty方法对对象属性进行劫持 defineReactive(obj, key, value)&#123; // 递归观察 this.observe(value); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: false, get()&#123; return value; &#125;, // 采用箭头函数在定义时绑定this的定义域 set: (newVal)=&gt;&#123; if(newVal !== value)&#123; this.observe(newVal); value = newVal; console.log(newVal); &#125; &#125; &#125;) &#125;&#125;利用Observer对象对数据进行劫持123456789101112131415class MVue &#123; constructor(options) &#123; // 初始元素与数据通过options对象绑定 this.$el = options.el; this.$data = options.data; this.$options = options; // 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法 if (this.$el) &#123; // 1. 编译模版 new Compiler(this.$el, this); // 2. 创建观察者，观察数据 new Observer(this.$data); &#125; &#125;&#125;定义Dep容器及Watcher对象对数据变化进行监听123456789101112131415161718192021222324252627282930313233343536373839404142class Watcher&#123; // 通过回调函数实现更新的数据通知到视图 constructor(expr, vm, cb)&#123; this.expr = expr; this.vm = vm; this.cb = cb; this.oldVal = this.getOldVal(); &#125; // 获取旧数据 getOldVal()&#123; // 在利用getValue获取数据调用getter()方法时先把当前观察者挂载 Dep.target = this; console.log(Dep.target); const oldVal = compileUtil.getValue(this.expr, this.vm); // 挂载完毕需要注销，防止重复挂载 (数据一更新就会挂载) Dep.target = null; return oldVal; &#125; // 通过回调函数更新数据 update()&#123; const newVal = compileUtil.getValue(this.expr, this.vm); if(newVal !== this.oldVal)&#123; this.cb(newVal); &#125; &#125;&#125;// Dep类存储watcher对象，并在数据变化时通知watcherclass Dep&#123; constructor()&#123; this.watcherCollector = []; &#125; // 添加watcher addWatcher(watcher)&#123; console.log('观察者', this.watcherCollector); this.watcherCollector.push(watcher); &#125; // 数据变化时通知watcher更新 notify()&#123; this.watcherCollector.forEach(w=&gt;w.update()); &#125;&#125;在Observer中绑定Dev123456789101112131415161718192021class Observer&#123; // ... 省略 defineReactive(obj, key, value)&#123; // ... 省略 const dep = new Dep(); Object.defineProperty(obj, key, &#123; // ... 省略 get()&#123; // 订阅数据变化时，往Dev中添加观察者 Dep.target &amp;&amp; dep.addWatcher(Dep.target); return value; &#125;, // 采用箭头函数在定义时绑定this的定义域 set: (newVal)=&gt;&#123; // ... 省略 // 通知watcher数据发生改变 dep.notify(); &#125; &#125;) &#125;&#125;在编译工具中绑定Watcher123456789101112131415161718192021222324252627282930313233const compileUtil = &#123; // ... 省略 getContent(expr, vm)&#123; // &#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125; // 防止修改person.name使得所有值全部被替换 return expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; return this.getValue(args[1], vm); &#125;); &#125;, text(node, expr, vm) &#123; let value; if(expr.indexOf('&#123;&#123;')!==-1)&#123; value = expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; // text的 Watcher应在此绑定，因为是对插值&#123;&#123;&#125;&#125;进行双向绑定 // Watcher的构造函数的 getOldVal()方法需要接受数据或者对象，而&#123;&#123;person.name&#125;&#125;不能接收 new Watcher(args[1], vm, ()=&gt;&#123; this.updater.textUpdater(node, this.getContent(expr, vm)); &#125;); return this.getValue(args[1], vm); &#125;); &#125;else&#123; value = this.getValue(expr, vm); &#125; this.updater.textUpdater(node, value); &#125;, html(node, expr, vm) &#123; let value = this.getValue(expr, vm); // html对应的 Watcher new Watcher(expr, vm, (newVal)=&gt;&#123; this.updater.htmlUpdater(node, newVal); &#125;) this.updater.htmlUpdater(node, value); &#125;在MVue类的构造函数中绑定Observer12345678910111213class MVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; this.$options = options; if (this.$el) &#123; // 1. 创建观察者 new Observer(this.$data); // 2. 编译模版 new Compiler(this.$el, this); &#125; &#125;&#125; 项目地址https://github.com/SUNYunZeng/ImitateVue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"自己实现简单版Vue--1. 编译初始Vue模版","slug":"自己实现简单版Vue-1-编译初始Vue模版","date":"2020-01-29","updated":"2020-02-01","comments":true,"path":"自己实现简单版Vue-1-编译初始Vue模版/","link":"","permalink":"http://sunyunzeng.com/自己实现简单版Vue-1-编译初始Vue模版/","excerpt":"","text":"前言Vue的双向绑定效果如下：Vue的底层到底是怎么实现的呢？通过手写简单的示例来学习Vue框架的运行机制。Vue是MVVM框架，其实就是MVC框架在前端的体现，其中的控制器(Controller)由View MOdel(VM)代替。简单来说，数据更新视图，以及视图更新影响数据这两步操作或者是双向绑定的过程由VM来执行。而Vue就是一个VM。Vue的可以说是开箱即用，它的使用非常简单，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;person.name&#125;&#125; -- &#123;&#123;person.age&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;person.fav&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;div v-text='msg'&gt;&lt;/div&gt; &lt;div v-text='person.name'&gt;&lt;/div&gt; &lt;div v-html='htmlStr'&gt;&lt;/div&gt; &lt;input type=\"text\" v-model='msg'&gt; &lt;button v-on:click=\"handleClick\"&gt;v-on:click&lt;/button&gt; &lt;button @click=\"handleClick\"&gt;@click&lt;/button&gt; &lt;a v-bind:href=\"https://www.bilibili.com/video/av80611222?p=3\"&gt;v-bind:href&lt;/a&gt; &lt;/div&gt; &lt;script src=\"./Vue.js\"&gt;&lt;/script&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; person: &#123; name: '海贼——王路飞', age: 18, fav: '宝藏' &#125;, msg: '最简单的插值', htmlStr: '这是v-html' &#125;, methods:&#123; handleClick: function()&#123; console.log('这是一个处理点击事件的方法'); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;通过 new Vue 新建一个Vue实例，并将元素节点与该实例通过 el 实现双向绑定，之后h5中的元素内容跟对象数据就融为一体，开发者的关注重点可以集中在代码逻辑的设计，而不是繁琐的页面与数据绑定问题。我们的实现原理图如下所示：需要实现一个Observer通过Object.defineProperty()劫持数据实现数据的监听。实现一个Dep收集各数据的监听Watcher，负责通知Watcher数据发生变化。实现Watcher对视图进行更新。实现Complier对Vue指令（v-text等）进行解析初始化，以及订阅对应的watcher。 Vue模版的编译第一步是将H5中的Vue模版进行编译，使得浏览器能够正确展示对应数据。其中包括这几部分的编译：文本模版中插值表达式的编译也就是双括号中的值能够正确表达出来，例如元素节点中模版表达式的编译例如 v-text、v-model、v-html、 v-on:click、 v-bind等 MVue入口类设计Mvue类接收一个参数对象作为初始输入，然后利用Compiler类对模版进行编译及渲染。12345678910111213class MVue &#123; constructor(options) &#123; // 初始元素与数据通过options对象绑定 this.$el = options.el; this.$data = options.data; this.$options = options; // 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法 if (this.$el) &#123; new Compiler(this.$el, this); &#125; &#125;&#125; Complier编译类设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const compileUtil = &#123; getValue(expr, vm)&#123; // 处理 person.name 这种对象类型，取出真正的value return expr.split('.').reduce((data,currentVal)=&gt;&#123; return data[currentVal]; &#125;, vm.$data) &#125;, text(node, expr, vm) &#123; let value; if(expr.indexOf('&#123;&#123;')!==-1)&#123; value = expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; return this.getValue(args[1], vm); &#125;); &#125;else&#123; value = this.getValue(expr, vm); &#125; this.updater.textUpdater(node, value); &#125;, html(node, expr, vm) &#123; const value = this.getValue(expr, vm); this.updater.htmlUpdater(node, value); &#125;, model(node, expr, vm) &#123; const value = this.getValue(expr, vm); this.updater.modelUpdater(node, value); &#125;, on(node, expr, vm, detailStr) &#123; let fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr]; node.addEventListener(detailStr,fn.bind(vm), false); &#125;, bind(node, expr, vm, detailStr)&#123; // v-on:href='...' =&gt; href='...' node.setAttribute(detailStr, expr); &#125;, // 视图更新函数 updater: &#123; textUpdater(node, value) &#123; node.textContent = value; &#125;, htmlUpdater(node, value)&#123; node.innerHTML = value; &#125;, modelUpdater(node, value)&#123; node.value = value; &#125; &#125;&#125;// 编译HTML模版对象class Compiler &#123; constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 1. 将预编译的元素节点放入文档碎片对象中，避免DOM频繁的回流与重绘，提高渲染性能 const fragments = this.node2fragments(this.el); // 2. 编译模版 this.compile(fragments); // 3. 追加子元素到根元素 this.el.appendChild(fragments); &#125; compile(fragments) &#123; // 1.获取子节点 const childNodes = fragments.childNodes; // 2.递归循环编译 [...childNodes].forEach(child =&gt; &#123; // 如果是元素节点 if (this.isElementNode(child)) &#123; this.compileElement(child); &#125; else &#123; // 文本节点 this.compileText(child); &#125; //递归遍历 if(child.childNodes &amp;&amp; child.childNodes.length)&#123; this.compile(child); &#125; &#125;) &#125; compileElement(node) &#123; let attributes = node.attributes; // 对于每个属性进行遍历编译 // attributes是类数组，因此需要先转数组 [...attributes].forEach(attr =&gt; &#123; let &#123;name,value&#125; = attr; // v-text=\"msg\" v-html=htmlStr type=\"text\" v-model=\"msg\" if (this.isDirector(name)) &#123; // v-text v-html v-mode v-bind v-on:click v-bind:href='' let [, directive] = name.split('-'); let [compileKey, detailStr] = directive.split(':'); // 更新数据，数据驱动视图 compileUtil[compileKey](node, value, this.vm, detailStr); // 删除有指令的标签属性 v-text v-html等，普通的value等原生html标签不必删除 node.removeAttribute('v-' + directive); &#125;else if(this.isEventName(name))&#123; // 如果是事件处理 @click='handleClick' let [, detailStr] = name.split('@'); compileUtil['on'](node, value, this.vm, detailStr); node.removeAttribute('@' + detailStr); &#125; &#125;) &#125; compileText(node) &#123; // 编译文本中的&#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125; const content = node.textContent; if(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/.test(content))&#123; compileUtil['text'](node, content, this.vm); &#125; &#125; isEventName(attrName)&#123; // 判断是否@开头 return attrName.startsWith('@'); &#125; isDirector(attrName) &#123; // 判断是否为Vue特性标签 return attrName.startsWith('v-'); &#125; node2fragments(el) &#123; // 创建文档碎片对象 const f = document.createDocumentFragment(); let firstChild; while (firstChild = el.firstChild) &#123; f.appendChild(firstChild); &#125; return f; &#125; isElementNode(node) &#123; // 元素节点的nodeType属性为 1 return node.nodeType === 1; &#125;&#125; 项目地址https://github.com/SUNYunZeng/ImitateVue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"JS异步函数小结","slug":"JS异步函数小结","date":"2020-01-04","updated":"2020-01-11","comments":true,"path":"JS异步函数小结/","link":"","permalink":"http://sunyunzeng.com/JS异步函数小结/","excerpt":"","text":"JS的异步JavaScript的执行环境是单线程的，对于http事件触发线程、浏览器事件触发线程、浏览器定时器等浏览器会单独开辟出一个异步线程处理，处理完毕后，加入任务队列，等待JS主线程调用执行。例如：12345678setTimeout(()=&gt;console.log('触发了'),0);console.log('我先触发');// 输出/*我先触发触发了*/虽然setTimeout()被设置为马上触发，但是setTimeout触发的异步任务需先放在任务队列中，等主线程中console()函数执行完毕后，再能被触发。JavaScript执行环境(浏览器)是从头到尾一行一行往下执行，但是遇到异步任务，先放入任务队列，等待主线程可以执行该任务，才被执行。详细的JS代码执行顺序可查看 https://juejin.im/post/59e85eebf265da430d571f89异步程序在JS代码中很常见，因为Web应用总归要与远方的服务器交互，请求数据，这个过程需要异步进行。否则，浏览器会一直卡住，直到结果请求完毕。我们先看一下最简单的回调函数：setTimeout() 与 setsetInterval()，它们都是Windows对象的自带方法。 setTimeoutsetTimeout()表示指定一个异步程序，在规定的时间后执行，但不保证百分百执行。123456789// 2000ms后执行 console.log()// 方法一setTimeout(()=&gt; console.log(\"执行啦！\"), 2000)// 方法二let innerFun = function(test)&#123; console.log(test);&#125;setTimeout(innerFun, 2000, '执行啦！');如果前面有耗时的密集计算，哪怕setTimeout()设定了在很短的时间后执行，也要等主线程执行完毕，所以说 setTimeout()的延迟时间为理想时间。123456789101112// 预期1s后执行console.log()let s = Date.now();let innerFun = function()&#123; console.log((Date.now()-s)/1000);&#125;setTimeout(innerFun, 1000);let m = 0;for(let i=1; i&lt;100000;i++)&#123; for(let j =0; j&lt;i; j++) m += j;&#125;// 实际5.547后执行clearTimeout() 方法可取消由 setTimeout() 方法设置的定时操作。12let timeout = setTimeout(() =&gt; console.log(\"执行!\"), 1000);clearTimeout(timeout); setIntervalsetInterval()跟setTimeout用法类似，只不过不是执行一次，而是如果不停止就永远重复执行。123// 每1000ms执行一次setIntervallet i =0;let interval = setInterval(()=&gt;console.log(i++), 1000)clearInterval()可以清除interval操作。1clearInterval(interval);setInterval()指定的时间也是理想的时间，该时间包括程序本身的运行时间。如果程序本身运行时间大于指定时间，则setInterval()无法满足间隔时间定时运行。123456789101112let s = Date.now();innerFun = function()&#123; let m = 0; for(let i=1; i&lt;100000;i++)&#123; for(let j =0; j&lt;i; j++) m += j; &#125; console.log((Date.now() - s)/1000)&#125;setInterval(innerFun, 1000)// 每次的运行时间都远远大于1s如果你想无论程序执行多长时间，每间隔固定时间都触发程序，你可以利用setTimeout()递归实现：12345let i = 1;let run = setTimeout(function recur()&#123; console.log(i++); setTimeout(recur, 1000);&#125;, 1000);上面的程序可以保证每隔1000ms就执行console.log()方法，而不用管程序的执行时间。setTimeout() 与 setInterval()都是系统自带的基础的异步程序添加方法，可以时间指定延迟时间触发程序。旧版本JS的异步是依靠回调函数实现的，例如传统的AJAX：12345678910111213$.get('ajax/text.html', function(data)&#123; // doSomeThing&#125;)request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; return success(request.responseText); &#125; else &#123; return fail(request.status); &#125; &#125;&#125;但是回调函数之间往往存在依赖关系，即下一次回调函数的执行依赖于上一次回调函数的执行结果，然后，当这种依赖变得越来越多，代码的可读性就变得很差，此时称为“回调地狱”。12345678// callback hallchooseToppings(function(toppings) &#123; placeOrder(toppings, function(order) &#123; collectOrder(order, function(pizza) &#123; eatPizza(pizza); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback)此时还有一个问题，就是对于每个回调函数，都要重复写一个对应的 catch 失败的函数，显然是非常冗余的，因此，ES6提出了Promise方法！ PromisePromise，英语单词，承诺，就像它的名称一样，Promise对象一定会实现它的诺言，也就是执行的结果无论成功与失败，都会给你一个答复。Promise是一个构造器，可以生成Promise对象，是ES6异步编程的解决方案。1234567let promise = new Promise(function(resolve, reject) &#123; if(/*异步执行成功*/)&#123; resolve(res); &#125;else&#123; reject(new Error('error')); &#125;&#125;)Promise在异步过程中一共有三个状态，pending等待结果状态,fullfilled的执行成功状态以及rejected拒绝状态。三个状态之间转换关系为：pending状态 -&gt; fullfilled 状态pending状态 -&gt; rejected 状态pending无论转向哪两个状态都是resloved(已完成)状态。一般resolved状态表示fullfilled状态，这是习惯的写法。 Promise.then()then()方法是Promise原型对象的方法，Promise.prototype.then()。该方法接受两个参数， promise.then(onFulfilled, onRejected)，一个是异步函数执行成功的处理函数，一个是执行失败的处理函数。但是错误处理函数最好在处理语句的最后用Promise.catch()方法捕获（后面会讲到），因为可提高代码的可读性。then()方法的onFulfilled传参要求如下：必须是函数，不是函数被忽略。12345let promise = new Promise((resolve, reject) =&gt;resolve('你好'));promise.then('JS').then((result) =&gt;console.log(result));// 返回 你好，最开始的JS被忽略其参数必须是上个then()或Promise函数所返回。123456let promise = Promise.resolve('Promise返回的');let ordinal = ()=&gt;'仅仅函数返回的';promise.then((result) =&gt;console.log(result)).then(ordinal).then((result) =&gt;console.log(result));// Promise返回的// 仅仅函数返回的如果函数没有返回值，则返回 undefined12345let ordinal = ()=&gt;'仅仅函数返回的';Promise.resolve().then(function()&#123; ordinal();&#125;).then((result) =&gt;console.log(result));// undefinedthen()方法只执行一次。由上规则的值，then()存在链式法则，一系列异步操作可以通过一系列的then()方法连接。12345678chooseToppings().then(toppings =&gt; placeOrder(toppings)).then(order =&gt; collectOrder(order)).then(pizza =&gt; eatPizza(pizza)).catch(failureCallback);// 或者chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback); Promise.catchcatch()方法是Promise原型对象的方法，Promise.prototype.catch()，用来捕获错误。最佳实战：永远在then()调用链的最后使用，可以捕获异步操作的任意步骤出现的错误。1chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback); Promise.finallyfinally()方法是Promise原型对象的方法，Promise.prototype.finally()，用来最异步操作执行后（无论成功还是失败）都执行的代码。1chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback).finally(server.stop); Promise.all可以令多个Pormise并行执行，等所有的Promise都执行完毕，然后按照Promise的顺序返回一个由结果构成的Array。123456789101112131415161718192021let p1 = new Promise((resolve, reject) =&gt; &#123; resolve('成功了')&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; resolve('success')&#125;)let p3 = Promse.reject('失败')Promise.all([p1, p2]).then((result) =&gt; &#123; console.log(result) //['成功了', 'success']&#125;).catch((error) =&gt; &#123; console.log(error)&#125;)Promise.all([p1,p3,p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 失败了，打出 '失败'&#125;) Promise.resolvePromise.resolve()将现有对象转为Promise对象。123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo'))Promise的参数分为四种情况:参数是Promise实例，则依旧返回Promise实例。参数是一个 thenable 对象，则将该对象转为 Promise 对象，并立即执行。12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;);如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。123456const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three注意立即resolve的 Promise 对象是在事件循环中当前宏任务的后面添加微任务，因此需要等当前宏任务结束后再执行。12Promise.resolve().then(() =&gt; console.log(2)).then(() =&gt; console.log(3));console.log(1); // 1, 2, 3","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"LeetCode 72.编辑距离","slug":"LeetCode-72-编辑距离","date":"2020-01-02","updated":"2020-01-11","comments":true,"path":"LeetCode-72-编辑距离/","link":"","permalink":"http://sunyunzeng.com/LeetCode-72-编辑距离/","excerpt":"","text":"编辑距离给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符示例 1:123456输入: word1 = \"horse\", word2 = \"ros\"输出: 3解释: horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e')示例 2:12345678输入: word1 = \"intention\", word2 = \"execution\"输出: 5解释: intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 思路 + 代码问题1：如果 word1[0…i-1] 到 word2[0…j-1] 的变换需要消耗 k 步，那 word1[0…i] 到 word2[0…j] 的变换需要几步呢？答：先使用 k 步，把 word1[0…i-1] 变换到 word2[0…j-1]，消耗 k 步。再把 word1[i] 改成 word2[j]，就行了。如果 word1[i] == word2[j]，什么也不用做，一共消耗 k 步，否则需要修改，一共消耗 k + 1 步。问题2：如果 word1[0…i-1] 到 word2[0…j] 的变换需要消耗 k 步，那 word1[0…i] 到 word2[0…j] 的变换需要消耗几步呢？答：先经过 k 步，把 word1[0…i-1] 变换到 word2[0…j]，消耗掉 k 步，再把 word1[i] 删除，这样，word1[0…i] 就完全变成了 word2[0…j] 了。一共 k + 1 步。问题3：如果 word1[0…i] 到 word2[0…j-1] 的变换需要消耗 k 步，那 word1[0…i] 到 word2[0…j] 的变换需要消耗几步呢？答：先经过 k 步，把 word1[0…i] 变换成 word2[0…j-1]，消耗掉 k 步，接下来，再插入一个字符 word2[j], word1[0…i] 就完全变成了 word2[0…j] 了。从上面三个问题来看，word1[0…i] 变换成 word2[0…j] 主要有三种手段，用哪个消耗少，就用哪个。123456789101112131415161718192021class Solution(object): def minDistance(self, word1, word2): \"\"\" :type word1: str :type word2: str :rtype: int \"\"\" m, n = len(word1), len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m+1): dp[i][0] = i for j in range(n+1): dp[0][j] = j for i in range(1, m+1): for j in range(1, n+1): # 如果当前的字符相等，则最小操作数与dp[i-1][j-1]相同 if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))+1 return dp[m][n]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/edit-distance著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 只有两个键的键盘最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。示例 1:12345678910输入: 3输出: 3解释:最初, 我们只有一个字符 'A'。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 'AA'。第 3 步, 我们使用 Paste 操作来获得 'AAA'。说明:n 的取值范围是 [1, 1000] 。 思路 + 代码动态规划。例如 9 ，从数字 8 开始依次找其最大除数，例如是3.那么dp[9] = d[3] + 9/312345678910111213class Solution(object): def minSteps(self, n): \"\"\" :type n: int :rtype: int \"\"\" dp = [0]*(n+1) for i in range(2,n+1): for j in range(i-1, 0, -1): if i % j == 0: dp[i] = dp[j] + i//j break return dp[n]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/2-keys-keyboard著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"2020来了","slug":"2020来了","date":"2020-01-01","updated":"2020-01-11","comments":true,"path":"2020来了/","link":"","permalink":"http://sunyunzeng.com/2020来了/","excerpt":"","text":"它真的来了不知不觉，2020年悄悄咪咪的来了。回顾2019年，一言以蔽之，尚可。回首当时立下的很多 Flag，也都完成了。还不错。2019年，自己读了一些书，做了一些事，也经历了一些事。2020年，也注定是不平凡的一年。或许以后人生的轨迹，就在这仿佛平常的一年中决定或改变了。2020年，是中国全面建成小康社会关键的一年，是脱贫攻坚战的关键时期，也是我的“工作年”。2020年，愿我们，不忘初心，方得始终！","categories":[{"name":"Jottings","slug":"Jottings","permalink":"http://sunyunzeng.com/categories/Jottings/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"http://sunyunzeng.com/tags/Diary/"}]},{"title":"LeetCode 474.一和零","slug":"LeetCode-474-一和零","date":"2019-12-28","updated":"2020-01-11","comments":true,"path":"LeetCode-474-一和零/","link":"","permalink":"http://sunyunzeng.com/LeetCode-474-一和零/","excerpt":"","text":"题目在计算机界中，我们总是追求用有限的资源获取最大的收益。现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。注意:12给定 0 和 1 的数量都不会超过 100。给定字符串数组的长度不会超过 600。示例 1:1234输入: Array = &#123;\"10\", \"0001\", \"111001\", \"1\", \"0\"&#125;, m = 5, n = 3输出: 4解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 \"10\",\"0001\",\"1\",\"0\" 。示例 2:12输入: Array = &#123;\"10\", \"0\", \"1\"&#125;, m = 1, n = 1输出: 2解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。题解多维背包，动态规划方程：dp[i][j]=max(dp[i][j], dp[i-conut_0][j-count_1])1234567891011121314151617class Solution(object): def findMaxForm(self, strs, m, n): \"\"\" :type strs: List[str] :type m: int :type n: int :rtype: int \"\"\" if len(strs)==0: return 0 dp = [[0]*(n+1) for _ in range(m+1)] for item in strs: count_0, count_1 = item.count('0'), item.count('1') for i in range(m, count_0-1, -1): for j in range(n, count_1-1, -1): dp[i][j] = max(dp[i][j], dp[i-count_0][j-count_1]+1) return dp[-1][-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ones-and-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1示例 2:12输入: coins = [2], amount = 3输出: -1说明:你可以认为每种硬币的数量是无限的。题解背包问题，无限背包，从小到大遍历。12345678910111213class Solution(object): def coinChange(self, coins, amount): \"\"\" :type coins: List[int] :type amount: int :rtype: int \"\"\" dp = [float('inf')]*(amount+1) dp[0] = [0] for coin in coins: for i in range(coin, amount+1): dp[i] = min(dp[i], dp[i-coin]+1) return dp[-1] if dp[-1] != float('inf') else -1来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 零钱兑换 II给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。示例 1:1234567输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1示例 2:12输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。示例 3:12输入: amount = 10, coins = [10] 输出: 1注意:你可以假设：0 &lt;= amount (总金额) &lt;= 50001 &lt;= coin (硬币面额) &lt;= 5000硬币种类不超过 500 种结果符合 32 位符号整数题解无限背包，注意递归条件是 dp[i] += dp[i-coin]12345678910111213class Solution(object): def change(self, amount, coins): \"\"\" :type amount: int :type coins: List[int] :rtype: int \"\"\" dp = [0]*(amount+1) dp[0] = 1 for coin in coins: for i in range(coin, amount+1): dp[i] += dp[i-coin] return dp[-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change-2著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 单词拆分给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1：123输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]输出: true解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。示例 2：12输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。注意你可以重复使用字典中的单词。示例 3：12输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]输出: false题解采用动态规划 dp[i]表示 截止 s 字符串的 i 位置的子字符串是否能被单词字典里的单词来表示。dp[i]为真的条件为：dp[j]为真dp[j:i]表示的字符串存在于字典中12345678910111213141516171819202122class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\" # dp[i]表示s[i]是否可用wordDict里的元素表示 # dp[i]能够被表示的前提是dp[j]可用wordDict里元素表示，而且dp[j:i]存在于wordDict中 # 如果字典为空，字符串为空，则返回true，否则返回false if not wordDict: return not s size = len(s) dp = [False]*(size+1) wordDict = list(set(wordDict)) dp[0] = True for i in range(1, size+1): for j in range(i-1, -1, -1): if dp[j] and dp[j:i] in wordDict: dp[i] = True break return dp[-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-break著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 组合总和给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。示例:nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？题解思路与零钱兑换一模一样，代码甚至都一样12345678910111213141516class Solution(object): def combinationSum4(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if not nums: return 0 size = len(nums) dp = [0]*(target+1) dp[0] = 1 for i in range(1, target+1): for n in nums: if i&gt;=n: dp[i] += dp[i-n] return dp[-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum-iv著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 1143.最长公共子序列","slug":"LeetCode-1143-最长公共子序列","date":"2019-12-27","updated":"2020-01-11","comments":true,"path":"LeetCode-1143-最长公共子序列/","link":"","permalink":"http://sunyunzeng.com/LeetCode-1143-最长公共子序列/","excerpt":"","text":"最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。示例 1:12输入：text1 = \"abcde\", text2 = \"ace\" 输出：3解释：最长公共子序列是 “ace”，它的长度为 3。示例 2:12输入：text1 = \"abc\", text2 = \"abc\"输出：3解释：最长公共子序列是 “abc”，它的长度为 3。示例 3:12输入：text1 = \"abc\", text2 = \"def\"输出：0解释：两个字符串没有公共子序列，返回 0。提示:121 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000输入的字符串只含有小写英文字符。题解动态规划，不过要设计一个二维数组dp，来统计dp[i][j]时对应 text1 在 i 位置与text2 在 j 位置时两子字符串对应的最长公共子序列。1234567891011121314151617class Solution(object): def longestCommonSubsequence(self, text1, text2): \"\"\" :type text1: str :type text2: str :rtype: int \"\"\" l1, l2 = len(text1), len(text2) if l1==0 or l2==0: return 0 dp = [[0 for i in range(l2+1)] for i in range(l1+1)] for i in range(1,l1+1): for j in range(1,l2+1): if text1[i-1]==text2[j-1]: dp[i][j] = dp[i-1][j-1]+1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[l1][l2]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 两个字符串的删除操作(最长公共子序列的变体)给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。示例 1:输入: “sea”, “eat”输出: 2解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;说明:给定单词的长度不超过500。给定单词中的字符只含有小写字母。 思路 + 代码最长公共子序列的变体，其实就是求最长公共自序列。12345678910111213141516class Solution(object): def minDistance(self, word1, word2): \"\"\" :type word1: str :type word2: str :rtype: int \"\"\" m, n = len(word1), len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1,n+1): if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return m+n-2*dp[m][n]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-operation-for-two-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分割等和子集给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。注意:每个数组中的元素不会超过 100数组的大小不会超过 200示例 1:1234输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11].示例 2:1234输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集.题解这是一道以 0-1 背包问题为背景的算法练习题，我们把这个题目翻译一下：给定一个只包含正整数的非空数组。是否可以从这个数组中挑选出一些正整数，每个数只能用一次，使得这些数的和等于整个数组元素的和的一半。0-1 背包问题也是最基础的背包问题，它的特点是：待挑选的物品有且仅有一个，可以选择也可以不选择。下面我们定义状态，不妨就用问题的问法定义状态试试看。dp[i][j]：表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和等于 j。根据我们学习的 0-1 背包问题的状态转移推导过程，新来一个数，例如是 nums[i]，根据这个数可能选择也可能不被选择：如果不选择 nums[i]，在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；如果选择 nums[i]，在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i] ，我既然这样写出来了，你就应该知道，这里讨论的前提条件是 nums[i] &lt;= j。以上二者成立一条都行。于是得到状态转移方程是：1dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]], (nums[i] &lt;= j)于是按照 0-1 背包问题的模板，我们不难写出以下代码。1234567891011121314151617181920212223class Solution(object): def canPartition(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" size = len(nums) s = sum(nums) if s &amp; 1 == 1: return False target = s // 2 dp = [[False for _ in range(target+1)] for _ in range(size)] for i in range(target+1): if nums[0]==i: dp[0][i] = True for i in range(1,size): n = nums[i] for j in range(target+1): if j&gt;=n: dp[i][j] = dp[i-1][j] or dp[i][j-n] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]优化版：123456789101112131415161718192021class Solution(object): def canPartition(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" size = len(nums) s = sum(nums) if s &amp; 1 == 1: return False target = s // 2 dp = [False for _ in range(target+1)] for i in range(target+1): if nums[0]==i: dp[i] = True for i in range(1,size): n = nums[i] for j in range(target, n-1, -1): if j&gt;=n: dp[j] = dp[j] or dp[j-n] return dp[-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/partition-equal-subset-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 300.最长上升子序列","slug":"LeetCode-300-最长上升子序列","date":"2019-12-26","updated":"2020-01-11","comments":true,"path":"LeetCode-300-最长上升子序列/","link":"","permalink":"http://sunyunzeng.com/LeetCode-300-最长上升子序列/","excerpt":"","text":"最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。示例:123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。说明:可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?1234567891011121314class Solution(object): def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" l = len(nums) if l==0 or l==1: return l dp = [1]*l for i in range(1, l): for j in range(0, i): if nums[i]&gt;nums[j]: dp[i] = max(dp[i], dp[j]+1) return max(dp)来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-increasing-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 最长数对链给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。示例 :123输入: [[1,2], [2,3], [3,4]]输出: 2解释: 最长的数对链是 [1,2] -&gt; [3,4]注意：给出数对的个数在 [1, 1000] 范围内。更上面一题类似，只不要是任意顺序的选择，可以先对列表进行排序，按照数对的第二个数值。123456789101112131415class Solution(object): def findLongestChain(self, pairs): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" l = len(pairs) if l==0 or l==1: return l pairs = sorted(pairs, key=lambda x: x[1]) dp = [1]*l for i in range(1,l): for j in range(0, i): if pairs[i][0]&gt;pairs[j][1]: dp[i] = max(dp[i], dp[j]+1); return max(dp)来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-length-of-pair-chain著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。示例 1:123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。示例 2:123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。示例 3:12输入: [1,2,3,4,5,6,7,8,9]输出: 2算法首先计算得到差值序列，例如：1[2,5,3, 1] -&gt; [1, -2, -2]然后去重：123[2,5,3, 1] -&gt; [1, -2]// 注意：全零序列的结果为1[0,0,0] -&gt; [0]动态规划计算，dp[i]保存的是截止位置i的最长摆动序列。1234567891011121314151617181920212223242526272829303132class Solution(object): # 判断i位置的元素可以添加到j元素的尾部，构成摆动序列 def isSuccess(self, nums, i, j): if nums[i] &gt; 0 &gt; nums[j] or nums[i] &lt; 0 &lt; nums[j]: return True else: return False def wiggleMaxLength(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" l = len(nums) if l == 0 or l == 1: return l if l == 2: return 1 dp, _nums = [1] * (l - 1), [1] * (l - 1) for i in range(1, l): _nums[i - 1] = nums[i] - nums[i - 1] # 差序列去重 nums = list(set(_nums)) nums.sort(key=_nums.index) # 防止全零序列的干扰 if len(nums) == 1 and nums[0] == 0: return 1 # 动态规划求解 dp = [1] * len(_nums) for i in range(1, len(_nums)): if _nums[i] == 0: continue for j in range(0, i): if self.isSuccess(_nums, i, j): dp[i] = max(dp[i], dp[j] + 1) return max(dp) + 1来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/wiggle-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 413.等差数列划分","slug":"Leetcode-413-等差数列划分","date":"2019-12-25","updated":"2020-01-11","comments":true,"path":"Leetcode-413-等差数列划分/","link":"","permalink":"http://sunyunzeng.com/Leetcode-413-等差数列划分/","excerpt":"","text":"等差数列划分如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。例如，以下数列为等差数列:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9以下数列不是等差数列。1, 1, 2, 5, 71数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。如果满足以下条件，则称子数组(P, Q)为等差数组：1元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。函数要返回数组 A 中所有为等差数组的子数组个数。示例:A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 思路 + 代码首先对于等差序列 B, 其元素数量为n，则其包含的连续自等差序列的总数为 1+2+…+n-2,因此，该题转化为寻找序列中，最长的连续子等差序列，然后根据其数量判断。123456789101112131415class Solution: def numberOfArithmeticSlices(self, A: List[int]) -&gt; int: l = len(A) if l &lt; 3: return 0 res, count = 0, 0 for i in range(2,l): if A[i]-A[i-1] == A[i-1]-A[i-2]: count+=1 else: if count!=0: res += sum(range(count+1)) count=0 if count != 0: res += sum(range(count + 1)) return res来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/arithmetic-slices著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。说明: 你可以假设 n 不小于 2 且不大于 58。 思路 + 代码动态规划，整数4的最大乘积为: dp[3] = max(max(dp[2], dp[1]*2), 1 * 2)12345678910class Solution: def integerBreak(self, n: int) -&gt; int: if n &lt; 2: return 0 dp = [1] * (n+1) for i in range(2, n + 1): for j in range(1, i): dp[i] = max(dp[j] * (i - j), dp[i]) # 很关键的一步，因为之前的dp[i]最大值可能比dp[i]小，例如2或者3 dp[i] = max(j*(i-j), dp[i]) return dp[-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-break著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 完全平方数动态规划， 与前一题类似123456789101112131415161718192021222324import java.lang.Math;class Solution &#123; public int numSquares(int n) &#123; if(n&lt;=3) return n; int[] dp = new int[n+1]; for(int i=0;i&lt;n+1; i++)&#123; dp[i] = Integer.MAX_VALUE; &#125; for(int i=1; i&lt;=3;i++)&#123; dp[i] = i; &#125; for(int i=4; i&lt;n+1; i++)&#123; int max_n = (int)Math.sqrt(i); if(max_n*max_n==i)&#123; dp[i]=1; &#125; else&#123; for(int j=1; j&lt;=max_n; j++)&#123; dp[i] = Math.min(dp[i], dp[i-j*j]+dp[j*j]); &#125; &#125; &#125; return dp[n]; &#125;&#125;12345678910111213141516171819class Solution(object): def numSquares(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n &lt;= 3: return n dp = [sys.maxsize] * (n + 1) for i in range(1, 4): dp[i] = i for i in range(4, n + 1): max_n = int(math.sqrt(i)) if max_n * max_n == i: dp[i] = 1 else: for j in range(1, max_n + 1): dp[i] = min(dp[i], dp[i - j * j] + dp[j*j]) return dp[-1]123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;number&#125; */var numSquares = function(n) &#123; if(n&lt;=3) return n; let dp = new Array(n+1).fill(Number.MAX_VALUE); for(let i=1; i&lt;=3; i++)&#123; dp[i] = i; &#125; for(let i=4; i&lt;n+1; i++)&#123; max_n = Math.trunc(Math.sqrt(i)); if(max_n*max_n==i) dp[i]=1; else&#123; for(let j=1; j&lt;=max_n; j++)&#123; dp[i] = Math.min(dp[i], dp[i-j*j]+dp[j*j]); &#125; &#125; &#125; return dp[n];&#125;; 解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码：‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。示例 1:输入: “12”输出: 2解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。示例 2:输入: “226”输出: 3解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。**思路：**动态规划，需注意0的处理，1010的编码方式共有1种，而909编码方式为0种，202编码方式为1种。12345678910111213141516class Solution(object): def numDecodings(self, s): \"\"\" :type s: str :rtype: int \"\"\" l = len(s) if l==0 or s[0]=='0': return 0 dp = [0]*(l+1) dp[0], dp[1] = 1, 1 for i in range(2, l+1): if s[i-1]!='0': dp[i] += dp[i-1] if 9&lt;int(s[i-2:i])&lt;=26: dp[i]+=dp[i-2] return dp[-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 打家劫舍 II","slug":"LeetCode-打家劫舍 II一","date":"2019-12-23","updated":"2020-01-11","comments":true,"path":"LeetCode-打家劫舍 II一/","link":"","permalink":"http://sunyunzeng.com/LeetCode-打家劫舍 II一/","excerpt":"","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 1:123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2:1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 思路 + 代码关键是环，可以通过 0~len-2, 1~len-1分别遍历规避掉环的问题。1234567891011121314class Solution: def subRob(self, s, e, nums)-&gt;int: pre1, pre2, cur = 0, 0, 0 for i in range(s,e): cur = max(pre1, pre2+nums[i]) pre2 = pre1 pre1 = cur return cur def rob(self, nums: List[int]) -&gt; int: l = len(nums) if l==0: return 0 if l==1: return nums[0] if l==2: return max(nums[0], nums[1]) return max(self.subRob(0, l-1, nums), self.subRob(1, l, nums))来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(六): ECharts实现轨迹动态可视化","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-六-ECharts实现轨迹动态可视化","date":"2019-12-23","updated":"2020-01-11","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-六-ECharts实现轨迹动态可视化/","link":"","permalink":"http://sunyunzeng.com/Vue-Express-MySQL驾驶行为分析全栈项目-六-ECharts实现轨迹动态可视化/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。项目地址可视化效果轨迹的动态可视化预期效果可以参考: https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect ECharts准备首先安装EChart组件1npm install echarts --save然后在 Vue 的 main.js 文件中引入百度地图依赖1require('echarts/extension/bmap/bmap'); 封装百度地图轨迹可视化模块我们将百度地图轨迹可视化单独包装成一个模块 EChartsMap.vue，该模块作用是接收父模块传来的可视化数据及设置参数，实现对应的可视化效果。首先创建界面模版：1234567891011&lt;template&gt; &lt;div class=\"bmap\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.bmap&#123; width: 100%; height: calc(78vh); position: relative;&#125;&lt;/style&gt;然后在 script 标签中引入逻辑代码1234567891011121314151617181920212223242526272829303132import store from '@/store';// 引入ECharts组件 let echarts = require('echarts'); export default &#123; name: 'EChartsMap', props: ['option'], watch:&#123; option: function (option) &#123; this.myChart.setOption(option); &#125; &#125;, data()&#123; return &#123; myChart: null &#125; &#125;, mounted()&#123; this.draw(); &#125;, methods: &#123; draw () &#123; this.myChart = echarts.init(this.$el); this.myChart.setOption(&#123; bmap:&#123; center: [114.03, 22.32], zoom: 10, roam: true, mapStyle: store.state.mapStyle &#125;&#125;); &#125;, &#125; &#125;;这样子，我们父组件通过子组件的 option 属性进行 ECharts 可视化的配置。然后子模块通过设置watch监听，实现可视化效果的随父模块数据的动态更新。我们的ECharts需要在模版渲染成HTML界面后引入，所以在 mounted() 函数中使用。 轨迹动态可视化首先我们通过样例：https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect 知道轨迹动态可视化的数据组织形式:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 busLines = [&#123;coords: [[114,25],[115,26], [117,28]...[lng, lat]], lineStyle: &#123; normal: &#123; color: echarts.color.modifyHSL('#5A94DF') &#125; &#125;&#125;, &#123;coords: [[114,25],[115,26], [117,28]...[lng, lat]], lineStyle: &#123; normal: &#123; color: echarts.color.modifyHSL('#5A94DF') &#125; &#125;&#125;] myChart.setOption(option = &#123; // 百度底图设置 bmap: &#123; center: [116.46, 39.92], zoom: 10, roam: true, mapStyle: &#123; 'styleJson': [ ...] &#125; &#125;, series: [ // 基础线条设置 &#123; type: 'lines', coordinateSystem: 'bmap', polyline: true, data: busLines, silent: true, lineStyle: &#123; normal: &#123; opacity: 0.2, width: 1 &#125; &#125;, progressiveThreshold: 500, progressive: 200 &#125;, // 线上动态点效果设置 &#123; type: 'lines', coordinateSystem: 'bmap', polyline: true, data: busLines, lineStyle: &#123; normal: &#123; width: 0 &#125; &#125;, effect: &#123; constantSpeed: 20, show: true, trailLength: 0.1, symbolSize: 1.5 &#125;, zlevel: 1 &#125;] &#125;);&#125;);通过数据分析发现，我们的轨迹数据只要组织成 busLines (其中设定了轨迹点序列、及轨迹颜色)，然后在ECharts 底图设定 bmap 及数据设定 series 里面将 基础线条设置 与 线上动态点效果设置 按照自己喜欢的样式设计好即可。然后在父模块中先引入EChartMap.vue模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;template&gt; &lt;div&gt; &lt;Button type=\"primary\" @click=\"handleSubmit\"&gt;展示&lt;/Button&gt; &lt;EChartsMap :option=\"option\"&gt;&lt;/EChartsMap&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import EChartsMap from '@/components/commom/EChartsMap'; export default &#123; name: 'prediction', data () &#123; return &#123; bmap: &#123; center: this.$store.state.mapconfig.center, boundingCoords: [], zoom: 15, roam: true, mapStyle: store.state.mapStyle &#125;, option: &#123; bmap: this.bmap, tooltip: &#123; trigger: 'item' &#125;, series: [] &#125;, myChart: null, lines: &#123; coords: [], lineStyle: &#123; normal: &#123; color: 'orange' &#125; &#125; &#125;, lines_option: &#123; type: 'lines', coordinateSystem: 'bmap', polyline: true, data: [], silent: true, lineStyle: &#123; normal: &#123; opacity: 0.75, width: 3 &#125; &#125;, progressiveThreshold: 500, progressive: 200 &#125;, lines_state: &#123; type: 'lines', coordinateSystem: 'bmap', polyline: true, data: [], lineStyle: &#123; normal: &#123; width: 0 &#125; &#125;, effect: &#123; constantSpeed: 40, show: true, trailLength: 0.3, symbolSize: 3.5 &#125;, zlevel: 1 &#125; &#125;, mounted () &#123; &#125;, methods: &#123; // 异步数据处理 handleSubmit () &#123; this.$axios.post().then((data) =&gt; &#123; draw(data); &#125;) &#125;, // 数据可视化函数 draw (trajectory) &#123; this.lines.coords = trajectory; this.lines_option.data = [this.lines]; this.lines_state.data = [this.lines]; let series = [this.lines_option, this.lines_state]; this.option = &#123; bmap: this.bmap, tooltip: &#123; trigger: 'item' &#125;, series: series &#125;;; &#125;, &#125;, components: &#123; EChartsMap &#125; &#125;;&lt;/script&gt;完整代码请查看：https://github.com/SUNYunZeng/AIforDriving/blob/master/src/views/Prediction.vue","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"LeetCode 524.通过删除字母匹配到字典里最长单词","slug":"LeetCode-524-通过删除字母匹配到字典里最长单词","date":"2019-12-21","updated":"2020-01-11","comments":true,"path":"LeetCode-524-通过删除字母匹配到字典里最长单词/","link":"","permalink":"http://sunyunzeng.com/LeetCode-524-通过删除字母匹配到字典里最长单词/","excerpt":"","text":"题目给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。示例 1:12345输入:s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]输出: \"apple\"1234567示例 2:输入:s = \"abpcplea\", d = [\"a\",\"b\",\"c\"]输出: \"a\"说明:所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。 思路 + 代码快慢指针判断是否在字符串里面12345678910111213141516171819202122232425262728293031class Solution: def isInWord(self, a, b) -&gt; bool: i, j = 0, len(b)-1 m, n = 0, len(a)-1 while i &lt;= j: if m &gt; n: return False if a[m]==b[i]: m+=1 i+=1 else: while m&lt;=n and a[m]!=b[i]: m+=1 if m &gt; n and i&lt;=j: return False if a[n]==b[j]: n-=1 j-=1 else: while m&lt;=n and a[n]!=b[j]: n-=1 if m &gt; n and i&lt;=j: return False return True def findLongestWord(self, s: str, d: List[str]) -&gt; str: if len(s)==0 or len(d)==0: return \"\" res=\"\" for i in range(len(d)): if self.isInWord(s, d[i]): if len(d[i])&gt;len(res): res = d[i] elif len(d[i])==len(res) and d[i]&lt;res: res = d[i] return res来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 763. 划分字母区间","slug":"LeetCode-763-划分字母区间","date":"2019-12-20","updated":"2020-01-11","comments":true,"path":"LeetCode-763-划分字母区间/","link":"","permalink":"http://sunyunzeng.com/LeetCode-763-划分字母区间/","excerpt":"","text":"题目字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。示例1：123456输入: S = \"ababcbacadefegdehijhklij\"输出: [9,7,8]解释:划分结果为 \"ababcbaca\", \"defegde\", \"hijhklij\"。每个字母最多出现在一个片段中。像 \"ababcbacadefegde\", \"hijhklij\" 的划分是错误的，因为划分的片段数较少。注意：12S的长度在[1, 500]之间。S只包含小写字母'a'到'z'。 思路 + 代码贪心算法。统计每个字母出现的最后位置，最优分割是该区间内任意一个字母的最大位置都包括在内。1234567891011class Solution: def partitionLabels(self, S: str) -&gt; List[int]: dic = &#123;c:i for i, c in enumerate(S)&#125; j, anchor = 0, 0 res = [] for i, c in enumerate(S): j = max(j, dic[c]) if i==j: res.append(i-anchor+1) anchor = i+1 return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Greedy Algorithm","slug":"Greedy-Algorithm","permalink":"http://sunyunzeng.com/tags/Greedy-Algorithm/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(五): Leftlet热力图实现","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-五-Leftlet热力图实现","date":"2019-12-14","updated":"2020-01-11","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-五-Leftlet热力图实现/","link":"","permalink":"http://sunyunzeng.com/Vue-Express-MySQL驾驶行为分析全栈项目-五-Leftlet热力图实现/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。项目地址可视化效果 Leftlet底图模块构建需要安装的依赖库与样式查看Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能。在 src/components/common 文件夹下添加 LeftletMap.vue文件，作为Leftlet地图的基础模块。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// LeftletMap.vue&lt;template&gt; &lt;div class=\"map\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'LeftletMap', data: function () &#123; return &#123; L: null, map: null, map_config: this.store.state.map_config &#125;; &#125;, methods: &#123; initMap () &#123; this.L = L; let map = L.map(this.$el, &#123; center: this.map_config.center, zoom: this.map_config.zoom &#125;); this.map = map; let baseLayer = L.tileLayer('https://api.tiles.mapbox.com/v4/&#123;id&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?' + 'access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', &#123; id: this.store.state.layerItems['box_d'], minZoom: 3 &#125;); map.addLayer(baseLayer); &#125; &#125;, mounted () &#123; this.initMap(); &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .map &#123; width: 100%; height: calc(88vh); position: relative; &#125;&lt;/style&gt;其中 this.state 是用Vuex插件定义的全局状态变量，其本身是 src/store/index.js文件中定义的一个对象，在其中我们定义了各种地图的配置选项。具体内容可查看Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能。 热力图实现首先安装leftlet热力图插件 leaflet-heatmap。1npm i leaflet-heatmap --save然后在src/views/ 文件夹下创建 ODpoint.vue 文件，该组件是对轨迹的O-D(Origin-Destination)点进行热力图分析。123456789101112131415161718192021222324252627282930&lt;!-- ODpoint.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;Form ref=\"formInline\" inline&gt; &lt;FormItem&gt; 测试用户: &lt;Select v-model=\"user\" clearable style=\"width:70px\"&gt; &lt;Option value=\"user1\"&gt;User1&lt;/Option&gt; &lt;Option value=\"user2\"&gt;User2&lt;/Option&gt; &lt;Option value=\"user3\"&gt;User3&lt;/Option&gt; &lt;Option value=\"user4\"&gt;User4&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt; &lt;FormItem&gt;&lt;b&gt;出发时间:&lt;/b&gt;&lt;/FormItem&gt; &lt;FormItem&gt; &lt;DatePicker v-model=\"time_range\" :start-date=\"new Date('2018-01-01 00:00:00')\" type=\"datetimerange\" style=\"width: 300px\"&gt;&lt;/DatePicker&gt; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;CheckboxGroup v-model=\"ODSelectoin\"&gt; &lt;Checkbox label=\"origin\"&gt;&lt;/Checkbox&gt; &lt;Checkbox label=\"destination\"&gt;&lt;/Checkbox&gt; &lt;/CheckboxGroup&gt; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button type=\"primary\" @click=\"show\"&gt;展示&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;Map style=\"height: calc(78vh);\" ref=\"leftletMap\"&gt;&lt;/Map&gt; &lt;/div&gt;&lt;/template&gt;然后定义展示的逻辑js代码。一些问题可以参考文章：https://blog.frytea.com/archives/41/。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 引入LeftletMap子模块import Map from '@/components/commom/LeftletMap';import HeatmapOverlay from 'heatmap.js/plugins/leaflet-heatmap';import &#123;post, get&#125; from '@/utils/myAjax';import &#123;points_factory&#125; from '@/utils/traj-handler'export default &#123; name: 'od', data () &#123; return &#123; user: 'user1', time_range: ['2018-01-01 00:00:00', '2018-01-31:00:00:00'], ODSelectoin: ['origin'], heatmapLayer: null, cfg: &#123; 'radius': 0.005, 'maxOpacity': 0.8, 'scaleRadius': true, 'useLocalExtrema': true, latField: 'lat', lngField: 'lng', valueField: 'eff' &#125; &#125;; &#125;, mounted () &#123; this.initHeatMap(); &#125;, components: &#123; Map &#125;, methods: &#123; show () &#123; if (this.ODSelectoin.length === 0 || this.user === undefined) &#123; this.$Message.info('请配置参数'); return null; &#125; if (this.$isOnServer) &#123; post('searchByRow', &#123; rowName: ['origin', 'destination', 'norm_dict', 'o_eff', 'd_eff'], time: this.time_range, tableName: this.user &#125;).then(data =&gt; &#123; if (data.length &gt; 0) &#123; let res = points_factory(data, this.ODSelectoin); this.heatmapLayer.setData(res.data); this.$refs.leftletMap.map.setView(res.center, 10); &#125; else &#123; this.$Message.info('空数据'); &#125; &#125;); &#125; else &#123; get('../static/data/' + this.user + '.json').then(data =&gt; &#123; if (data.RECORDS.length &gt; 0) &#123; let basket = []; let record = data.RECORDS; for (let item of record) &#123; let tmp_date = new Date(item['time']); if (tmp_date &gt;= this.time_range[0] &amp;&amp; tmp_date &lt;= this.time_range[1]) &#123; basket.push(item); &#125; &#125; let res = points_factory(basket, this.ODSelectoin); this.heatmapLayer.setData(res.data); this.$refs.leftletMap.map.setView(res.center, 10); &#125; else &#123; this.$Message.info('空数据'); &#125; &#125;); &#125; &#125;, initHeatMap () &#123; this.heatmapLayer = new HeatmapOverlay(this.cfg); this.heatmapLayer.addTo(this.$refs.leftletMap.map); L.control.scale(&#123; maxWidth: 200, metric: true, imperial: false &#125;).addTo(this.$refs.leftletMap.map); &#125; &#125;&#125;;最后，预览效果：http://geoai.sunyunzeng.com/#/od","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-四-Leftlet组件与图层加载功能","date":"2019-12-14","updated":"2020-01-11","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-四-Leftlet组件与图层加载功能/","link":"","permalink":"http://sunyunzeng.com/Vue-Express-MySQL驾驶行为分析全栈项目-四-Leftlet组件与图层加载功能/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。项目地址可视化效果 准备工作首先下载安装 leftlet。1npm install leaflet --save然后在全局入口 main.js 文件中引入leftlet，包括样式文件123456// 引入插件与样式import * as L from 'leaflet';import 'leaflet/dist/leaflet.css';// 全局注册Vue.L = Vue.prototype.$L = L;安装leftlet地图图层的加载插件-- leaflet.chinatmsproviders1npm i leaflet.chinatmsproviders --save123import * as Provider from 'leaflet.chinatmsproviders';Vue.Provider = Vue.prototype.$Provider = Provider;然后引入1npm i leaflet.chinatmsproviders再安装iView插件。1npm install iview --save然后在全局入口 main.js 文件中引入iview插件及样式123import iView from 'iview';Vue.use(iView);main.js文件1234567891011121314151617181920212223242526// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue';import App from '@/App';import router from '@/router';import iView from 'iview';import store from '@/store';import 'leaflet/dist/leaflet.css';import 'iview/dist/styles/iview.css'import '@/permission';import * as L from 'leaflet';import * as Provider from 'leaflet.chinatmsproviders';// 全局注册Vue.use(iView);Vue.L = Vue.prototype.$L = L;Vue.Provider = Vue.prototype.$Provider = Provider;/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App) // 相当于 components: &#123; App &#125; vue1.0的写法&#125;); 界面展示逻辑然后定义我们的页面展示逻辑。首先在 src/views/ 文件夹下创建 Home.vue 文件。然后定义界面组件，包括返回home按钮与下拉图层选择选项。12345678910111213141516171819202122232425262728293031323334353637&lt;!-- Home.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div id=\"map\"&gt;&lt;/div&gt; &lt;Button id=\"map_home\" class=\"rightmenu\" @click=\"returnHome\" icon=\"ios-home\" type=\"primary\" shape=\"circle\" title=\"home\"&gt;&lt;/Button&gt; &lt;Dropdown class=\"rightmenu\" style=\"margin-left: 20px\" placement=\"bottom-end\"&gt; &lt;Button type=\"primary\"&gt; &#123;&#123;msg&#125;&#125; &lt;Icon type=\"ios-arrow-down\"&gt;&lt;/Icon&gt; &lt;/Button&gt; &lt;DropdownMenu slot=\"list\"&gt; &lt;DropdownItem @click.native=\"mapSet('gd')\"&gt;高德地图&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=\"mapSet('glg')\"&gt;谷歌地图&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=\"mapSet('box')\"&gt;MapBox&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=\"mapSet('osm')\"&gt;OSM地图&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=\"mapSet('geo')\"&gt;智图&lt;/DropdownItem&gt; &lt;/DropdownMenu&gt; &lt;/Dropdown&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; #map &#123; width: 100%; height: calc(88vh); position: relative; &#125; .rightmenu&#123; position: absolute; top: 30px; right: 70px; z-index: 1000; &#125; #map_home&#123; right: 30px; &#125;&lt;/style&gt; 功能实现逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Home.vue &lt;script&gt; import store from '@/store'; export default &#123; name: 'home', data () &#123; return &#123; map: null, L: null, baseLayer: null, msg: '高德地图', map_config: &#123; zoom: 15, center: [30.541093, 114.360734], minZoom: 2, maxZoom: 18 // key: \"eb35dddb3aa33c7a8fb4218b39d1e424\" 天地图key &#125; &#125;; &#125;, mounted () &#123; this.initMap(); &#125;, methods: &#123; initMap () &#123; this.L = L; let map = L.map(\"map\", &#123; center: this.map_config.center, zoom: this.map_config.zoom &#125;); this.map = map; this.addLayer(L, map, store.state.layerItems['gd_n_a'],18, 3); &#125;, addLayer (L, map, layer_name, maxZoom, minZoom) &#123; if (this.baseLayer !== null) &#123; map.removeLayer(this.baseLayer); &#125; this.baseLayer = L.tileLayer.chinaProvider(layer_name, &#123; maxZoom: maxZoom === undefined ? this.map_config.maxZoom : maxZoom, minZoom: minZoom === undefined ? this.map_config.minZoom : minZoom &#125;); map.addLayer(this.baseLayer); &#125;, returnHome () &#123; this.map.setView(this.map_config.center, 15); &#125;, mapSet (map_name, L = this.L, map = this.map) &#123; switch (map_name) &#123; case 'gd': this.addLayer(L, map, store.state.layerItems['gd_n_a'], 18, 3); this.msg = '高德地图 '; break; case 'glg': this.addLayer(L, map, store.state.layerItems['glg_n']); this.msg = '谷歌地图 '; break; case 'geo': this.addLayer(L, map, store.state.layerItems['geo_n_g'], 16); this.msg = ' 智图 '; break; case 'osm': this.addLayer(L, map, store.state.layerItems['osm']); this.msg = 'OSM地图'; break; case 'box': if (this.baseLayer !== null) &#123; map.removeLayer(this.baseLayer); &#125; this.baseLayer = L.tileLayer('https://api.tiles.mapbox.com/v4/&#123;id&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?' + 'access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', &#123; id: store.state.layerItems['box'], minZoom: 3 &#125;); map.addLayer(this.baseLayer); this.msg = 'Mapbox'; break; default: break; &#125; &#125;, &#125;, &#125;&lt;/script&gt;其中 this.state 是用Vuex插件定义的全局状态变量，其本身是 src/store/index.js文件中定义的一个对象，在其中我们定义了各种地图的配置选项。123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/store/index.jsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; // 底图数据 layerItems: &#123; 'tdt_n': 'TianDiTu.Normal.Map', 'tdt_n_a': 'TianDiTu.Normal.Annotion', 'tdt_s': 'TianDiTu.Satellite.Map', 'tdt_s_a': 'Satellite.Annotion', 'gd_n_a': 'GaoDe.Normal.Map', 'gd_s': 'GaoDe.Satellite.Map', 'gd_s_a': 'GaoDe.Satellite.Annotion', 'glg_n': 'Google.Normal.Map', 'glg_s': 'Google.Satellite.Map', 'geo_n': 'Geoq.Normal.Map', 'geo_n_p': 'Geoq.Normal.PurplishBlue', 'geo_n_g': 'Geoq.Normal.Gray', 'geo_n_w': 'Geoq.Normal.Warm', 'geo_n_h': 'Geoq.Normal.Hydro', 'osm': 'OSM.Normal.Map', 'box_d': 'mapbox.dark', 'box_l': 'mapbox.light', 'box': 'mapbox.streets' &#125;, //地图配置 mapconfig: &#123; zoom: 15, center: [30.541093, 114.360734], minZoom: 2, maxZoom: 18 &#125; &#125;, mutations: &#123; setMap(state, key, value) &#123; state.mapconfig[key] = value; &#125; &#125;&#125;);export default store;然后基于Leftlet的图层切换与返回指定位置功能就实现啦，预览：http://geoai.sunyunzeng.com/#/home","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(三): 前端设计","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-三-前端设计","date":"2019-12-12","updated":"2020-01-11","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-三-前端设计/","link":"","permalink":"http://sunyunzeng.com/Vue-Express-MySQL驾驶行为分析全栈项目-三-前端设计/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。项目地址可视化效果 前端结构设计下图是整个项目的结构，也就是采用Vue-cli脚手架搭建的前端项目结构buile 文件夹存放项目构建脚本。config 文件夹存放项目的配置信息，包括webpack配置及端口转发等。dist/docs 文件夹存放的是项目构建后的内容，即编译出的项目代码。node_modules 这个目录存放的是项目的所有依赖，即 npm install 命令下载下来的文件。server 文件夹存放的是服务器相关代码与数据。src 存放前端项目的源码。static 存放项目的静态资源。index.html 项目的入口页，也是唯一的HTML页面。package.json 定义了项目的所有依赖，包括开发时依赖和发布时依赖。其中前端开发的大多工作是在 src 文件夹下进行的，它的目录结构如下：assets 文件夹存放资产文件。components 文件夹存放项目公共的组件(.vue文件)。lib 文件夹存放的是第三方库暴露出来的接口。router 存放前端界面的路由逻辑js文件。store 文件夹存放的是全局共享的变量。utils 存放辅助函数脚本。view 存放项目各独立界面(.vue文件)。App.vue 一个vue组件，是第一个vue组件。main.js 定义了项目启动的入口。permission.js 界面初始化工作，包括动态界面的加载。 界面模版前端界面模版是基于 vue-admin-template修改的，去除了登录功能，精简了界面逻辑。界面模版最大的特点可以实现菜单栏的个性定制。首先在 src/components/Index.vue文件夹内，定义动态菜单栏。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;template&gt; &lt;div class=\"index-vue\"&gt; &lt;!-- 侧边栏 --&gt; &lt;aside :class=\"asideClassName\"&gt; &lt;!-- logo --&gt; &lt;div class=\"logo-c pointer\" @click=\"isShrinkAside\" title=\"收缩/展开\"&gt; &lt;img src=\"../assets/imgs/logo.png\" alt=\"logo\" class=\"logo\"&gt; &lt;span v-show=\"isShowAsideTitle\"&gt;驾驶分析系统&lt;/span&gt; &lt;/div&gt; &lt;!-- 菜单栏 --&gt; &lt;Menu class=\"menu\" ref=\"asideMenu\" theme=\"dark\" width=\"100%\" @on-select=\"gotoPage\" accordion :open-names=\"openMenus\" :active-name=\"currentPage\" @on-open-change=\"menuChange\"&gt; &lt;!-- 动态菜单 --&gt; &lt;div v-for=\"(item, index) in menuItems\" :key=\"index\"&gt; &lt;Submenu v-if=\"item.children\" :name=\"index\"&gt; &lt;template slot=\"title\"&gt; &lt;Icon :size=\"item.size\" :type=\"item.type\"/&gt; &lt;span v-show=\"isShowAsideTitle\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;div v-for=\"(subItem, i) in item.children\" :key=\"index + i\"&gt; &lt;Submenu v-if=\"subItem.children\" :name=\"index + '-' + i\"&gt; &lt;template slot=\"title\"&gt; &lt;Icon :size=\"subItem.size\" :type=\"subItem.type\"/&gt; &lt;span v-show=\"isShowAsideTitle\"&gt;&#123;&#123;subItem.text&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;MenuItem class=\"menu-level-3\" v-for=\"(threeItem, k) in subItem.children\" v-if=\"!threeItem.hidden\" :name=\"threeItem.name\" :key=\"index + i + k\"&gt; &lt;Icon :size=\"threeItem.size\" :type=\"threeItem.type\"/&gt; &lt;span v-show=\"isShowAsideTitle\"&gt;&#123;&#123;threeItem.text&#125;&#125;&lt;/span&gt; &lt;/MenuItem&gt; &lt;/Submenu&gt; &lt;MenuItem v-else-if=\"!subItem.hidden\" :name=\"subItem.name\"&gt; &lt;Icon :size=\"subItem.size\" :type=\"subItem.type\"/&gt; &lt;span v-show=\"isShowAsideTitle\"&gt;&#123;&#123;subItem.text&#125;&#125;&lt;/span&gt; &lt;/MenuItem&gt; &lt;/div&gt; &lt;/Submenu&gt; &lt;MenuItem v-else-if=\"!item.hidden\" :name=\"item.name\"&gt; &lt;Icon :size=\"item.size\" :type=\"item.type\"/&gt; &lt;span v-show=\"isShowAsideTitle\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt; &lt;/MenuItem&gt; &lt;/div&gt; &lt;/Menu&gt; &lt;/aside&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'index', data () &#123; return &#123; // 用于储存页面路径 paths: &#123;&#125;, // 当前显示页面 currentPage: '', openMenus: [], // 要打开的菜单名字 name属性 menuCache: [], // 缓存已经打开的菜单 showLoading: false, // 是否显示loading isShowRouter: true, isShowAsideTitle: true, // 是否展示侧边栏内容 main: null, // 页面主要内容区域 asideClassName: 'aside-big', // 控制侧边栏宽度变化 asideArrowIcons: [], // 缓存侧边栏箭头图标 收缩时用 &#125;; &#125;, created () &#123; // 已经为ajax请求设置了loading 请求前自动调用 请求完成自动结束 // 添加请求拦截器 this.$axios.interceptors.request.use(config =&gt; &#123; this.showLoading = false; // 在发送请求之前做些什么 return config; &#125;, error =&gt; &#123; this.showLoading = false; // 对请求错误做些什么 return Promise.reject(error); &#125;); // 添加响应拦截器 this.$axios.interceptors.response.use(response =&gt; &#123; // 可以在这里对返回的数据进行错误处理 如果返回的 code 不对 直接报错或退出登陆 // 就可以省去在业务代码里重复判断 // 例子 // if (res.code != 0) &#123; // this.$Message.error(res.msg) // return Promise.reject() // &#125; this.showLoading = false; const res = response.data; return res; &#125;, error =&gt; &#123; this.showLoading = false; // 对响应错误做点什么 return Promise.reject(error); &#125;); &#125;, mounted () &#123; // 第一个标签 const name = this.$route.name; this.currentPage = name; // 根据路由打开对应的菜单栏 this.openMenus = this.getMenus(name); this.$nextTick(() =&gt; &#123; this.$refs.asideMenu.updateOpened(); &#125;); this.main = document.querySelector('.sec-right'); this.asideArrowIcons = document.querySelectorAll('aside .ivu-icon-ios-arrow-down'); // 监听窗口大小 自动收缩侧边栏 this.monitorWindowSize(); &#125;, watch: &#123; $route (to) &#123; const name = to.name; this.currentPage = name; &#125; &#125;, computed: &#123; // 菜单栏 menuItems () &#123; return this.$store.state.menuItems; &#125;, // 由于iView的导航菜单比较坑 只能设定一个name参数 // 所以需要在这定义组件名称和标签栏标题的映射表 有多少个页面就有多少个映射条数 nameToTitle () &#123; const obj = &#123;&#125;; this.menuItems.forEach(e =&gt; &#123; this.processNameToTitle(obj, e); &#125;); return obj; &#125;, &#125;, methods: &#123; getMenus (name) &#123; let menus; const tagTitle = this.nameToTitle[name]; for (let i = 0, l = this.menuItems.length; i &lt; l; i++) &#123; const item = this.menuItems[i]; menus = []; menus[0] = i; if (item.text == tagTitle) &#123; return menus; &#125; if (item.children) &#123; for (let j = 0, ll = item.children.length; j &lt; ll; j++) &#123; const child = item.children[j]; menus[1] = i + '-' + j; menus.length = 2; if (child.text == tagTitle) &#123; return menus; &#125; if (child.children) &#123; for (let k = 0, lll = child.children.length; k &lt; lll; k++) &#123; const grandson = child.children[k]; menus[2] = i + '-' + j + '-' + k; if (grandson.text == tagTitle) &#123; return menus; &#125; &#125; &#125; &#125; &#125; &#125; &#125;, monitorWindowSize () &#123; let w = document.documentElement.clientWidth || document.body.clientWidth; if (w &lt; 1300) &#123; this.shrinkAside(); &#125; window.onresize = () =&gt; &#123; // 可视窗口宽度太小 自动收缩侧边栏 if (w &lt; 1300 &amp;&amp; this.isShowAsideTitle &amp;&amp; w &gt; (document.documentElement.clientWidth || document.body.clientWidth)) &#123; this.shrinkAside(); &#125; w = document.documentElement.clientWidth || document.body.clientWidth; &#125;; &#125;, // 判断当前标签页是否激活状态 isActive (name) &#123; return this.$route.name === name; &#125;, // 判断 isShrinkAside () &#123; this.isShowAsideTitle ? this.shrinkAside() : this.expandAside(); &#125;, // 收缩 shrinkAside () &#123; this.asideArrowIcons.forEach(e =&gt; &#123; e.style.display = 'none'; &#125;); this.isShowAsideTitle = false; this.openMenus = []; this.$nextTick(() =&gt; &#123; this.$refs.asideMenu.updateOpened(); &#125;); setTimeout(() =&gt; &#123; this.asideClassName = ''; this.main.style.width = 'calc(100% - 80px)'; &#125;, 0); &#125;, // 展开 expandAside () &#123; setTimeout(() =&gt; &#123; this.isShowAsideTitle = true; this.asideArrowIcons.forEach(e =&gt; &#123; e.style.display = 'block'; &#125;); this.openMenus = this.menuCache; this.$nextTick(() =&gt; &#123; this.$refs.asideMenu.updateOpened(); &#125;); &#125;, 200); this.asideClassName = 'aside-big'; this.main.style.width = 'calc(100% - 220px)'; &#125;, // 菜单栏改变事件 menuChange (data) &#123; this.menuCache = data; &#125;, processNameToTitle (obj, data, text) &#123; if (data.name) &#123; obj[data.name] = data.text; this.paths[data.name] = text ? `$&#123;text&#125; / $&#123;data.text&#125;` : data.text; &#125; if (data.children) &#123; data.children.forEach(e =&gt; &#123; this.processNameToTitle(obj, e, text ? `$&#123;text&#125; / $&#123;data.text&#125;` : data.text); &#125;); &#125; &#125; &#125; &#125;;&lt;/script&gt;任务栏是根据 this.$store.state.menuItems 定义的内容循环更新，包括子任务栏，其定义在src/store/index.js文件内，需利用Vuex状态管理插件。1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; // 左侧菜单栏数据 menuItems: [ &#123; name: 'home', // 要跳转的路由名称 不是路径 size: 22, // icon大小 type: 'md-home', // icon类型 text: '主页', // 文本内容 &#125; &#123; text: '数据视图', type: 'md-globe', size: 22, children: [ &#123; text: '可视化', type: 'ios-eye', size: 20, children: [ &#123; type: 'logo-steam', name: 'trajectory', text: '轨迹' &#125; ] &#125; ] &#125; ], &#125;, mutations: &#123; setMenus (state, items) &#123; state.menuItems = [...items]; &#125; &#125;&#125;);export default store;然后在src/router/index.js文件中定义每个组件的路由规则。12345678910111213141516171819202122232425262728293031323334353637import Vue from 'vue';import Router from 'vue-router';Vue.use(Router);export const commonRouters = [ &#123; path: '/', redirect: 'home' &#125;];// 需要动态定制的任务栏，包括子任务栏export const asyncRouters = &#123; 'home': &#123; path: 'home', name: 'home', component: () =&gt; import('@/views/Home.vue') &#125;, 'trajectory': &#123; path: 'trajectory', name: 'trajectory', component: () =&gt; import('@/views/Trajectory.vue') &#125;&#125;;const createRouter = () =&gt; new Router(&#123; routes: commonRouters&#125;);export function resetRouter () &#123; const newRouter = createRouter(); router.matcher = newRouter.matcher;&#125;const router = createRouter();export default router;然后在 src/views 文件夹下定义对应路口的界面vue组件。1234567891011121314151617181920212223242526272829// Home.vue&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; export default &#123; name: 'home' &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;// Trajectory.vue&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; export default &#123; name: 'home' &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;之后，在src/permission.js文件中，定义界面初始化逻辑：12345678910111213141516171819202122232425import router from '@/router'import store from '@/store'import &#123;menusToRouters&#125; from '@/utils';import &#123;LoadingBar&#125; from 'iview'let hasMenus = false;router.beforeEach(async (to, from, next)=&gt;&#123; LoadingBar.start(); if(hasMenus)&#123; next() &#125;else&#123; try&#123; const routers = menusToRouters(store.state.menuItems); router.addRoutes(routers); hasMenus = true; next(&#123;path: to.path || '/'&#125;); &#125;catch (e) &#123; console.log(e.toString()); &#125; &#125;&#125;);router.afterEach(()=&gt;&#123; LoadingBar.finish()&#125;);其中 menusToRouters 方法是将定义的任务栏转化为对应的router对象：12345678910111213141516171819202122232425262728293031323334import &#123;asyncRouters&#125; from '@/router';export function menusToRouters (data) &#123; const res = []; const children = []; res.push(&#123; path: '/', component: () =&gt; import('@/components/Index.vue'), children, &#125;); data.forEach(item =&gt; &#123; generateRouters(children, item); &#125;); children.push(&#123; path: 'error', name: 'error', component: () =&gt; import('@/components/Error.vue') &#125;); return res;&#125;function generateRouters (children, item) &#123; if (item.name) &#123; children.push(asyncRouters[item.name]); &#125; else if (item.children) &#123; item.children.forEach(e =&gt; &#123; generateRouters(children, e); &#125;); &#125;&#125;最后，在入口文件 src/main.js 文件中导入permission.js文件：1234567891011121314151617181920212223// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue';import App from '@/App';import router from '@/router';import iView from 'iview';import axios from 'axios';import store from '@/store';import 'iview/dist/styles/iview.css'import '@/permission';// 全局注册Vue.config.productionTip = false;Vue.prototype.$axios = axios;Vue.use(iView);/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App) // 相当于 components: &#123; App &#125; vue1.0的写法&#125;);初始化的菜单栏就定义完成了。","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(二): 服务器搭建","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-二-服务器搭建","date":"2019-12-10","updated":"2020-01-11","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-二-服务器搭建/","link":"","permalink":"http://sunyunzeng.com/Vue-Express-MySQL驾驶行为分析全栈项目-二-服务器搭建/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。项目地址可视化效果 服务端结构设计结构设计如下图所示：api 文件夹存放的是网页路由查询逻辑的实现代码。py-script 存放的是python的脚本及训练好的深度学习模型。tables 是基于Sequlize的数据库表模型。config-default 定义了数据库连接信息。db.js 定义了Sequlize对象模型。func.js 定义了一些函数接口。index.js 是服务器的启动入口，定义了路口链接的运行文件。table.js 将tables文件中的表模型统一用模块接口暴露出来。 服务器搭建服务端采用了基于Node.js运行的Web应用框架——Express，首选需要安装Express框架。(前提是电脑安装了Node.js，如需安装，请参考其它网上教程)12// 进入在server目录，执行下面命令安装Expressnpm install express数据库采用了MySQL数据库，首先需要安装连接数据库的库函数1npm install --save mysql然后我们采用了Sequlize库函数方便管理SQL查询，接着安装Sequlize。1npm install --save sequelize我们再安装Express的中间件 body-parser 帮助我们解析JSON、Raw、文本、URL-encoded格式的请求体。1npm install --save body-parser然后再index.js编写我们的服务端启动入口。12345678910111213141516171819202122232425262728293031// node server// use ES6require('babel-register')(&#123; presets: ['env']&#125;);const bodyParser = require('body-parser');const express = require('express');const app = express();app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123;extended: false&#125;));// 允许跨域访问app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS'); res.header('X-Powered-By', ' 3.2.1'); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;);app.get('/', (req, res, next) =&gt; res.send('Express Server'));app.get('/api', (req, res, next) =&gt; res.send('API Pages'));// 监听端口app.listen(3000, () =&gt; console.log('success listen at port:3000......'));在server文件夹下用node.js启动程序，node index, 命令窗口会显示 ‘success listen at port:3000…’ 字样，证明服务器启动成功！这时在浏览器中输入 localhost:3000/api发现浏览器输出 API Pages。 连接数据库访问数据首先在 config-default 文件内定义数据库连接信息，如下：12345678module.exports = &#123; host: 'localhost', user: 'root', password: '**********', database: 'your_database', port: '3306', dialect: 'mysql'&#125;;然后 在db.js 文件中定义Sequlize模型：12345678910111213141516171819202122232425262728293031323334353637383940const Sequelize = require('sequelize');const config = require('./config-default');let sequelize = new Sequelize(config.database, config.user, config.password, &#123; host: config.host, dialect: config.dialect, pool: &#123; max: 5, min: 0, idle: 10000 &#125;&#125;);let defineModel = function (name, attributes) &#123; let attrs = &#123;&#125;; for (let key in attributes) &#123; let value = attributes[key]; // if the value is the mainKey if (typeof value === 'object' &amp;&amp; value['type']) &#123; value.allowNull = value.allowNull || false; attrs[key] = value; &#125; else &#123; attrs[key] = &#123; type: value, allowNull: false &#125;; &#125; &#125; return sequelize.define(name, attrs, &#123; tableName: name, timestamps: false, freezeTableName: true &#125;);&#125;;let exp = &#123; defineModel: defineModel&#125;;module.exports = exp;Sequlize 是一个基于Node.js的对象关系映射（Object Relational Mapping，ORM）实现，通过对SQL语言的封装，实现model与SQL的映射，让开发者可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。这里我们把Sequlize模型的定义做成了一个的模块接口，只要指定Sequlize参数，就可以生成一个Sequlize模型，这样针对一个数据库中不同的表就可以生成不同的Sequlize对象。之后根据自己的数据库表设计定义对应的表模型，如项目中 tables 文件夹内的 User1 文件。12345678910111213141516171819202122232425const Sequelize = require('sequelize');const db = require('../db');module.exports = db.defineModel('user_1',&#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true, allowNull: false &#125;, weekday: Sequelize.INTEGER, start_time: Sequelize.INTEGER, dis_total: Sequelize.FLOAT, sem_O: Sequelize.TEXT, sem_D: Sequelize.TEXT, destination: Sequelize.TEXT, lngs: Sequelize.TEXT, lats: Sequelize.TEXT, travel_dis: Sequelize.TEXT, spd: Sequelize.TEXT, azimuth: Sequelize.TEXT, norm_dict: Sequelize.TEXT, key_point: Sequelize.TEXT, sem_pt: Sequelize.TEXT, time: Sequelize.TEXT&#125;);因为随着项目不断深入，数据表模型也不断增多。为了统一管理，建立 tables 模块将所有表模型统一打包，用户可按需导入。1234567891011121314// tables.js 文件// scan all models defined in models:const fs = require('fs');const user1 = require('./tables/User1');const user2 = require('./tables/User2');const user3 = require('./tables/User3');const user4 = require('./tables/User4');module.exports = &#123; 'user1': user1, 'user2': user2, 'user3': user3, 'user4': user4,&#125;;之后再 api 文件夹中定义不同路由的处理逻辑，这里主要是对数据库的访问。例如 searchAll.js 文件是对整张表进行访问，其内容如下：12345678910111213141516171819const table = require('../table');const express = require('express');const router = express.Router();import &#123;jsonWrite&#125; from '../func';router.post('/', (req, res) =&gt; &#123; let params = req.body; if(params['tableName'] === undefined)&#123; jsonWrite(res, undefined); return; &#125; let user = table[params.tableName]; (async () =&gt; &#123; let traj = await user.findAll(); jsonWrite(res, traj); &#125;)();&#125;);module.exports = router;其中 jsonWrite 是我们在fun.js定义的根据请求结果返回res的函数，如下：123456789101112const jsonWrite = function (res, ret) &#123; if (typeof ret === 'undefined') &#123; res.json(&#123; code: '1', msg: '操作失败' &#125;); &#125; else &#123; res.json(ret); &#125;&#125;;export &#123;jsonWrite&#125;;然后，前端发送post请求，请求体中输入待查询数据表名就可以实现整张表的查询。这里的服务器代码不能实时更新效果，最后可以采用 nodemon 包检测服务器代码变化，实现代码的实时监测更新。1npm install -g nodemon然后利用 nodemon 启动 index.js入口文件，就可以实现服务器根据代码更新的自动重启，1nodemon index","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(一): 项目初始化","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-一-项目初始化","date":"2019-12-04","updated":"2020-01-11","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-一-项目初始化/","link":"","permalink":"http://sunyunzeng.com/Vue-Express-MySQL驾驶行为分析全栈项目-一-项目初始化/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。项目地址可视化效果 动态预测效果 技术栈1. 前端界面：Vue框架 + iView组件库 + ES6标准 + Webpack资源打包工具 + Leftlet地图交互JS库 + ECharts图表可视化库。Vue是一个渐进式的前端开发框架。它只关注图层界面(不像Angular一样提供全家桶)，通过数据的双向绑定解放开发者，让开发者可以专注于业务逻辑的代码。同时，Vue简单易上手，初学者完全不需要学习任何的新知识。基于Vue搭建前端界面的逻辑，包括界面模块层级关系、路由、操作逻辑等等。iView组件库是一个基于Vue.js的可视化组件库，提供高质量的前端组件，例如按钮、表格、任务栏等等，基于该组件库提供用户交互的入口。ES6标准是JavaScript的新一代标准，规范了类的继承，增加了模块的定义与引入、变量的解析赋值、以及 let、const命令语法等等。虽然很多是ES5的语法糖，但使得JS更加严谨与灵活。然而很多项目都是用ES6前版本实现的，以及很多浏览器并没完全支持ES6语法，为了向下兼容，采用babel编译器对ES6代码编译。Webpack一种模块化的解决方案，通过模块化提高js代码的复用性，降低项目的耦合性，提高可维护性。利用Webpack使我们的项目模块化，并进行项目的打包。Leftlet与ECharts是两个优秀的前端可视化库，利用它们，项目实现地图轨迹的可视化。2. 服务器：Express框架 + Sequelize数据库查询管理库。**Express框架：**基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。本项目基于Express实现了路由的管理与处理、数据库的CRUD操作、深度学习模型的python脚本调用。Sequelize是一个基于Node.js的对象关系映射（Object Relational Mapping，ORM）实现，通过对SQL语言的封装，实现model与SQL的映射，让开发者可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。3. 数据库： MySQL关系型数据库。 本教程的食用准则需要有一定的前端基础，包括JS、H5、CSS3基础知识的掌握。对npm等包管理器有所了解。具有一定的面向对象的开发经验，具有模块化编程思想。对于数据库的SQL有初步掌握。了解Vue等前端框架。 项目总框架如下图所示，项目框架是基于Vue项目框架实现，首先通过Vue-cli搭建Vue项目(此处网上教程很多，略过)，然后再框架下创建Server文件夹，用来存放服务器端代码。其中绿色标出的部分并是我自己创建的，可以忽略。","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://sunyunzeng.com/tags/Vue/"}]},{"title":"LeetCode 75.颜色分类","slug":"LeetCode-75-颜色分类","date":"2019-11-26","updated":"2020-01-11","comments":true,"path":"LeetCode-75-颜色分类/","link":"","permalink":"http://sunyunzeng.com/LeetCode-75-颜色分类/","excerpt":"","text":"题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。注意:不能使用代码库中的排序函数来解决这道题。示例:12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 思路 + 代码先统计0,1,2分别出现的次数，然后按照各自数量依次赋予数组新数值。时间复杂度: O(N^2)空间复杂度: O(1)1234567891011121314151617181920class Solution &#123; public void sortColors(int[] nums) &#123; if(nums==null || nums.length==0) return; int[] counts = new int[3]; for(int i=0; i&lt;nums.length; i++)&#123; counts[nums[i]]++; &#125; for(int i=0;i&lt;nums.length; i++)&#123; if(counts[0]&gt;0)&#123; nums[i] = 0; counts[0]--; &#125;else if(counts[1]&gt;0)&#123; nums[i] = 1; counts[1]--; &#125;else&#123; nums[i] = 2; &#125; &#125; &#125;&#125;或者三指针方法，左指针负责交换0， 右指针负责交换2，中间指针负责扫描。时间复杂度: O(N)空间复杂度: O(1)123456789101112131415161718class Solution: def sortColors(self, nums: List[int]) -&gt; None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" p0 = cur = 0 p1 = len(nums) - 1 while cur &lt;= p1: if nums[cur] == 0: nums[cur], nums[p0] = nums[p0], nums[cur] # 这里左边遍历当前位置加一，因为左边的确定全部扫描过，而右边交换过的未进行判断 cur += 1 p0 += 1 elif nums[cur] == 1: cur +=1 else: nums[cur], nums[p1] = nums[p1], nums[cur] p1 -=1来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-colors著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"文档对象模型DOM","slug":"文档对象模型DOM","date":"2019-11-22","updated":"2020-01-11","comments":true,"path":"文档对象模型DOM/","link":"","permalink":"http://sunyunzeng.com/文档对象模型DOM/","excerpt":"","text":"DOM是什么？DOM，即Document Object Model，文档对象模型，用于操作HTML的编程接口。它描绘了一个层次化的节点树，允许编程人员进行节点的添加、修改与删除等操作。 DOM节点DOM 1级定义了一个Node接口，由DOM中所有的节点实现。一共有12中节点类型，其中包括Document、Element节点类型等，可通过node.nodeType查询每个节点的类型，例如，Element的节点类型返回数值为1。每一个节点都有childNodes、parentNode、previousSibling、nextSibling、firstChild、lastChild等节点查询方法。还有appendChild、insertBefore、replaceChild、removeChild、cloneNode等操作节点的方法。 DocumentDocument节点表示整个文档。浏览器中的document是一个全局对象，表示HTML页面，是HTMLDocument对象的实例。document.documentElement：快速取得对html的引用。document对象只有一个子节点，也就是&lt; html &gt;对象，没必要使用节点操作方法。document的title、URL、domain、referrer等方法可以访问网页的标题、URL地址、域名及连接当前URL的前一URL。document.getElementById()：获取指定id的元素。ducument.getElementsByTagName()：获取指定标签名的元素，例如var img = ducument.getElementsByTagName(&quot;img&quot;)，返回一个HTMLCollection类型的实例，其中img.namedItem(&quot;imgName&quot;)可以返回执行name的元素。ducument.getElementsByName()：获取指定name的元素集合。ducument.write()与ducument.writeln()写入文档。getElementsByClassName()：获取同一类的元素列表，返回NodeList。document.activeElement()：获得当前焦点所在的元素，例如页面加载中，焦点所在的元素是document.body，之后变成null。document.hasFocus()：判断当前文档是否获取了焦点。document.readyState：&quot;loading&quot;正在加载文档，&quot;complete&quot;加载完毕。document.compatMode：&quot;CSS1Compat&quot;渲染模式为标准，“BackCompat&quot;渲染模式为混杂模式。document.charset：查看与设置文档字符集，默认&quot;UTF-16”。 ElementElement类型表现为HTML元素，每个HMTML元素都存在id、title、dir、className、lang属性。getAttribute() setAttribute()和 removeAttribute()操作属性值。123456var div = document.getElementById(\"myDiv\"); alert(div.getAttribute(\"id\")); //\"myDiv\"div.setAttribute(\"id\", \"someOtherId\");div.removeAttribute(\"class\");attributes属性，是表示一个元素属性的动态的集合，可通过nodeValue获取标签值。1var id = div.attributes.getNamedItem(\"id\").nodeValue;document.createElement()创建元素。1var div = document.createElement(\"div\"); Text类型Text，文本节点，用于表示不含HTML标签的纯文本。包含在element类型中。 appendData(text)：将 text 添加到节点的末尾。 deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。123456789&lt;!-- 没有内容，也就没有文本节点 --&gt; &lt;div&gt;&lt;/div&gt;&lt;!-- 有空格，因而有一个文本节点 --&gt; &lt;div&gt; &lt;/div&gt;&lt;!-- 有内容，因而有一个文本节点 --&gt; &lt;div&gt;Hello World!&lt;/div&gt;// 取得div的文本节点，并修改其值div.firstChild.nodeValue = \"Some other message\";document.createTextNode()创建新文本节点。12345var element = document.createElement(\"div\"); element.className = \"message\";var textNode = document.createTextNode(\"Hello world!\"); element.appendChild(textNode);document.body.appendChild(element); DOM操作技术 动态脚本可以通过doucument.createElement()方法实现动态script代码的引入或创建。1234var script = document.createElement(\"javascript\");script.type = \"text/javascript\";script.src = \"client.js\";document.body.appendChild(script);或者可以通过自定义代码的方式调用1234567891011function loadScriptString(code)&#123; var script = document.createElement(\"script\"); script.type = \"text javascript\"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; script.text = code; &#125; document.body.appendChild(script); &#125;loadScriptString(\"function sayHi()&#123;alert('hi');&#125;\"); 动态样式CSS样式可以通过style属性或元素嵌入样式，或者可以通过&lt; link &gt;引入CSS外部文件。1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\"&gt;与动态script一样的原理，可以通过实现样式的动态添加。123456var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"style.css\";var head = document.getElementsByTagName(\"head\")[0]; head.appendChild(link);或者可以通过自定义代码的方式调用123456789var style = document.createElement(\"style\"); style.type = \"text/css\"; try&#123; style.appendChild(document.createTextNode(\"body&#123;background-color:red&#125;\")); &#125; catch (ex)&#123; style.styleSheet.cssText = \"body&#123;background-color:red&#125;\"; &#125;var head = document.getElementsByTagName(\"head\")[0];head.appendChild(style); DOM扩展 选择符querySelector()与querySelectorAll()方法。querySelector()12345678//取得 body 元素var body = document.querySelector(\"body\"); //取得 ID 为\"myDiv\"的元素var myDiv = document.querySelector(\"#myDiv\"); //取得类为\"selected\"的第一个元素var selected = document.querySelector(\".selected\"); //取得类为\"button\"的第一个图像元素var img = document.body.querySelector(\"img.button\");querySelectorAll()123456//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(\"em\")） var ems = document.getElementById(\"myDiv\").querySelectorAll(\"em\"); //取得类为\"selected\"的所有元素var selecteds = document.querySelectorAll(\".selected\"); //取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(\"p strong\");","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript中的函数表达式","slug":"JavaScript中的函数表达式","date":"2019-11-19","updated":"2020-01-11","comments":true,"path":"JavaScript中的函数表达式/","link":"","permalink":"http://sunyunzeng.com/JavaScript中的函数表达式/","excerpt":"","text":"函数表达式函数表达式是定义函数的一种方式，如下：12345678// 函数表达式var add = function(v1, v2)&#123; return v1 + v2;&#125;// 函数声明function add(v1, v2) &#123; return v1 + v2;&#125;函数表达式可以创建一个匿名函数，它与JS的很多特性与模式有关，包括闭包、私有变量创建等等。 闭包闭包指一个函数，该函数有权访问其他函数作用域中的变量。123456789101112131415161718192021function createComparisonFunction(propertyName)&#123; // 闭包 return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;var compare = createComparisonFunction(\"name\");console.log(compare(&#123;name: \"syz\"&#125;, &#123;name: \"xj\"&#125;));// 释放内存compare = null;放回的匿名函数引用了外包函数createComparisonFunction()的变量propertyName。需要注意的是，在createComparisonFunction()执行完毕产生比较函数compare()时，其作用域链被销毁，但是其活动对象(此处指propertyName)仍被compare()函数引用，并没有销毁。闭包实现的具体原理是：首先，每一个执行环境都有一个变量对象表示。全局执行环境的变量对象始终存在，而函数内部的变量对象在执行过程中创建，执行完毕销毁。createComparisonFunction()函数执行过程，首先创建一个包含全局变量对象的作用域链，并被内部属性[[Scope]]引用，其中的参数、变量与方法都作为活动对象(该函数的变量对象)被推入作用域链的顶端，构成该函数的作用域链。作用域链提供一个变量对象的引用链，通过它可以访问链上的变量。然后，内部函数的创建，首先创建一个包含全局变量对象的作用域链。如果内部函数引用了外部函数的变量，即闭包，那么内部函数的作用域链会添加外部函数的活动对象，最后再将本函数的活动对象推入作用域链顶端。最后，外部函数createComparisonFunction()执行完毕，本来所有作用域链与活动对象全部销毁，但由于内部函数的引用，导致只销毁作用域链，而活动对象继续被内部函数引用，直到内部函数被销毁。 匿名函数中的this对象要熟知函数的this对象指向其对应的执行环境。12345678910111213141516171819202122232425262728// 例子1var object = &#123; name: \"this indicator\", getName: function()&#123; return function()&#123; return this.name; &#125; &#125;&#125;/* 因为调用函数getName()返回一个内部函数，而此内部函数的执行环境为全局执行环境,尽管其作用域链存在外部函数的this对象，但是作用域链的顶端this对象指向全局执行环境,所以返回 windows*/console.log(object.getName()()); // windows// 例子2var object = &#123; name: \"this indicator\", getName: function()&#123; var that = this; return function()&#123; return that.name; &#125; &#125;&#125;// 指定匿名函数的this对象就是指向外部函数的this对象，因此返回 this indicatorconsole.log(object.getName()()); // this indicator 模拟块级作用域由于JS不存在块级作用域，因此if、for语句中声明的变量存在于全局变量中，会导致内存的溢出及命名的冲突。可以通过匿名函数的方式模拟模拟块级作用域，将生命的变量随匿名函数的生命周期绑定。12345(function() &#123; for(var i = 0; i &lt;10; i++)&#123; console.log(i); &#125;&#125;)(); // 表示立即执行该函数，如果匿名函数没有被()包裹，则报错。 自定义类型的私有变量JS的所有属性没有私有概念。但是函数内的变量是局部的，外部不可访问的。可在构造函数或私有作用域中声明私有变量与方法，在匿名函数中引用外部函数的私有变量，并提供可访问这些方法的特权函数，实现自定义类型的私有变量。 构造函数中创建私有变量123456789101112function Person()&#123; // 私有变量与方法 var name = \"syz\"; function getGender()&#123; return \"man\"; &#125; // 特权方法获取私有变量 this.getInfo = function()&#123; name = \"xj\"; return getGender(); &#125;&#125;还可以通过匿名函数实现私有变量的不可修改与直接读取的设定。12345678910function Person(name)&#123; // 保护私有变量，此时Person构造函数的变量name通过闭包访问，形成了每个成员的保护变量 this.getName = function()&#123; return name; &#125; this.setName = function(value)&#123; name = value; &#125;&#125; 静态私有变量采用构造函数声明私有变量对每个实例都是唯一的，会造成代码的重复。对属于类的公共的属性与方法，可以通过静态私有变量的方式私有化。12345678910111213141516171819202122232425// 通过私有作用域实现私有变量的保存(function()&#123; // 私有变量 var name = \"\"; // 全局构造函数 Person = function(value)&#123; name = value; &#125; // 通过原型实现静态私有变量 Person.prototype.getName = function()&#123; return name; &#125; Person.prototype.setName = function(value)&#123; name = value; &#125;&#125;)();var person1 = new Person(\"syz\");console.log(person1.getName()); // syzvar person2 = new Person(\"xj\");console.log(person1.getName()); // xjconsole.log(person2.getName()); // xj 单例的私有变量JS中的单例很简单。123var singleton = &#123; description: \"I am a singleton\";&#125; 模块模式单例可以通过模块模式的方式实现变量的私有化。基本思想是通过将私有变量与方法保存在外部匿名函数的活动对象中，然后返回一个具有特权访问函数的匿名对象。123456789101112131415161718var application = function() &#123; // 私有变量 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 放回单例，单例内通过特权方法访问私有变量 return &#123; getComponentCount : function()&#123; return components.length; &#125;, registerComponent : function(component)&#123; if (typeof component == \"object\")&#123; components.push(component); &#125; &#125; &#125;&#125;(); // 立即执行函数 增强模块模式如果想创建指定类型的单例，并为其添加私有变量及增加属性与方法，可采用增强模块模式。基本思想与模块模式差不多，只不多不返回匿名对象，而是先创建指定类型的单例对象，然后为该对象添加特权访问函数、增强属性与方法，然后返回。123456789101112131415161718var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建 application 的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == \"object\")&#123; components.push(component); &#125; &#125;; //返回这个副本 return app;&#125;();","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript中的继承","slug":"JavaScript中的继承","date":"2019-11-18","updated":"2020-01-11","comments":true,"path":"JavaScript中的继承/","link":"","permalink":"http://sunyunzeng.com/JavaScript中的继承/","excerpt":"","text":"浅述JS继承JS作为一门不是很严谨的OO语言，由于其函数没有签名，因此不能实现签名继承的接口形式，却可实现属性与方法的完全继承。JS的继承方式有六种：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承及寄生组合继承。 原型链继承在JS对象一章讲到了构造函数的原型对象，如果一个构造函数的原型对象是另一个构造函数的实例，那么通过该构造函数创建的实例就继承了原型对象对应构造函数的全部属性与方法。123456789101112131415161718192021222324function SuperType(name)&#123; this.name= name; this.color = [\"red\", \"green\", \"blue\"];&#125;SuperType.prototype.sayHello = function()&#123; console.log(\"Hello \" + this.name);&#125;function SubType(name,age)&#123; this.name=name; this.age=age;&#125;// 原型链继承SubType.prototype = new SuperType();var sub = new SubType(\"sg\", 26);sub.sayHello(); // Hello sgvar sub1 = new SubType(\"syz\", 24);var sub2 = new SubType(\"xj\", 22);sub1.color.push(\"black\");console.log(sub2.color); // [ 'red', 'green', 'blue', 'black' ]不足：1. 对于父类的引用类型，在子类中是共享的，因为子类原型对象指向同一父类实例，无法实现与子类的单独绑定。 2. 没有办法在不影响子类的情况下为父类构造函数赋予初始值。 构造函数继承在子类构造函数中，调用父类构造函数方法，可以实现父类属性（尤其是引用类型）与子类的单独绑定。1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name= name; this.color = [\"red\", \"green\", \"blue\"];&#125;SuperType.prototype.sayHello = function()&#123; console.log(\"Hello \" + this.name);&#125;// 构造函数继承function SubType(name,age)&#123; // 在SubType执行环境作用域执行父类构造函数的初始化函数 SuperType.call(this, name); this.age=age;&#125;var sub = new SubType(\"sg\", 26);// 原型对象是通过内部指针访问，通过执行函数的方式无法访问sub.sayHello() //TypeError: subType.sayHello is not a functionvar sub1 = new SubType(\"syz\", 24);var sub2 = new SubType(\"xj\", 22);sub1.color.push(\"black\");sub2.color.push(\"yellow\");console.log(sub1.color); //[ 'red', 'green', 'blue', 'black' ]console.log(sub2.color); //[ 'red', 'green', 'blue', 'yellow' ]不足：无法复用父类原型对象中公共的属性与方法。 组合继承组合继承就是综合原型链与构造函数的继承方式，结合二者各自的优点，可以继承父类构造函数与原型对象中的属性与方法，且可以实现父类引用类型数据与子类的单独绑定。12345678910111213141516171819202122function SuperType(name)&#123; this.name= name; this.color = [\"red\", \"green\", \"blue\"];&#125;SuperType.prototype.sayHello = function()&#123; console.log(\"Hello \" + this.name);&#125;function SubType(name,age)&#123; // 在SubType执行环境作用域执行父类构造函数的初始化函数 SuperType.call(this, name); // 第二次调用 this.age=age;&#125;SubType.prototype = new SuperType(); //第一次调用// 防止指向父类的构造器SubType.prototype.constructor = SubType;var sub = new SubType(\"sg\", 26);// 原型对象是通过内部指针访问，通过执行函数的方式无法访问sub.sayHello() // Hello sg不足： 重复调用了两次的父类的构造函数，导致子类原型对象中存储了重复的无用的数据。 原型式继承如果只想使得某些类表现得像某个类，可以采用原型式继承。即使这些类的原型对象指向同一个对象。1234567891011121314151617181920212223var Person = &#123; name: \"syz\", friends: [\"mzp\", \"wjh\"]&#125;// 原型继承函数function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F;&#125;var person1 = object(Person);person1.name = \"John\";person1.friend.push(\"lili\");var person2 = object(Person);person1.name = \"gad\";person1.friend.push(\"uzi\");console.log(person1.name); // Johnconsole.log(person2.name); // gadconsole.log(person1.friends); // [ 'mzp', 'wjh', 'lili', 'uzi' ]console.log(person2.friends); // [ 'mzp', 'wjh', 'lili', 'uzi' ]ECMAScript5规范了原型式继承的方式，即采用Object.create()方法，参数数即要继承的包含共用的属性与方法的对象，第二个参数为可选参数Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。Object.create()作用与object()方法相同。1234567891011var Person = &#123; name: \"syz\", friends: [\"mzp\", \"wjh\"]&#125;var person1 = Object.create(Person, &#123; name: &#123; value: \"xj\" &#125;&#125;);console.log(person1.name); // xjconsole.log(person1.friends); // [ 'mzp', 'wjh' ] 寄生继承寄生继承组合了原型式继承与工厂方法，或者是装饰器模式，可以对原型示例添加装饰方法。1234567891011121314151617181920var Person = &#123; name: \"syz\", friends: [\"mzp\", \"wjh\"]&#125;function createPerson(_name_)&#123; var person = Object.create(Person, &#123; name: &#123; value: _name_ &#125; &#125;); person.sayHi = function()&#123; console.log(\"Hi\"); &#125; return person;&#125;var person = createPerson(\"xj\");person.sayHi(); // Hiconsole.log(person.name); // xj 寄生组合继承是JS继承的最优解，通过寄生继承减少了组合继承中多余的父类构造函数调用产生的子类原型对象属性重复的问题。对于子类的原型对象，采用寄生继承方式继承自父类的原型对象。1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name= name; this.color = [\"red\", \"green\", \"blue\"];&#125;SuperType.prototype.sayHello = function()&#123; console.log(\"Hello \" + this.name);&#125;function inheritPrototype(subType, superType)&#123; subType.prototype = Object.create(superType.prototype); subType.prototype.constructor = subType;&#125;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age;&#125;inheritPrototype(SubType,SubType);var sub = new SubType(\"syz\", 12);console.log(sub.name); // syzconsole.log(sub.age); // 12console.log(sub.color); // [ 'red', 'green', 'blue' ]sub.sayHello(); // Hello syz完美！","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript中的对象","slug":"JavaScript中的对象","date":"2019-11-16","updated":"2020-01-11","comments":true,"path":"JavaScript中的对象/","link":"","permalink":"http://sunyunzeng.com/JavaScript中的对象/","excerpt":"","text":"对象的概念JS 中的对象其实是无序属性的集合，属性包括基本数据、函数与对象，每个属性有属性名，属性名与属性值以键值对的形式保存在对象内部。12345678// JS中的一个对象var person = &#123; name: \"syz\", job: \"Software Engineer\", sayHello: function()&#123; console.log(\"Hello\"); &#125; &#125; 对象的属性为了JavaScript引擎可以操作对象中的属性，每个属性定义了对应的两种属性类型：1. 数据属性。 2. 访问器属性。 数据属性是对一个对象属性值的操作说明，共有四类说明：configurable、enumerable、writable及value。可通过Object.defineProperty实现不同属性的值操作限定，接收三个参数，第一个是操作对象、第二个是操作对象的属性第三个是对该属性的操作限定。12345678910111213141516171819202122232425262728293031var person = &#123; name: \"syz\", job: \"Software Engineer\", age: 24&#125;Object.defineProperty(person, \"age\", &#123; /* 默认true。 设置为false，则该属性不能被删除，configurable、enumerable、writable(true还可设定为false)不能再设定； 该属性不能在通过Object.defineProperty()方法修改为访问器属性。 */ configurable: true, /* 默认true。 设置为false，则不能通过for-each方式遍历该属性。 for(var item in person)&#123; console.log(item) // 不会输出person的age属性 &#125; */ enumerable: true, /*默认true。 设置为false，则属性值为可读的，严格模式强行修改会报错，一般模式修改无效。 */ writable: true, // 设置该属性的值 value: 25&#125;); 访问器属性访问器属性是对访问对象属性值的操作的说明，共四类：configurable、enumerable、get及set。可通过Object.defineProperty实现不同属性的值操作限定，接收三个参数，第一个是操作对象、第二个是操作对象的属性第三个是对该属性的操作限定。12345678910111213141516171819202122232425262728293031323334353637383940var person = &#123; name: \"syz\", job: \"Software Engineer\", _age: 24&#125;Object.defineProperty(person, \"age\", &#123; /* 默认为true。 设置为false，则该属性不能被删除，该属性不能在通过Object.defineProperty()方法修改为数据属性。 */ configurable: true, /* 默认为true。 设置为false，则不能通过for-each方式遍历该属性。 for(var item in person)&#123; console.log(item) // 不会输出person的age属性 &#125; */ enumerable: true, /*设置读取该属性时的返回值。 注意_age前面有 _ 下划线，表示该属性值只能通过对象的方法访问到，也就是get()方法，如果没有定义相应的方法， 采用person._age访问会返回undefined。 如果_age前面不加下划线，而又通过get()函数访问this.age的话，会导致函数调用栈溢出. 因为person.age -&gt; get.call(person) -&gt;this.age -&gt; person.age -&gt; ... */ get: function()&#123; return this._age; &#125;, // 改属性赋值时的操作 set: function(value)&#123; this._age = value; if(value &gt; 50)&#123; this.job = \"rubbish\"; &#125; &#125;&#125;); 数据属性其它知识通过Object.defineProperties()方法一次性为对象的多个属性设置属性类型。1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperies(book, &#123; name: &#123; value: \"machine learning\" &#125;, _year: &#123; value: 2019 &#125;, edition&#123; value: 1 &#125; year: &#123; get: function() &#123; return this._year; &#125;, set: function(value) &#123; if(value&gt;2019)&#123; this._year = value; this.edition += value - this._year; &#125; &#125; &#125;&#125;)通过Object.getOwnPropertyDescriptor()方法获得指定对象指定属性的属性类型说明对象。第一个参数接收查询对象，第二个参数接收对应对象的查询属性的字符串表示。该方法只能获取实例对象的属性类型描述对象，对于原型对象，需要调用Person.prototype。12345var descriptor = Object.getOwnPropertyDescriptor(book, \"year\");console.log(descriptor.enumrable); //如果是访问器属性，则返回undefinedconsole.log(descriptor.value);console.log(descriptor.writable); //如果是访问器属性，则返回undefinedconsole.log(descriptor.configurable); 创建对象JavaScript中自定义的对象又是怎么创建来的呢？从前面知识，我们了解到，可以通过构造函数或者对象字面量的形式创建，如下：123456789// 默认的Object构造函数var person = new Object(&#123; name : \"syz\"&#125;);// 对象字面量形式var person = &#123; name : \"syz\"&#125;首先，通过对象字面量形式创建的对象只能是Obejct类型实例，无法满足特定实例的要求。然后，再看通过构造函数创建的方式。 构造函数构造函数其实就是函数的一种，任何函数都可以是构造函数，只要在函数前面使用 new 关键字，就使该函数成为了构造函数。123456789// 构造函数通常大写function Person(name, age) &#123; this.age = age; this.name = name; this.sayHello = function ()&#123; console.log(\"Hello\"); &#125;&#125;var person = new Person(\"syz\", 12);前面提到，函数其实也是一种Funcation类型的实例对象，加入了new关键字后，函数执行四个步骤:创建一个新对象。将构造函数的作用域赋给对象，即this的主体换为新对象。执行构造函数的语句，对新对象执行初始化操作。返回该对象。构造函数也可以当做普通函数使用，如下：12345// 此时函数的作用域是全局执行环境，因此也就是给windows对象赋予了name及age属性Person(\"syz\", 12);//通过调用call()方法在指定作用域执行,相当于为person对象赋予了姓名与年龄属性var person = &#123;&#125;;Person.call(person, \"syz\", 12);通过构造函数创建的对象实例可以通过关键字 instanceof来判断其是否为某自定义引用类型的对象。1person instanceof Person; // =&gt; true 原型对象然而，仅通过构造函数创建对象存在弊端。即一些属于类公共部分的属性（尤其是引用类型值）仍需要在每个实例创建过程中重新创建一份副本。1234567891011function Person(name) &#123; this.name = name; this.sayHello = function ()&#123; console.log(\"Hello\"); &#125;&#125;var person1 = new Person(\"syz\");var person2 = new Person(\"xj\");console.log(person1.sayHello===person2.sayHello); // =&gt;false因为 sayHello() 方法是 Function 类型的实例，尽管其作用在每个对象实例中是相同的，但是在每个对象创建过程中，每个sayHello() 都重新创建一份副本，导致内存资源的浪费。JS通过构造函数的原型对象来解决。原型对象其实是构造函数的属性之一，可以通过 Person.prototype 访问 Person 构造函数原型对象，其中保存了 Person 类共享的属性与方法。原型对象在每个函数的创建过程中自动生成，即每个函数自动生成一个 prototype 属性，指向一个原型对象，该原型对象自动生成一个 constructor属性，指向构造函数，其属性类型是不可枚举的。1234567891011121314151617181920212223242526272829303132333435function Person()&#123;&#125;// 为原型兑现赋值Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function()&#123; alert(this.name);&#125;;/* 还可以用简便的方法为原型对象赋值Person.prototype = &#123; name: \"Nicholas\", age: 29, job: \"Software Engineer\", sayName: function()&#123; alert(this.name); &#125; /*由于此时完全重写了系统自动生成的的原型对象，所以constroctor属性不再指向Person，而是Object 此时再用person.constroctor == Person 就返回false,需要重新定义constroctor的指向 */ // constructor: Person, 但是此时的constructor属性时可枚举的，可用下列语句修改属性类型 Obeject.defineProperty(Person.prototype, \"constroctor\"&#123; enumerable: false, value: Person &#125;);&#125;;var person1 = new Person(); var person2 = new Person(); person1.sayName(); //\"Nicholas\"var person2 = new Person(); person2.sayName(); //\"Nicholas\" alert(person1.sayName == person2.sayName); //true各对象之间的关系在一个实例中访问某个属性，首先在实例本身搜索，如果没找到，再通过内部属性[[Property]]找到指向的原型对象，再在其内部寻找。如果实例内部定义了与原型对象中重名的属性，则读取到该属性即停止搜索。12345678910function Person()&#123;&#125;Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person = new Person();person.height = 30;相关函数isPrototypeOf(): 判断某个原型对象是否是某个实例对应的原型对象1Person.prototype.isPrototypeOf(person); // =&gt; tureObject.getPrototypeOf(): 获得某个实例的原型对象1var proto = Object.getPrototypeOf(person);hasOwnProperty(): 判断某个属性是来自实例还是原型对象，来自实例返回true1console.log(persom.hasOwnProperty(\"height\")); //=&gt; truein: 判断某个实例是否包含某个属性，无论是位于实例本身还是原型对象12console.log(\"job\" in person); //=&gt; trueconsole.log(\"height\" in person); // =&gt; truefor in: 遍历所有可枚举属性，无论是位于实例本身还是原型对象123for(var item in person)&#123; console.log(item); // name,height,age,job,sayName&#125;Object.keys(): 以字符串数组形式返回实例本身可枚举的属性12console.log(Object.keys(Person.prototype)); //[ 'name', 'age', 'job', 'sayName' ]console.log(Object.keys(person)); //[ 'name', 'height' ]getOwnPropertyNames(): 以字符串数组形式返回实例本身所有的属性（包括不可枚举）12console.log(Object.getOwnPropertyNames(Person.prototype)); //[ 'constructor', 'name', 'age', 'job', 'sayName' ]console.log(Object.getOwnPropertyNames(person)); //[ 'name', 'height' ] 混合模式创建对象通过原型模式可以设置共享的对象类型，通过构造器模式可以为对象的创建赋予初始值，结合二者的混合模式是最常见的创建对象的方法。1234567891011121314151617181920212223function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; constroctor: Person, sex: \"man\"&#125;if(typeof Person.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; console.log(\"Hello, my name is \" + this.name); &#125;;&#125;person1 = new Person(\"syz\", 24);person2 = new Person(\"xj\", 23);console.log(person1.name); // \"syz\"console.log(person2.name); // \"xj\"console.log(person1.sex); // \"man\"console.log(person2.sex); // \"man\"","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript基础知识点","slug":"JavaScript基础知识点","date":"2019-11-13","updated":"2020-01-11","comments":true,"path":"JavaScript基础知识点/","link":"","permalink":"http://sunyunzeng.com/JavaScript基础知识点/","excerpt":"","text":"为啥“又”学JavaScript？那年头发还多，正是大四上学期。提前联系了导师，由于项目原因，第一次接触到JS。然后，看了两周左右的入门书籍，入了前端的坑。结果，自己觉得前端没啥技术含量，跑回去学后端开发，也就是Java开发的一套东西。看到数据库、并行化编程部分，心态崩了。自己还是喜欢前端开发。又滚回来重新学习。看到网页在自己面前展示，真TM有意思。 JavaScript这门语言JavaScript很有趣，比Java有趣多了。Java好比是一个严谨的大叔，什么都严格要求，准确但无趣。JavaScript好比是一个热血青年，喜欢打篮球，生动有趣。不过JavaScript也不老了，1995年诞生。当时叫这个名字还是蹭Java的热度。。。JavaScript由三剑客组成：ECMAScript、DOM、BOM。 ECMAScriptECMAScript是ECMA-262标准定义的一种语言规范，规定了一门语言的5类部分：类型、语句、关键字、保留字、操作符及对象。ECMAScript没有定义任何语言运行的环境要求，只是说明，你按照我这个规范，可以实现一种编程语言。不像Java，规定了虚拟机作为它的运行环境。浏览器可以作为ECMAScript语言的运行环境，当然Node、Abode Flash也都是。JavaScript就是一种实现了该标准的语言，同样的Adobe ActionScript也实现了ECMAScript。因此，JavaScript就是按照 ECMAScript 规定的脚手架搭建起来的房子，所以掌握JavaScript必须要掌握ECMAScript规范。最新的ECMAScript标准是2015年6月颁布的《ECMAScript2015标准》简称ES2015，由于比前面版本有了重大改进，因此又被称为ES6.0。每年6月份ES标准委员会会颁布最新的ES标准，而2016年颁布的《ECMAScript2016标准》相比较2015标准改进不大，因此又被称为ES6.1.具体ES6标准的讲解后面博客中再讲。 DOMDOM, Document Object Model, 文档对象模型，这里指针对HTML的可编程接口。将网页通过层次性节点来表示，如下所示：12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;其实DOM可针对任何XML类语言进行实现，包括 SVG（Scalable Vector Graphic，可伸缩矢量图）1.0等。 BOMBOM, Browser Object Model, 浏览器对象模型，使开发人员可以控制浏览器网页页面之外的部分。比如：弹出新浏览器、移动缩放与关闭浏览器窗口、提供用户显示器分辨率详细信息的screen对象、对cookies支持等。 总结ECMAScript 标准为JavaScript提供核心语言功能；DOM 提供访问与操作网页内容的方法和接口；BOM 提供操作浏览器的方法和接口。 JS知识点 在H5中使用JS**引入位置：**JS的&lt;script&gt;标签放在&lt;body&gt;标签内最下方，使浏览器先加载页面再加载JS代码，保证界面流畅。**嵌入外部文件：**尽量不要再 HTML 文件中嵌入JS代码，而是引入JS外部文件的方式。提高可维护性与缓存效率。**严格模式：**在整个脚本顶部或者函数内部上方加上语句&quot;use strict&quot;。1234function()&#123; \"use strict\"; //函数体，在函数内部执行严格模式&#125; 数据类型**数据类型：**JS一共6中数据类型，5中基本数据类型：String、Number、Boolean、Null、Undefined 及一种复杂类型 Object。基本数据类型占据固定的内存大小，存储在栈内存中。引用类型的变量名保存在栈空间中。JS的变量只是转递数据的载体，其本身是松散类型，一个变量即可存储字符串又可存储数组。此时需要用typeof操作符检查数据类型。简单数据类型变量与值都存储在栈内存(stack)中。浏览器从电脑内存中开辟一块栈内存，再分配一个主线程自上而下执行程序。栈内存分为变量存储空间与值存储空间。赋值语句将两个空间对应的变量与值关联起来。1234567// let a = 12的赋值过程：// 1. 首先新建变量a(如没有)，将其存入变量存储空间// 2. 再新建数值12(如没有)，将其存入值存储空间。// 3. 再执行赋值操作 = ，将变量a与值12关联。 let a = 12; let b = a; b = 13;引用数据类型的变量名存储在栈内存中，**值存储在堆内存(heap)**中。浏览器从电脑内存中开辟一块栈内存，再分配一个主线程自上而下执行程序。由于引用数据类型的值非常复杂，因此开辟一块堆内存，每块内存对应一个唯一的内存地址。赋值操作 = 将变量与堆内存的内存地址关联起来。123456let c = &#123; name: \"syz\", age: 24 &#125;;let d = c;d.age = 256; 基本数据类型String类型不同于Java,它是简单数据类型，但相同点是它是不可变的。任何数据都可转为String类型。通过调用对象的toString方法或者对于Null及Undefined直接返回&quot;null&quot;与&quot;undefined&quot;。通过 a.toString()转换。通过String(a, n)转换。n为可选项，当a为数值类型时，n可以指定转换的进制数。Number类型分为浮点值和整型值。浮点值小数点后面必须有数字，否则认为值整型。浮点值最高精度是17位，因此不要测试某个具体的浮点值，例如0.3==0.1+0.2。Number最大值为Number.MAX_VALUE，最小值是Number.MIN_VALUE，超出范围则根据正负情况得到正负Infinity。用isFinite()函数判断一个数是不是无穷。0 / 0 的结果是NaN。它不与任何数相等，包括自身。 可用isNaN()判断一个数据是不是数。parseInt(a, n) 与 parseFloat()可以解析数值。如果字符串前面有数值的话也能被解析出来。Boolean类型可用Boolean()来对任意数值进行转换。非零及非NaN的数值(包括无限大)为真。非空的字符串为真。任何非null的对象为真。undefined 始终为假。Null与Undefinednull表示空指针，即声明了对象指针，但没实例化。undefined表示没有初始化。undefined 派生自 null，所以null==undefined,返回true。所有的类型复制都是值传递。对于基本类型的复制结果的修改不影响原数据，因为再拷贝了一份。复杂类型的复制结果是对其指针的复制，复制结果的修改会影响原数据。方法内部传递的复杂类型也是复制后的指针。所有**基本数据类型都是不可变的，**即使对相同名字的变量赋值，也是先销毁原先变量再生成新变量。与=== 是相等，即判断两者不同时，先进行类型转换。true转为数值 1， false转为0。字符串与数值比较，先转为数值。对象与其它类型数据比较，先调用valueOf()方法将对象转为字符串，再按照上面规则判定。NaN与任何数据比较都是false。对象的比较是他们是否指向同一个对象。null==undefined返回ture。=== 是全等。如果比较的两者类型不同，则直接返回false。**方法的形参：**命名只是为了操作方便，内部实现不管形参定义，而是利用数组依次存储数据。可调用内部数组arguments读取传入的参数。JS的方法不存在重载。123456789function add()&#123; if(arguments.length==1) return argument[0]; if(arguments.length==2) return arguments[0] + argument[1];&#125;add(1) //输出1add(1,2) //输出3执行环境与作用域链执行环境：ECMAScript代码运行的环境执行环境用一个与之关联的变量对象表示，环境中所有的变量与函数都保存在该对象内部。环境对象的生命周期也就是内部变量与函数的声明周期。全局执行环境是最外围的执行环境，根据宿主环境不同，变量对象也不同。例如Web浏览器中的全局执行环境的变量对象为windows，浏览器关闭就相当于 windows 变量对象死亡，内部代码也消亡。每个函数也有自己的执行环境，进入函数内，函数环境推入环境栈，运行完毕弹出环境栈，类似于Java的虚拟机栈，会存在栈溢出错误。作用域链：定义了可访问变量的顺序。全局执行环境变量在最外围。函数内部变量在最前端，例如arguments。由前端向根部查找，找到便不再往后查找，哪怕存在重名变量。没有块级作用域与Java等C类语言不同， if或for等块级作用域声明的变量会被加入到全局执行环境中作为全局变量。1234for(var i=0; i&lt;10; i++) &#123; doSomeThing(i);&#125;alert(i); //输出10 引用数据类型对象其实是某个特定引用类型的实例，由一组键值对组成 {[key]:[value]}，属性名：属性值。Onject类型所有JS的对象类型都基于Object类，因此含有它一切的方法。hasOwnProperty(“propertyName”): 检查对象实例中属性是存在实例自身还是存在于原型对象中。isPrototypeOf(Object): 检查传入对象是否是传入对象的原型。toLocalString(): 返回本地环境的对象字符串表示。toString(): 返回对象的字符串表示。valueOf(): 返回对象的数值、字符串即布尔表示，一般与toString()返回相同。创建方法有两种。通过构造函数创建。1234// 用Object构造函数创建对象var obj = new Object();// 定义属性obj.name = \"syz\";通过对象字面量表示法12345678// 通过花括号将要赋值内容用的键值对表示// 空花括号与new Object()作用相当； var obj = &#123;&#125;;// 属性名可以是字符串、数字var obj = &#123; name : \"syz\", \"age\": 12, 12: 0&#125;对象属性访问方式也有两种通过对象加 .方式引用，但不能引用数字及会导致引用语法错误的字符。123456789var person = &#123; name: \"syz\", age: 12, 12: 0&#125;// 访问name及agr属性alert(person.name);alert(person.age);// 但不能访问属性 12， person.12是语法错误通过中括号+属性字符串方式引用，可通过变量访问属性。123456789101112var person = &#123; name: \"syz\", age: 12, 12: 0&#125;// 访问name属性alert(person[\"name\"]);// 访问age属性var propertyName = \"age\";alert(person[propertyName]);//访问12属性alert(person[\"12\"]);Array类型JS的数组比Java的强大太多，不仅可以支持类似于Python的切片功能，而且还可以模拟队列、栈等数据结构，还能够很方便的实现数组的迭代、拼接、插入、删除等功能。新建Array有两种方式。通过Array构造函数创建，可省略new关键字。123var arr0 = new Array(); // 构建数组var arr1 = Array(5); // 预定义长度为5的数组，每一项为 undefinedvar arr2 = Array(\"1\",2,\"test\"); // 可以存储任何类型的数据，且长度是动态扩展的通过数组字面量表示法1var arr = [1, \"test\"];数组的length属性数组的length属性不是可读的，可以控制它实现数据的删除与扩展操作。1234var arr = [1,2,3];arr.length = 2;alert(arr[2]); // 返回unfefinedarr.length = 99; // 2-98位置都为undefined检查数组由于全局执行环境可能有多种（框架多种），不同环境的Array定义不同，所以采用 instanceOf Array可能有错误。采用Array.isArray()方法来判断。打印数组调用toString()打印（默认采用）;采用join(&quot;||&quot;)打印，里面接收分隔符。12var a = [1,2,3];alert(a.join(\"||\")); //打印 1||2||3数组的类栈操作push()方法入栈，返回数组长度pop()方法出栈，移除并返回数组最后一个元素数组的类队列操作push()方法入队列shift()方法出队列，即移除并返回数组第一个元素unshift()方法反向入队列，即在数据第一个位置插入，并返回数组长度pop()方法反向出队列，移除并返回数组最后一个元素数组拼接、切片、插入与删除concat()函数实现拼接新元素，并返回新数组123var arr = [1,2,3];var arr2 = arr.concat(\"3\",[\"string\", 4, 5]);console.log(arr2); //打印 1,2,3,3,string,4,5 -**slice(startIndex, endIndex)函数**实现数组切片,返回新数组 123456789101112var arr = [1,2,3,4,5];var arr2 = arr.slice(1,3); console.log(arr2); // 输出[2,3]arr2 = arr.slice(3);console.log(arr2); // 输出[4,5],默认从位置3开始切片到末尾arr2 = arr.slice(-1);console.log(arr2); // 输出[5],从最后的位置开始切片arr2 = arr.slice(-3,-1);console.log(arr2); // 输出[3, 4],从倒数第3位置开始切分，不包括倒数第一位置的数 - **splice(startIndex, removeNum, insertElement)方法**插入与删除元素，返回删除的数据 123456789101112var arr = [1,2,3,4,5];arr.splice(0, 0, [1,2,3]);console.log(arr); //输出[ [ 1, 2, 3 ], 1, 2, 3, 4, 5 ]， 即在首位插入[1,2,3]var arr = [1,2,3,4,5];var deleteEle = arr.splice(1, 4);console.log(arr); // 输出 [1]，即从第二个位置删除4项console.log(deleteEle); // 输出[2,3,4,5]，即删除的数据var arr = [1,2,3,4,5];arr.splice(1,2,\"insertEle\");console.log(arr); // 输出[ 1,'insertEle', 4, 5 ]，即从第位置1删除两项并在位置1开始插入\"insertEle\"+ **数组的排序** - **reverse()函数**，颠倒数组 12var a = [1,2,3];console.log(a.reverse()); //输出[3,2,1] - **sort()函数**，排序数组，默认是先把元素转为字符串，然后排序 1234567891011121314// 默认字符串排序var a = [1,5, 10, 15, 20];console.log(a.sort()); //输出[ 1, 10, 15, 20, 5 ]//传入比较函数，实现自定义排序/*比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。*/function compare(v1, v2)&#123; // 逆序 return v2-v1;&#125;console.log(a.sort(compare)); //输出[[ 20, 15, 10, 5, 1 ]]+ **数组元素位置查询** - indexOf(searchLocation)，从指定位置顺序查询 - lastIndexOf(searchLocation)，从指定位置逆序查询 + **数组迭代** 每个迭代方法都接收两个参数：**要在每一项上运行的函数和（可选的）运行该函数的作用域对象**——影响 this 的值。传入这些方法中的函数会接收三个参数：**数组项的值、该项在数组中的位置和数组对象本身**。 - **every()**：对数组中的每一项运行给定函数，如果该函数对**每一项**都返回 true，则返回 true。 - **filter()**：对数组中的每一项运行给定函数，**返回该函数会返回 true 的项组成的数组**。 - **forEach()**：对数组中的每一项运行给定函数。这个方法没有返回值。 - **map()**：对数组中的每一项运行给定函数，返回**每次函数调用的结果组成的数组**。 - **some()**：对数组中的每一项运行给定函数，如果该函数对**任一项**返回 true，则返回 true。 1234567891011121314151617181920212223242526// everyvar numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(everyResult); // false// somevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(someResult); //true// filtervar numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(filterResult); //[3,4,5,4,3]// mapvar numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;); alert(mapResult); //[2,4,6,8,10,8,6,4,2]+ **数组归并** 两个归并数组的方法：**reduce()和 reduceRight()**。归并元素生成一个值。 两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 传给 reduce()和 reduceRight()的函数接收4个参数：**前一个值、当前值、项的索引和数组对象。** 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;); alert(sum); //15Function类型所有的函数都是Function类型的实例，因此函数名也就是实例的指针，函数可以拥有方法和属性，函数也可以作为参数传入另一个函数或对象中，就跟一个对象没区别。创建函数123456789101112131415161718192021222324/* 使用函数声明定义函数,此时存在函数声明提升的过程。即在代码还没运行前，将函数声明的函数解析并放到代码树的顶端，以供后面的代码使用。*/alert(sum1(1,2)); //可以执行，因为sum1已经被提升到最前端// 函数声明方式创建function sum1(d1, d2)&#123; return d1 + d2;&#125;// 函数表达式创建// alert(sum(1, 2)) 报错，因为函数表达式不会有函数提升过程var sum = function(d1, d2)&#123; return d1 + d2;&#125;; //有分号// 函数可以作为 对象/参数 传入函数function apply(fc, num1, num2)&#123; return fc(num1, num2);&#125;function sum(d1, d2)&#123; return d1 + d2;&#125;alert(apply(sum,1,2)); // 输出3- **apply()与call()方法** **两个都是Function除Object对象自带函数外内置的另外两个函数，作用是在指定的环境中运行某函数**，两个方法接收两个参数，第一个表示当前环境的指针，另一个表示传入的参数。区别是，apply第二个可以是参数属性arguments或者是数组，而call()必须是参数依次列出。 1234567891011121314151617181920212223242526272829303132// apply应用场景function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]);&#125;alert(callSum1(10,10)); alert(callSum2(10,10));// call应用场景function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125; alert(callSum(10,10));// apply在指定环境运行函数var color = \"red\";var o = &#123;color:\"blue\"&#125;;function sayColor()&#123; return this.color;&#125;alert(sayColor()); //redalert(sayColor.call(this)); // red 全局执行环境，即windowsalert(sayColor.call(whidows)); // red 全局执行环境alert(sayColor.call(o)); // blue 执行环境为对象oarguments对象与this对象arguments表示传入的参数数组，该对象具有属性length及callee。lenght属性查看传入参数的数量。callee，获得包含arguments的函数指针123456789// 阶乘函数function factorial(num)&#123; if(num&lt;=1) return num; // 与函数名解耦 return arguments.callee(num-1)*num;&#125;var fc2 = factorial;alert(fc2(10));this对象指向表示函数的执行环境的对象。length与prototype属性length表示函数希望接收的参数个数。prototype保存函数的所有实例方法。基本包装类型JS在生成一个基本类型数据时，同时产生一个基本包装类型，为读取基本数据的一些操作提供执行方法的入口。1234var str = \"Hello JS\"；str.substring(0,5)；str.name = \"str\";alert(str.name); //输出undefined，因为执行完毕后立即销毁该包装类型对象上面的例子生成一个string类型的基本数据，但是调用substring()方法时，是调用的同时生成的基本包装类型String对象内的方法。在执行完毕后该对象立马销毁。基本包装类型有Boolean、Number和String，都有Object内置的toString()、toLocalString()以及valueOf()等方法。String包装类型内置方法三种切片方法substring、slice及substr，返回新的字符串**substring(startIndex, endIndex)😗*在索引都是正数时，与slice()一样，但是遇到负数取零。**slice(startIndex, endIndex)😗*与数组切片方法一致。substr(startIndex, cut_length): 第一个切片起点，第二个切片长度，长度为负数时返回空字符串&quot;&quot;。charAt()与charCodeAt(): 分别返回所在位置的字符及字符编码。length: 放回字符数量。concat(): 拼接字符串，返回新字符串。split(): 用指定字符切割字符串，第一个参数是切割字符，第二个可选参数为返回数组的长度。match()与search(): 子字符串的查找。Number包装类型toFixed(n): 精确到小数点后n位。toExponential(n): 用指数表示法表示，n为精确的小数点位数。toPrecision(n): n为显示数值的位数，根据情况调用toFixed()或toExponential()方法。Boolean包装类型不推荐使用。Global对象与Math对象全局对象Global是JS最终的“兜底”对象，所有对象包含在其内部，不属于其它方法(如isNaN()、isFinite())与属性(如NaN、undifined)都属于它的方法与属性。例如windows对象就是一个全局对象。**Global对象的属性**Math对象是为数学运算设计的，包括常用的max()、min()、ceil()、floor()、round()及random()方法等。其中，max()与min()与java不同的是，可以比较获得所有数据的最大值与最小值。 总结JavaScript是按照ECMAScript语言标准设计，可操作DOM、BOM接口与方法的一门前端语言。JavaScript数据类型分为五种基本数据类型与引用数据类型。基本数据类型存储在栈内存中，且是final的，即不可修改。引用数据类型的变量名存储在栈内存中存储实例的指针，内容存储在堆内存中，以键值对方式保存。JavaScript语言的类型都是松散型的，且为顺序执行。让我们拥抱JS，一起迎接大前端时代吧！","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://sunyunzeng.com/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sunyunzeng.com/tags/JavaScript/"}]},{"title":"LeetCode 96.不同的二叉搜索树","slug":"LeetCode-96-不同的二叉搜索树","date":"2019-11-12","updated":"2020-01-11","comments":true,"path":"LeetCode-96-不同的二叉搜索树/","link":"","permalink":"http://sunyunzeng.com/LeetCode-96-不同的二叉搜索树/","excerpt":"","text":"题目给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？示例:12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 思路 + 代码动态规划。假设 整数 n对应的二叉搜索树数量为 G(n)。每个节点 i ∈ (0,n] 为根节点对应的二叉搜索树数量为 F(i)。则， G(n) = F(1) + F(2) + F(3) + … + F(n)。而 节点i 为根节点的二叉搜索树，可以分为 i-1 个左子树 跟 n-i个右子树，F(i) = G(i-1)*G(n-i);因此 G(n) = G(0)*G(n-1) + G(1)*G(n-2) + G(2)*G(n-3) + … + G(n-1)*G(0)因此1234567891011121314class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0]=1; // 边界条件 dp[1]=1; for(int i=2; i&lt;=n; i++)&#123; for(int j=1; j&lt;=i; j++)&#123; // 节点i为根节点对应的二叉搜索树数量 dp[i] += dp[j-1]*dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 208.实现Trie(前缀树)","slug":"LeetCode-208-实现Trie-前缀树","date":"2019-11-11","updated":"2020-01-11","comments":true,"path":"LeetCode-208-实现Trie-前缀树/","link":"","permalink":"http://sunyunzeng.com/LeetCode-208-实现Trie-前缀树/","excerpt":"","text":"题目实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。示例:12345678Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\"); // 返回 truetrie.search(\"app\"); // 返回 falsetrie.startsWith(\"app\"); // 返回 truetrie.insert(\"app\"); trie.search(\"app\"); // 返回 true说明:你可以假设所有的输入都是由小写字母 a-z 构成的。保证所有输入均为非空字符串。 思路 + 代码题解实现一个链表，每一个链表节点存储的是数组，数组包含所有可能的键（这里指26个字符）。类似于HashMap的entry结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Trie &#123; private class TrieNode&#123; private TrieNode[] links; private boolean isEnd; TrieNode()&#123; links = new TrieNode[26]; &#125; public boolean containsKey(char c)&#123; return links[c-'a']!=null; &#125; public TrieNode get(char c)&#123; return links[c-'a']; &#125; public void set(char c, TrieNode node)&#123; links[c-'a'] = node; &#125; public void setEnd()&#123; this.isEnd = true; &#125; public boolean isEnd()&#123; return this.isEnd; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode node = root; for(int i=0; i&lt;word.length(); i++)&#123; char c = word.charAt(i); if(!node.containsKey(c))&#123; node.set(c, new TrieNode()); &#125; node = node.get(c); &#125; node.setEnd(); &#125; private TrieNode searchPrefix(String word)&#123; TrieNode node = root; for(int i=0; i&lt;word.length(); i++)&#123; char c = word.charAt(i); if(node.containsKey(c)) node = node.get(c); else return null; &#125; return node; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node!=null &amp;&amp; node.isEnd(); &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node!=null; &#125; &#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 221.最大正方形","slug":"LeetCode-221-最大正方形","date":"2019-11-09","updated":"2020-01-11","comments":true,"path":"LeetCode-221-最大正方形/","link":"","permalink":"http://sunyunzeng.com/LeetCode-221-最大正方形/","excerpt":"","text":"题目在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。示例：12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 思路 + 代码是动态规划的题目。关键在于问题的转化。问题转化为最长边长。然后截止当前位置的最长边长是左边、上边及右上三者中的最小值 + 1。12345678910111213141516171819class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if(matrix.length==0 || matrix[0].length==0) return 0; int row = matrix.length; int col = matrix[0].length; int[][] dp = new int[row+1][col+1]; int max_side = 0; for(int i=1; i&lt;=row; i++)&#123; for(int j=1; j&lt;=col; j++)&#123; if(matrix[i-1][j-1]=='1')&#123; dp[i][j] = Math.min(Math.min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1])+1; max_side = Math.max(max_side, dp[i][j]); &#125; &#125; &#125; return max_side*max_side; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 62.不同路径","slug":"LeetCode-62-不同路径","date":"2019-11-08","updated":"2020-01-11","comments":true,"path":"LeetCode-62-不同路径/","link":"","permalink":"http://sunyunzeng.com/LeetCode-62-不同路径/","excerpt":"","text":"题目一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？ 思路 + 代码动态规划。。用回溯竟然做不出来123456789101112131415161718class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m&lt;=0 || n&lt;=0) return 0; int[][] dp = new int [m][n]; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0) dp[i][j] = 1; else if(j==0) dp[i][j] = 1; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 238.除自身以外数组的乘积","slug":"LeetCode-238-除自身以外数组的乘积","date":"2019-11-07","updated":"2020-01-11","comments":true,"path":"LeetCode-238-除自身以外数组的乘积/","link":"","permalink":"http://sunyunzeng.com/LeetCode-238-除自身以外数组的乘积/","excerpt":"","text":"题目给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。示例：12输入: [1,2,3,4]输出: [24,12,8,6]**说明：**请不要使用除法，且在 O(n) 时间复杂度内完成此题。 思路 + 代码不能常规的循环暴力解决，因为时间限制在O(n)内。考虑上三角/下三角的乘法。123456789101112131415161718class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int len = nums.length; int[] res = new int[len]; Arrays.fill(res, 1); int left = 1, right=1; for(int i=0; i&lt;len; i++) &#123; // 只经过左指针操作，res[0] = 1, res[1] = 1, res[2] = 1*2, res[3] = 1*2*3 res[i] *= left; left *= nums[i]; // 只经过右指针操作，res[0] = 2*3*4, res[1] = 3*4, res[2] = 4 res[3] = 1 res[len-1-i] *= right; right *= nums[len-1-i]; // 上下相乘得到结果 &#125; return res; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 114.二叉树展开为链表","slug":"LeetCode-114-二叉树展开为链表","date":"2019-11-06","updated":"2020-01-11","comments":true,"path":"LeetCode-114-二叉树展开为链表/","link":"","permalink":"http://sunyunzeng.com/LeetCode-114-二叉树展开为链表/","excerpt":"","text":"题目给定一个二叉树，原地将它展开为链表。例如，给定二叉树：12345 1 / \\ 2 5 / \\ \\3 4 6将其展开为：12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 题解 + 思路一开始想的是递归，但是递归是由底向顶递归生成，而这道题是由顶到底生成，虽然存在子问题，但是仍难以求解。其实可以看做如下步骤：找到左子树的最右节点。12345 1 / \\ 2 5 / \\ \\3 4 6将右子树移到左子树的最右节点。123456789 1 / 2 / \\ 3 4 \\ 5 \\ 6右子树换为左子树，左子树置为 null1234567891 \\ 2 / \\ 3 4 \\ 5 \\ 6从右节点开始，继续该操作12345678910111 \\ 2 \\ 4 \\ 5 \\ 6 \\ 3123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; while(root!=null)&#123; if(root.left==null)&#123; root=root.right; &#125;else&#123; TreeNode pre = root.left; while(pre.right!=null)&#123; pre = pre.right; &#125; pre.right = root.right; root.right = root.left; root.left = null; root = root.right; &#125; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"LeetCode 22.括号生成","slug":"LeetCode-22-括号生成","date":"2019-11-05","updated":"2020-01-11","comments":true,"path":"LeetCode-22-括号生成/","link":"","permalink":"http://sunyunzeng.com/LeetCode-22-括号生成/","excerpt":"","text":"题目给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：1234567[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"] 思路 + 代码回溯法，通过两个整数统计“（”与“）”的数量。1234567891011121314151617181920class Solution &#123; private List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; if(n&lt;1) return res; backtracing(\"\", 0, 0, n); return res; &#125; private void backtracing(String s, int open, int close, int n)&#123; if(close&gt;open || open&gt;n || close&gt;n) return; if(s.length()==2*n)&#123; res.add(s); return; &#125; String str = new String(s); backtracing(str+\"(\", open+1, close, n); backtracing(str+\")\", open, close+1, n); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 437.路径总和 III","slug":"LeetCode-437-路径总和","date":"2019-11-05","updated":"2020-01-11","comments":true,"path":"LeetCode-437-路径总和/","link":"","permalink":"http://sunyunzeng.com/LeetCode-437-路径总和/","excerpt":"","text":"题目给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。示例1：123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路 + 代码双重递归。首先建立一个递归寻找以每个节点为根节点的路径查找。再建立一个递归遍历每一个节点，并以该节点为根节点。1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int cnt = 0; public int pathSum(TreeNode root, int sum) &#123; helper(root, sum); return cnt; &#125; private void helper(TreeNode root, int sum)&#123; if(root==null) return; search(root, sum, root.val); helper(root.left, sum); helper(root.right, sum); &#125; private void search(TreeNode root, int sum, int tmp)&#123; if(sum==tmp)&#123; cnt++; &#125; if(root.left!=null) search(root.left, sum, tmp+root.left.val); if(root.right!=null) search(root.right, sum, tmp+root.right.val); &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"LeetCode 494.目标和","slug":"LeetCode-494-目标和","date":"2019-11-04","updated":"2020-01-11","comments":true,"path":"LeetCode-494-目标和/","link":"","permalink":"http://sunyunzeng.com/LeetCode-494-目标和/","excerpt":"","text":"题目给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。示例1：1234567891011输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。注意：数组非空，且长度不会超过20。初始的数组的和不会超过1000。保证返回的最终结果能被32位整数存下。 思路 + 代码首先是回溯方法。12345678910111213141516class Solution &#123; private int cnt = 0; public int findTargetSumWays(int[] nums, int S) &#123; dfs(nums, S, 0, 0); return cnt; &#125; private void dfs(int[]nums, int S, int tmpS, int location)&#123; if(location==nums.length)&#123; if(S==tmpS) cnt++; return; &#125; dfs(nums, S, tmpS + nums[location], location+1); dfs(nums, S, tmpS - nums[location], location+1); &#125;&#125;然后是动态规划一个数组可分为两个子集和 X 跟 Y，然后 X-Y=S，X+Y=Sum，由此得到 X=(Sum+S)/2。也就是寻找一个子集和X，满足 X=(Sum+S)/2，此和且为整数。123456789101112131415161718192021class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; int sum = 0; for(int n: nums)&#123; sum += n; &#125; if(sum &lt; S || (sum+S)%2!=0)&#123; return 0; &#125; int s = (sum+S)/2; int[] dp = new dp[s+1]; dp[0] = 1; for(int n: nums)&#123; for(int i=s; i&gt;=n; i--)&#123; // 如果考虑数n，结果数为dp[i]，否则为dp[i-n] dp[i] += dp[i-n]; &#125; &#125; return dp[s]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/target-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 160.相交链表","slug":"LeetCode-160相交链表","date":"2019-11-04","updated":"2020-01-11","comments":true,"path":"LeetCode-160相交链表/","link":"","permalink":"http://sunyunzeng.com/LeetCode-160相交链表/","excerpt":"","text":"题目编写一个程序，找到两个单链表相交的起始节点。 思路 + 代码1. 最容易想到的，两层遍历求解。12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode tmp; while(headA!=null)&#123; tmp = headB; while(tmp!=null)&#123; if(tmp!=headA) return tmp; tmp = tmp.next; &#125; headA = headA.next; &#125; return null; &#125;&#125;时间复杂度O(M*N)空间复杂度O(1)2. 利用Map记录一个链表的每个节点，第二个链表寻找第一次出现的节点。12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; Map&lt;ListNode,Integer&gt; map = new HashMap&lt;ListNode,Integer&gt;(); while(headA!=null)&#123; map.put(headA,1); headA = headA.next; &#125; while(headB!=null)&#123; if(map.containsKey(headB)) return headB; headB = headB.next; &#125; return null; &#125;&#125;时间复杂度O(M+N)空间复杂度O(M)或O(N)3. 或者两个指针，分别从两个链表的头结点开始，当一个节点遍历到尾部时换到另一个链表头部。即利用 a+all+b = b+all+a，也就是两个指针走的路程一样。12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode tmpA = headA; ListNode tmpB = headB; while(tmpA!=tmpB)&#123; tmpA = tmpA==null?headB:tmpA.next; tmpB = tmpB==null?headA:tmpB.next; &#125; return tmpA; return tmpA; &#125;&#125;时间复杂度O(M+N)空间复杂度O(1)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 23.合并K个排序链表","slug":"LeetCode-23-合并K个排序链表","date":"2019-11-03","updated":"2020-01-11","comments":true,"path":"LeetCode-23-合并K个排序链表/","link":"","permalink":"http://sunyunzeng.com/LeetCode-23-合并K个排序链表/","excerpt":"","text":"题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。示例：1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路 + 代码合并两个有序链表的翻版。123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null || lists.length==0) return null; if(lists.length==1) return lists[0]; ListNode res = lists[0]; for(int i=1; i&lt;lists.length; i++)&#123; res = mergeTwoLists(res, lists[i]); &#125; return res; &#125; // 合并两个有序链表的操作 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode prehead = new ListNode(0); ListNode node = prehead; while(l1!=null &amp;&amp; l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; node.next = l1; l1=l1.next; &#125;else&#123; node.next = l2; l2=l2.next; &#125; node = node.next; &#125; node.next=l1==null?l2:l1; return prehead.next; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 543.二叉树的直径","slug":"LeetCode-543-二叉树的直径","date":"2019-11-03","updated":"2020-01-11","comments":true,"path":"LeetCode-543-二叉树的直径/","link":"","permalink":"http://sunyunzeng.com/LeetCode-543-二叉树的直径/","excerpt":"","text":"题目给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。示例：给定二叉树12345 1 / \\ 2 3 / \\ 4 5返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。**注意：**两结点之间的路径长度是以它们之间边的数目表示。 思路 + 代码路径长度一定是以某个节点为根节点，左右子树的最大深度和。与题目求二叉树的最大深度类似1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum; public int diameterOfBinaryTree(TreeNode root) &#123; if(root==null) return 0; getDepth(root); return sum; &#125; private int getDepth(TreeNode root)&#123; if(root==null) return 0; int left = getDepth(root.left); int right = getDepth(root.right); sum = Math.max(sum, left+right ); return Math.max(left, right)+1; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 560.和为K的子数组","slug":"LeetCode-560-和为K的子数组","date":"2019-11-03","updated":"2020-01-11","comments":true,"path":"LeetCode-560-和为K的子数组/","link":"","permalink":"http://sunyunzeng.com/LeetCode-560-和为K的子数组/","excerpt":"","text":"题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。示例1：12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明：数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 思路1先固定数组的左侧位置，然后依次移动右侧指针，如何数组和为 k，结果加一。数组和置为零，更新左侧位置。1234567891011121314class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int res=0; for(int left=0; left&lt;nums.length; left++)&#123; int sum=0; for(int right = left; right&lt;nums.length; right++)&#123; sum += nums[right]; if(sum==k) res++; &#125; &#125; return res; &#125;&#125;此时空间复杂度为 1， 时间复杂度为 O(n)。 思路2只需要遍历一次，统计到各个位置的累积和。如果至 j 位置的和与至 i 位置的和差为k，那么位于 i~j 的子序列和为 k。用一个Map统计不同累积和出现的次数。12345678910111213class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int sum = 0, res = 0; for(int n: nums)&#123; sum += n; if(map.containsKey(sum-k)) res += map.get(sum-k); // map.getOrDefault(key, default)--如果存在键K就取出对应的V，否则值为default map.put(sum, map.getOrDefault(sum, 0)+1); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"LeetCode 621.任务调度器","slug":"LeetCode-621-任务调度器","date":"2019-11-02","updated":"2020-01-11","comments":true,"path":"LeetCode-621-任务调度器/","link":"","permalink":"http://sunyunzeng.com/LeetCode-621-任务调度器/","excerpt":"","text":"题目给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。你需要计算完成所有任务所需要的最短时间。示例1：12345678910输入: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.``` **注:**```java1. 任务的总个数为 [1, 10000]。2. n 的取值范围为 [0, 100]。 思路 + 代码 方法1规定 n + 1 个任务为一轮，这样的好处是同一轮中一个任务最多只能被安排一次。在每一轮中，我们将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 n + 1 个任务依次执行。如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。这样做的正确性在于，由于冷却时间的存在，出现次数较多的那些任务如果不尽早安排，将会导致大量空闲时间的出现，因此贪心地将出现次数较多的任务安排在前面是合理的。同时我们可以保证，这一轮的第 k 个任务距离上一次执行至少有 n 个单位的冷却时间。我们可以使用逆向思维来证明：假设第 r 轮中某个任务在第 k 个执行，那么说明它在第 r 轮时为数量第 k 多的任务。在第 r 轮结束后，第 1 多到第 k 多的任务的数量都会减少 1，因此在第 r + 1 轮，这个任务最多也只能是数量第 k 多，因此它如果被执行，一定满足冷却时间的要求。12345678910111213141516171819202122public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char c: tasks) map[c - 'A']++; Arrays.sort(map); int time = 0; while (map[25] &gt; 0) &#123; int i = 0; while (i &lt;= n) &#123; if (map[25] == 0) break; if (i &lt; 26 &amp;&amp; map[25 - i] &gt; 0) map[25 - i]--; time++; i++; &#125; Arrays.sort(map); &#125; return time; &#125;&#125; 方法2(count[25] - 1) * (n + 1) + maxCount假设数组 [“A”,“A”,“A”,“B”,“B”,“C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,“A”,“A”,“B”,“B”,“B”,“C”,“C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount公式算出的值可能会比数组的长度小，如[“A”,“A”,“B”,“B”]，n = 0，此时要取数组的长度1234567891011121314151617181920class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if(tasks==null || tasks.length==0 || n&lt;0) return 0; int len = tasks.length; int[] counts = new int[26]; // 统计数量 for(char c: tasks)&#123; counts[c-'A']++; &#125; int maxCount = 0; Arrays.sort(counts); for(int i=0; i&lt;26; i++) if(counts[i]==counts[25]) maxCount++; int res = (counts[25]-1)*(n+1)+maxCount; return res&lt;len?len:res; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/task-scheduler著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 581.最短无序连续子数组","slug":"Leetcode-581-最短无序连续子数组","date":"2019-11-02","updated":"2020-01-11","comments":true,"path":"Leetcode-581-最短无序连续子数组/","link":"","permalink":"http://sunyunzeng.com/Leetcode-581-最短无序连续子数组/","excerpt":"","text":"题目给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。你找到的子数组应是最短的，请输出它的长度。示例1：123输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。说明：输入的数组长度范围在 [1, 10,000]。输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 思路 + 代码首先用左右两个指针分别探测左右各自逆序的起点。此时序列对应的数值是局部最小值与局部最大值。然后在逆序序列(左边逆序开始与右边逆序开始位置之间)中寻找全局最小值与全局最大值。然后从左边开始遍历寻找小于等于全局最小值的边界；从右边寻找大于等于全局最大值的边界。左右边界构成数组的长度即为所求。12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; // 异常值处理 if(nums==null||nums.length&lt;=1) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; int len = nums.length; int i = 0, j = len-1; // 寻找左右逆序的边界 while(i+1&lt;len) if(nums[i+1]&lt;nums[i++]) break; while(j-1&gt;=0) if(nums[j-1]&gt;nums[j--]) break; // 如果i+1&gt;len，证明数组本身是升序的，返回0 if(i+1&gt;len) return 0; // 寻找全局最小值与全局最大值 do&#123; if(nums[i]&lt;min) min = nums[i]; &#125;while(++i&lt;len); do&#123; if(nums[j]&gt;max) max = nums[j]; &#125;while(--j&gt;=0); // 从左右分别开始遍历，找到逆序数组真实左右边界 i = 0; j = len-1; while(i&lt;len &amp;&amp; nums[] &lt;=min) i++; while(j&gt;=0 &amp;&amp; nums[j] &gt;=max) j--; return j-i+1&gt;0?j-i+1:0; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"归并排序 | 插入排序 | 希尔排序","slug":"Algorithm：归并排序","date":"2019-11-01","updated":"2020-01-11","comments":true,"path":"Algorithm：归并排序/","link":"","permalink":"http://sunyunzeng.com/Algorithm：归并排序/","excerpt":"","text":"插入排序每次遍历都将对应位置的数字插入到合适的位置，当前位置之前的数据保持排序。 代码12345678910111213141516public class InsertionSort &#123; public static int[] sort(int[] arr)&#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr, 0, A, 0, len); int i,j; for (i = 1; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j - 1] &gt; temp; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; return A; &#125;&#125; 希尔排序是插入排序的变种，通过根据步长对原数组切分，加大了视野范围。步长一直到1，此时交换的数量少，运行时间少。12345678910111213141516171819public class ShellSort&#123; public static int[] sort(int[] nums)&#123; if(nums==null || nums.length==0) return null; int len = nums.length; int[] A = new int[len]; System.arraycopy(nums,0,A,0,len); for(int step = len/2; step &gt; 0; step/=2)&#123; for(int i=step; i&lt;len; i++)&#123; int tmp = A[i]; int j; for(j=i; j&gt;=step &amp;&amp; A[j-step] &gt; tmp; j-=step) A[j] = A[j-step]; A[j] = tmp; &#125; &#125; return A; &#125;&#125; 归并排序分而治之的思想。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MergeSort &#123; public static int[] sort(int[] nums)&#123; if(nums==null || nums.length==0) return null; int len = nums.length; int[] A = new int[len]; System.arraycopy(nums, 0, A, 0, len); mergeSort(A, 0, A.length-1); return A; &#125; private static void mergeSort(int[] nums, int i, int j)&#123; if(i&gt;=j) return; int m = i + (j-i)/2; mergeSort(nums,i, m); mergeSort(nums, m+1, j); // m位置属于左数组 merge(nums, i, m, j); &#125; private static void merge(int[] nums, int i, int m, int j)&#123; int[] leftArr = new int[m-i+1]; int[] rightArr = new int[j-m]; // 辅助数组填充 for(int l=i; l&lt;=m; l++)&#123; leftArr[l-i] = nums[l]; &#125; for(int r=m+1; r&lt;=j; r++)&#123; rightArr[r-m-1] = nums[r]; &#125; int l = 0, r = 0, k=i; while(l&lt;leftArr.length &amp;&amp; r&lt;rightArr.length)&#123; if(leftArr[l]&lt;rightArr[r])&#123; nums[k++]=leftArr[l++]; &#125;else&#123; nums[k++] = rightArr[r++]; &#125; &#125; while(l&lt;leftArr.length) nums[k++] = leftArr[l++]; while (r&lt;rightArr.length) nums[k++] = rightArr[r++]; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://sunyunzeng.com/tags/排序算法/"}]},{"title":"MySQL：入门","slug":"MySQL：入门","date":"2019-10-31","updated":"2020-01-11","comments":true,"path":"MySQL：入门/","link":"","permalink":"http://sunyunzeng.com/MySQL：入门/","excerpt":"","text":"MySQL 简介MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。MySQL具有以下优点： 成本——MySQL是开放源代码的，一般可以免费使用（甚至可以 免费修改）。 性能——MySQL执行很快（非常快）。  可信赖——某些非常重要和声望很高的公司、站点使用MySQL， 这些公司和站点都用MySQL来处理自己的重要数据。 简单——MySQL很容易安装和使用。 基础入门启动服务Windows：1net start mysqlubuntu:1sudo service mysql start登录12mysql -u root -p*****查看已有数据库1SHOW DATABASES;创建数据库1CREATE DATABASE;使用数据库1USE DATABASE;显示所有表1SHOW TABLES;显示已有表的所有列1SHOW COLUMNS FROM YOURDATABASE;创建表1CREATE TABLE book(name char(20), author char(20));在表中插入数据123INSERT INTO book VALUES('C++ Primer', 'Stanley B. Lippman');INSERT INTO book VALUES('Thinking in JAVA', 'Bruce Eckel');INSERT INTO book VALUES('Easy Python', 'Kukeel Borant');查看表中数据1SELECT * FROM book; 选择数据 SELECT选择单列1SELECT name FROM book;选择多列1SELECT name, author FROM book;选择所有列1SELECT * FROM book;检索不同行1SELECT DISTINCT author FROM book;限制检索的行数从第一行开始，返回结果不超过3行123SELECT author FROM bookLIMIT 3从第3行（第一行为0）开始，只检索结果不超过3行123SELECT author FROM bookLIMIT 2，3完全限定的表名指定从表 book 中选择 author 列从数据库 library 中选择 book 表12SELECT book.authorFROM library.book; 排序检索数据关系数据库设计理论认为，如果不明确规定排序顺序，则不应假设检索出得数据的顺序有意义。SQL语句由字句(clause)构成，有的字句是必需的，而有的是可选的。OREDR BY 关键字句排序默认升序排序123SELECT authorFROM bookOREDER BY name;还可以显示多列，添加多列约束，约束规则是在优先级高的数据有重复时，再按低一级的约束列排序。123SELECT author, nameFROM bookORDER BY price, name;指定排序方向DESC逆序排列。只对价格逆序排列123SELECT author, nameFROM bookORDER BY price DESC, name;集合 LIMIT 与 ORDER 挑选最贵书籍1234SELECT nameFROM bookORDER BY price DESCLIMIT 1; 过滤数据通过关键字 WHERE 进行数据过滤操作符说明=等于&lt;&gt;不等于!=不等于&lt;小于&gt;大于&lt;=小于等于&gt;=大于等于BETWEEN在指定两个值之间过滤行123SELECT nameFROM bookWHERE name = 'Machine Learning';阈值过滤123SELECT nameFROM bookWHERE price BETWEEN 5 AND 10;空值检查123SELECT idFROM bookWHERE price is NULL; LIKE 通配符搜索通配符是 WHERE 字句中具有特殊含义的字符% 通配符% 通配符表示匹配任意字符出现任意次匹配 Mach 开头的书名123SELECT nameFROM bookWHERE name LIKE 'Mach%';_ 通配符_ 通配符表示任意字符出现一次123SELECT nameFROM bookWHERE name LIKE '_ach%'; 插入数据在首列插入新字段123ALTER TABLE booksADD COLUMN price float(5,2) --总共5位，小数2位NOT NULL FRIST;在某列后插入新字段123ALTER TABLE booksADD COLUMN price float(5,2) --总共5位，小数2位NOT NULL AFTER author;默认插入最后一列123ALTER TABLE booksADD COLUMN price float(5,2) --总共5位，小数2位NOT NULL; 更新数据一定记得加 WHERE 字句限定更新指定单行与单列123UPDATE bookSET price = 10.23WHERE id = 0;更新指定多列与单行1234UPDATE bookSET price = 8.88, --多行之间逗号隔开 name = 'Machine Learning'WHERE id = 0;通过设置为NULL 删除某列的值123UPDATE bookSET price = NULLWHERE id = 0; 删除数据一定记得加 WHERE 字句限定删除某一行12DELECT FROM bookWHERE id = 0;删除某一列属于重构表结构，谨慎选择12ALTER TABLE bookDROP COLUMN price;","categories":[{"name":"数据库管理系统","slug":"数据库管理系统","permalink":"http://sunyunzeng.com/categories/数据库管理系统/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sunyunzeng.com/tags/MySQL/"}]},{"title":"剑指Offer：剪绳子","slug":"剑指Offer：剪绳子","date":"2019-10-31","updated":"2020-01-11","comments":true,"path":"剑指Offer：剪绳子/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：剪绳子/","excerpt":"","text":"题目给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。（2 &lt;= n &lt;= 60） 思路 + 代码动态规划可以分解子问题，即剪一刀，产生两段绳子，长度分别是 i 与 n-i, 在这两条绳子上可以继续剪：1f(n) = max(f(i), f(n-i))123456789101112131415public class Solution &#123; public int cutRope(int target) &#123; int[] dp = new int[target+1]; dp[1] = 1; for(int i=2; i&lt;=target; i++)&#123; for(int j=1; j&lt;i; j++)&#123; // 剪一刀长度为j，则产生长度为j与i-j长度的绳子 // 进而判断长度为j的绳子的大值，为max(j, dp[j]); // 最后去dp[j]的最大值 dp[i] = Math.max(dp[i], Math.max(j*(i-j), dp[j]*(i-j))); &#125; &#125; return dp[target]; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：机器人的运动范围","slug":"剑指Offer：机器人的运动范围","date":"2019-10-31","updated":"2020-01-11","comments":true,"path":"剑指Offer：机器人的运动范围/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：机器人的运动范围/","excerpt":"","text":"题目地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路 + 代码回溯方法，类似题目1、题目212345678910111213141516171819202122232425262728293031323334public class Solution &#123; private int k; private int res; private int[][] next = new int[][]&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; public int movingCount(int threshold, int rows, int cols) &#123; if(rows&lt;=0 || cols&lt;=0 || threshold&lt;0) return 0; k = threshold; res = 0; boolean[][] visit = new boolean[rows][cols]; dfs(0,0, visit); return res; &#125; private void dfs(int i, int j, boolean[][] visit)&#123; if(i&lt;0 || j&lt;0 || i&gt;=visit.length || j&gt;=visit[0].length || k&lt;calNum(i)+calNum(j) || visit[i][j] )&#123; return; &#125; res++; visit[i][j] = true; for(int[] step: next)&#123; dfs(i+step[0], j+step[1], visit); &#125; return; &#125; private int calNum(int num)&#123; int res = 0; while(num &gt; 0)&#123; res += num%10; num /= 10; &#125; return res; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"},{"name":"backtrace","slug":"backtrace","permalink":"http://sunyunzeng.com/tags/backtrace/"}]},{"title":"剑指Offer：滑动窗口的最大值","slug":"剑指Offer：滑动窗口的最大值","date":"2019-10-31","updated":"2020-01-11","comments":true,"path":"剑指Offer：滑动窗口的最大值/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：滑动窗口的最大值/","excerpt":"","text":"题目给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路 + 代码用一个最大堆维护中间的判断结果，每次只需对顶元素调整即可。1234567891011121314151617181920import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(size&lt;=0 || size&gt;num.length) return res; // 最大堆维护结果 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;((o1, o2)-&gt;o2-o1); for(int i=0; i&lt;size; i++) queue.add(num[i]); res.add(queue.peek()); for(int i=size; i&lt;num.length; i++)&#123; queue.remove(num[i-size]); queue.add(num[i]); res.add(queue.peek()); &#125; return res; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：数据流中的中位数","slug":"剑指Offer：数据流中的中位数","date":"2019-10-31","updated":"2020-01-11","comments":true,"path":"剑指Offer：数据流中的中位数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：数据流中的中位数/","excerpt":"","text":"题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 思路 + 代码参考CyC12345678910111213141516171819202122232425import java.util.*;public class Solution &#123; // left-最大堆 right-最小堆 private PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;Integer&gt;((o1, o2)-&gt;o2-o1); private PriorityQueue&lt;Integer&gt; right = new PriorityQueue&lt;Integer&gt;(); private int N = 0; public void Insert(Integer num) &#123; if(N%2==0)&#123; left.add(num); right.add(left.poll()); &#125;else&#123; right.add(num); left.add(right.poll()); &#125; // N是滞后计数，表示一数据流的长度是多少 N++; &#125; public Double GetMedian() &#123; if(N%2==0)&#123; return (left.peek()+right.peek())/2.0; &#125;else&#123; return (double)right.peek(); &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：二叉搜索树的第k个结点","slug":"剑指Offer：二叉搜索树的第k个结点","date":"2019-10-30","updated":"2020-01-11","comments":true,"path":"剑指Offer：二叉搜索树的第k个结点/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：二叉搜索树的第k个结点/","excerpt":"","text":"题目给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路 + 代码其实就是二叉搜索树的中序遍历翻版。1234567891011121314151617181920212223242526272829303132333435/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private int cnt; private TreeNode node; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(k&lt;1) return null; cnt = 0; inOrder(pRoot, k); return node; &#125; private void inOrder(TreeNode pRoot, int k)&#123; if(cnt&gt;=k || pRoot==null) return; inOrder(pRoot.left, k); cnt++; if(cnt==k)&#123; node = pRoot; &#125; inOrder(pRoot.right, k); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Search-Tree/"}]},{"title":"剑指Offer：序列化二叉树","slug":"剑指Offer：序列化二叉树","date":"2019-10-30","updated":"2020-01-11","comments":true,"path":"剑指Offer：序列化二叉树/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：序列化二叉树/","excerpt":"","text":"题目请实现两个函数，分别用来序列化和反序列化二叉树二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 思路 + 代码递归序列化与递归反序列化。123456789101112131415161718192021222324252627282930313233343536373839/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private String deserializeStr; String Serialize(TreeNode root) &#123; if(root==null) return \"#\"; return root.val + \" \" + Serialize(root.left) + \" \" + Serialize(root.right); &#125; TreeNode Deserialize(String str) &#123; deserializeStr = str; return Deserialize(); &#125; TreeNode Deserialize()&#123; if(deserializeStr.length()==0) return null; int index = deserializeStr.indexOf(\" \"); String node = index==-1?deserializeStr:deserializeStr.substring(0, index); deserializeStr = index==-1?\"\":deserializeStr.substring(index+1); if(node.equals(\"#\")) return null; int val = Integer.valueOf(node); TreeNode root = new TreeNode(val); root.left = Deserialize(); root.right = Deserialize(); return root; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：按之字形顺序打印二叉树","slug":"剑指Offer：按之字形顺序打印二叉树","date":"2019-10-29","updated":"2020-01-11","comments":true,"path":"剑指Offer：按之字形顺序打印二叉树/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：按之字形顺序打印二叉树/","excerpt":"","text":"题目请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路 + 代码其实就是二叉树层次遍历的变体。遍历过程中，如果是二叉树的偶数层，就顺序遍历；否则逆序遍历。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(pRoot == null) return res; int layer = 0; int location = 0; queue.add(pRoot); while(!queue.isEmpty())&#123; int len = queue.size(); Integer[] nums = new Integer[len]; for(int i=0;i&lt;len; ++i)&#123; TreeNode tmp = queue.remove(); if(layer%2!=0) location = len-1-i; else location = i; nums[location]=tmp.val; if(tmp.left!=null) queue.add(tmp.left); if(tmp.right!=null) queue.add(tmp.right); &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Collections.addAll(list, nums); if(list.size()&gt;0) res.add(list); layer++; &#125; return res; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：二叉树的下一个结点","slug":"剑指Offer：二叉树的下一个结点","date":"2019-10-28","updated":"2020-01-11","comments":true,"path":"剑指Offer：二叉树的下一个结点/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：二叉树的下一个结点/","excerpt":"","text":"题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路 + 代码树的问题最容易想到的就是递归方法。中序遍历顺序是左叶子节点、根节点、右叶子节点。分为两种情况：如果右子节点不为空，则递归寻找后面最左叶子节点。如果右子节点为空，则递归在父级节点寻找。2.1 如果父节点为空，则返回 null。2.2 如果父节点左节点等于该节点，则返回父节点。2.3 如果父节点右节点等于该节点，则继续递归寻找。123456789101112131415161718192021222324252627282930313233343536373839/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null) return null; if(pNode.right!=null) return getRightNode(pNode.right); else return getParentNode(pNode); &#125; // 寻找最左节点 private TreeLinkNode getRightNode(TreeLinkNode pNode)&#123; if(pNode.left==null) return pNode; else return getRightNode(pNode.left); &#125; // 如果没有右节点，下一节点则是父级节点 private TreeLinkNode getParentNode(TreeLinkNode pNode)&#123; if(pNode.next==null) return null; if(pNode.next.left == pNode) return pNode.next; else return getParentNode(pNode.next); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：删除链表中重复的节点","slug":"剑指Offer：删除链表中重复的节点","date":"2019-10-27","updated":"2020-01-11","comments":true,"path":"剑指Offer：删除链表中重复的节点/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：删除链表中重复的节点/","excerpt":"","text":"题目在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路 + 代码利用递归求解，问题分解为去除下一个节点开始链表中重复的节点。123456789101112131415161718192021222324252627/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead==null || pHead.next==null) return pHead; ListNode next = pHead.next; if(pHead.val==next.val)&#123; while(next!=null &amp;&amp; pHead.val == next.val) next = next.next; return deleteDuplication(next); &#125;else&#123; pHead.next = deleteDuplication(pHead.next); return pHead; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：字符流中第一个不重复的字符","slug":"剑指Offer：字符流中第一个不重复的字符","date":"2019-10-26","updated":"2020-01-11","comments":true,"path":"剑指Offer：字符流中第一个不重复的字符/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：字符流中第一个不重复的字符/","excerpt":"","text":"题目请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。如果当前字符流没有存在出现一次的字符，返回#字符。 思路 + 代码利用队列进行结果的存储，利用一个数组进行出现次数的统计。队列对于其中所有出现超过两次的字符进行出栈。123456789101112131415161718import java.util.*;public class Solution &#123; private char[] tmp = new char[256]; private Queue&lt;Character&gt; queue = new LinkedList&lt;Character&gt;(); //Insert one char from stringstream public void Insert(char ch) &#123; tmp[ch]++; queue.add(ch); while(!queue.isEmpty()&amp;&amp;tmp[queue.peek()]&gt;1) queue.poll(); &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; return queue.isEmpty()?'#':queue.peek(); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：表示数值的字符串","slug":"剑指Offer：表示数值的字符串","date":"2019-10-25","updated":"2020-01-11","comments":true,"path":"剑指Offer：表示数值的字符串/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：表示数值的字符串/","excerpt":"","text":"题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,“5e2”,&quot;-123&quot;,“3.1416&quot;和”-1E-16&quot;都表示数值。 但是&quot;12e&quot;,“1a3.14”,“1.2.3”,&quot;±5&quot;和&quot;12e+4.3&quot;都不是。 思路 + 代码方法1: 正则匹配123456789101112131415161718/*[] ： 字符集合() ： 分组? ： 重复 0 ~ 1 次+ ： 重复 1 ~ n 次* ： 重复 0 ~ n 次. ： 任意字符\\\\. ： 转义后的 .\\\\d ： 数字*/public class Solution &#123; public boolean isNumeric(char[] str) &#123; if(str == null || str.length == 0) return false; return new String(str).matches(\"[+-]?\\\\d*(\\\\.\\\\d+)?([Ee][+-]?\\\\d+)?\"); &#125;&#125;方法2: 特殊情况排除12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean isNumeric(char[] str) &#123; if(str == null || str.length == 0) return false; boolean hasE = false; boolean hasP = false; for(int i=0; i&lt;str.length; i++)&#123; // 首字母出现的正负号合法 if(i==0 &amp;&amp; (str[i]=='+' || str[i]=='-')) continue; // 小数点判定（只出现一次，且不能在E（e）后面出现） if(str[i]=='.')&#123; if(hasE || hasP) return false; hasP = true; &#125; // 指数判定，只出现一次，且不能在最后出现 else if(str[i]=='E' || str[i]=='e')&#123; if(i==str.length-1 || hasE) return false; hasE = true; &#125; // 第二次出现只能在指数后面 else if(str[i]=='+' || str[i]=='-')&#123; if(str[i-1]!='E' &amp;&amp; str[i-1]!='e') return false; &#125; // 非法字符判定 else if(!isInteger(str[i])) return false; &#125; return true; &#125; private boolean isInteger(char c)&#123; return c &gt;='0' &amp;&amp; c &lt;='9'; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：正则表达式匹配","slug":"剑指Offer：正则表达式匹配","date":"2019-10-25","updated":"2020-01-11","comments":true,"path":"剑指Offer：正则表达式匹配/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：正则表达式匹配/","excerpt":"","text":"题目请实现一个函数用来匹配包括’.‘和’‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;abaca&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 思路 + 代码**动态规划：**利用一个dp(x, y)的数组表示原字符串 s[0, x) 与匹配字符串 p[0, y)是否匹配。状态转移：对于dp(x, y)：如果 p(y) == ‘.’ || p(y) == s(x-1), dp(x, y)= dp(x-1, y-1)。如果 p(y) == ‘*’2.1 如果 p(y-1) == s(x) || p(y-1) == ‘.’‘*’ 复制多个：dp(x, y) = dp(x-1, y)‘*’ 复制一个：dp(x, y) = dp(x, j-1)‘*’ 复制零个：dp(x, y) = dp(x, j-2)2.2 如果 s 为空且不满足 2.1，则 ‘*’ 复制零个：dp(x, y) = dp(x, j-2)12345678910111213141516171819202122232425262728public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; int m = str.length+1; int n = pattern.length+1; boolean[][] dp = new boolean[m][n]; dp[0][0] = true; // 空字符串处理 for(int i=1; i&lt;n; i++) if(pattern[i-1]=='*') dp[0][i] = dp[0][i-2]; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(str[i-1]==pattern[j-1] || pattern[j-1]=='.') dp[i][j] = dp[i-1][j-1]; else if(pattern[j-1]=='*')&#123; if(pattern[j-2]==str[i-1] || pattern[j-2]=='.')&#123; dp[i][j] |= dp[i-1][j]; // 复制多个 dp[i][j] |= dp[i][j-1]; //复制一个 dp[i][j] |= dp[i][j-2]; // 删除一个 &#125;else dp[i][j] |= dp[i][j-2]; // 删除一个 &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：扑克牌顺子","slug":"剑指Offer：扑克牌顺子","date":"2019-10-23","updated":"2020-01-11","comments":true,"path":"剑指Offer：扑克牌顺子/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：扑克牌顺子/","excerpt":"","text":"题目LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张_)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 思路 + 代码首先用一个长度为13的数组统计每个数字出现的次数。然后满足以下条件为顺子：除大小王外所有数字出现一次。最大值与最小值差值小于等于4，例如存在 1 跟 6 无法形成顺子。四个癞子稳赢。12345678910111213141516171819202122232425public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers==null || numbers.length==0) return false; int[] counts = new int[14]; for(int num: numbers) counts[num]++; int n = 0; int i=0, j=14; //四个癞子稳赢 if(counts[0]==4) return true; // 寻找最大值与最小值 while(counts[++i]==0); while(counts[--j]==0); // 例如：最小值1，最大值6肯定不行 if(Math.abs(j-i)&gt;4) return false; // 用癞子补全，如果癞子够，就可以 for(int k=i; k&lt;=j; k++) if(counts[k]&gt;1) return false; return true; &#125;&#125;其它方法：1234567891011121314151617181920212223import java.util.*;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers==null || numbers.length&lt;5) return false; int count = 0; Arrays.sort(numbers); //统计癞子数量 for(int num: numbers)&#123; if(num==0) count++; else break; &#125; for(int i=count; i&lt;4; i++)&#123; // 存在重复的 if(numbers[i]==numbers[i+1]) return false; count -= numbers[i+1]-numbers[i]-1; &#125; return count&gt;=0; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：翻转单词顺序列","slug":"剑指Offer：翻转单词顺序列","date":"2019-10-22","updated":"2020-01-11","comments":true,"path":"剑指Offer：翻转单词顺序列/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：翻转单词顺序列/","excerpt":"","text":"题目牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路 + 代码先翻转每个单词，再重头到尾进行翻转。1234567891011121314151617181920212223242526272829public class Solution &#123; public String ReverseSentence(String str) &#123; if(str==null || str.length()==0) return str; char[] chs = str.toCharArray(); int len = chs.length; int i=0, j=0; while(j&lt;=len)&#123; // 反转单词 if(j==len || chs[j]==' ')&#123; reverse(chs, i, j-1); i=j+1; &#125; j++; &#125; // 反转整个句子 reverse(chs, 0, len-1); return new String(chs); &#125; private void reverse(char[] chs, int i, int j)&#123; while(i&lt;j) swap(chs, i++, j--); &#125; private void swap(char[] chs, int i, int j)&#123; char t = chs[i]; chs[i] = chs[j]; chs[j] = t; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：左旋字符串","slug":"剑指Offer：左旋字符串","date":"2019-10-22","updated":"2020-01-11","comments":true,"path":"剑指Offer：左旋字符串/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：左旋字符串/","excerpt":"","text":"题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路 + 代码先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。123456789101112131415161718192021222324public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0) return str; char[] chs = str.toCharArray(); int len = chs.length-1; inverse(chs, 0, n-1); inverse(chs, n ,len); inverse(chs, 0, len); return new String(chs); &#125; private void inverse(char[] chs, int i, int j)&#123; while(i&lt;j)&#123; swap(chs, i, j); i++; j--; &#125; &#125; private void swap(char[] chs, int i, int j)&#123; char t = chs[i]; chs[i] = chs[j]; chs[j] = t; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"Leetcode 2：两数相加","slug":"Leetcode-2：两数相加","date":"2019-10-21","updated":"2019-11-02","comments":true,"path":"Leetcode-2：两数相加/","link":"","permalink":"http://sunyunzeng.com/Leetcode-2：两数相加/","excerpt":"","text":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode pre = new ListNode(0); ListNode h = pre; int more = 0; while(l1!=null || l2!=null)&#123; int x = l1==null?0:l1.val; int y = l2==null?0:l2.val; int n = (x + y + more)%10; more = (x + y + more) / 10; h.next = new ListNode(n); if(l1!=null) l1=l1.next; if(l2!=null) l2=l2.next; h = h.next; &#125; if(more &gt;0) h.next = new ListNode(1); return pre.next; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"剑指Offer：数组中只出现一次的数字","slug":"剑指Offer：数组中只出现一次的数字","date":"2019-10-21","updated":"2020-01-11","comments":true,"path":"剑指Offer：数组中只出现一次的数字/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：数组中只出现一次的数字/","excerpt":"","text":"题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路 + 代码 思路1利用Map统计每个数字出现的次数。123456789101112131415161718192021//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int num: array)&#123; if(!map.containsKey(num)) map.put(num, 1); else map.put(num, map.get(num)+1); &#125; for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; if(entry.getValue()==1) list.add(entry.getKey()); &#125; num1[0] = list.get(0); num2[0] = list.get(1); &#125;&#125; 思路2与题目只出现一次的数字类似，利用异或的知识。唯一不同是这次是找出两个只出现一次的数字，所以需要找到这两个不同数字的区别，然后分别异或。123456789101112131415161718//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int dif=0; for(int num: array) dif ^= num; // dif=1100 -dif=0100, dif &amp;= -dif dif=0100,即只保存最右侧异或结果不同的那一位，分割数组 dif &amp;= -dif; for(int num: array)&#123; if((num &amp; dif)==0) num1[0] ^= num; else num2[0] ^= num; &#125; &#125;&#125;类似题目","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：平衡二叉树","slug":"剑指Offer：平衡二叉树","date":"2019-10-21","updated":"2019-11-02","comments":true,"path":"剑指Offer：平衡二叉树/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：平衡二叉树/","excerpt":"","text":"题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路 + 代码平衡二叉树的左右子树的高度差不大于 1。12345678910111213141516public class Solution &#123; private boolean isBalanced = true; public boolean IsBalanced_Solution(TreeNode root) &#123; height(root); return isBalanced; &#125; private int height(TreeNode root)&#123; if(root==null || !isBalanced) return 0; int left = height(root.left); int right = height(root.right); if(1&lt;Math.abs(left-right)) isBalanced = false; return Math.max(left, right) + 1; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：数组在排序中出现的次数","slug":"剑指Offer：数组在排序中出现的次数","date":"2019-10-17","updated":"2019-10-21","comments":true,"path":"剑指Offer：数组在排序中出现的次数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：数组在排序中出现的次数/","excerpt":"","text":"题目统计一个数字在排序数组中出现的次数。 思路 + 代码不能遍历，否则时间超出。二分查找，寻找边界位置。12345678910111213141516171819202122public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; if(array==null||array.length==0) return 0; int l = binarySearch(array, k); int h = binarySearch(array, k+1); return (l&gt;array.length-1 || array[l]!=k)?0:h-l; &#125; private int binarySearch(int[] n, int k)&#123; int l = 0, r = n.length; int m; while(l&lt;r)&#123; m = (r+l)/2; if(n[m]&gt;=k) // 保证最后的位置等于或小于查找的元素 r=m; else l=m+1; &#125; return l; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：两个链表的第一个公共结点","slug":"剑指Offer：两个链表的第一个公共结点","date":"2019-10-17","updated":"2019-10-21","comments":true,"path":"剑指Offer：两个链表的第一个公共结点/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：两个链表的第一个公共结点/","excerpt":"","text":"题目输入两个链表，找出它们的第一个公共结点。 思路 + 代码设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。1234567891011121314151617181920/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode l1 = pHead1; ListNode l2 = pHead2; while(l1!=l2)&#123; l1 = l1==null?pHead2:l1.next; l2 = l2==null?pHead1:l2.next; &#125; return l1; &#125;&#125;参考","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：数组中的逆序对","slug":"剑指Offer：数组中的逆序对","date":"2019-10-17","updated":"2019-10-21","comments":true,"path":"剑指Offer：数组中的逆序对/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：数组中的逆序对/","excerpt":"","text":"题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007题目描述:123456789题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5示例112345输入1,2,3,4,5,6,7,0输出7 思路归并排序，先拆分成单个的数字，然后向上归并同时统计逆数数量。12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; private int count = 0; public int InversePairs(int [] array) &#123; if(array==null || array.length==0) return -1; mergeSort(array, 0, array.length-1); return count; &#125; private void mergeSort(int[] nums, int left, int right)&#123; if(left&gt;=right) return; int l = left, r = right, m = (left + right)/2; mergeSort(nums, l, m); mergeSort(nums, m+1, r); merge(nums, l, m, r); &#125; private void merge(int[] nums, int left, int mid, int right)&#123; int len = right-left; int[] tmp = new int[len+1]; int l = mid, r = right; while(l &gt;= left &amp;&amp; r &gt;= mid+1)&#123; if(nums[l]&gt;nums[r])&#123; count += (r-mid); tmp[len--] = nums[l--]; if(count &gt;= 1000000007) count %= 1000000007; &#125;else&#123; tmp[len--] = nums[r--]; &#125; &#125; // 上述判定并不能概括所有的情况，因此用两个循环继续完成辅助数组tmp while(l &gt;= left) tmp[len--] = nums[l--]; while(r &gt;= mid+1) tmp[len--] = nums[r--]; // 排序 for(int i=0; i&lt;tmp.length; i++) nums[left+i] = tmp[i]; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：第一个只出现一次的字符","slug":"剑指Offer：第一个只出现一次的字符","date":"2019-10-15","updated":"2019-10-21","comments":true,"path":"剑指Offer：第一个只出现一次的字符/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：第一个只出现一次的字符/","excerpt":"","text":"题目在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 思路 + 代码用一个LinkedHashMap统计每个字符出现的次数，同时保存顺序。然后String查找该字符第一次出现的位置。12345678910111213141516171819202122import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0) return -1; char[] chs = str.toCharArray(); LinkedHashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); int len = chs.length; for(int i=0; i&lt;len; i++)&#123; if(!map.containsKey(chs[i]))&#123; map.put(chs[i], 1); &#125;else&#123; map.put(chs[i], map.get(chs[i])+1); &#125; &#125; for(Map.Entry&lt;Character, Integer&gt; entry: map.entrySet())&#123; if(entry.getValue()==1) return str.indexOf(entry.getKey()); &#125; return -1; &#125;&#125;或者可以用一个数组来模拟Map。1234567891011121314151617import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0) return -1; int[] counts = new int[256]; int len = str.length(); for(int i=0; i&lt;len; i++)&#123; counts[str.charAt(i)]++; &#125; for(int i=0; i&lt;len; i++)&#123; if(counts[str.charAt(i)]==1) return i; &#125; return -1; &#125;&#125;空间复杂度可以继续优化，用两个Bitset分别表示出现一次和出现一次及以上。12345678910111213141516171819202122232425262728import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0) return -1; int len = str.length(); char[] chs = str.toCharArray(); BitSet bs1 = new BitSet(256); BitSet bs2 = new BitSet(256); for(char c: chs)&#123; if(!bs1.get(c) &amp;&amp; !bs2.get(c))&#123; // 出现一次 bs1.set(c); &#125;else if(bs1.get(c) &amp;&amp; !bs2.get(c))&#123; // 出现一次以上 bs2.set(c); &#125; &#125; for(int i=0; i&lt;len; i++)&#123; char c = str.charAt(i); if(bs1.get(c) &amp;&amp; !bs2.get(c)) return i; &#125; return -1; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：丑数","slug":"剑指Offer：丑数","date":"2019-10-15","updated":"2019-10-21","comments":true,"path":"剑指Offer：丑数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：丑数/","excerpt":"","text":"题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。# 思路 ＋ 代码丑数只能是丑数乘以 2、３、５。按照顺序存储丑数，也就是比较每次丑数的大小。1234567891011121314151617181920public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; int[] dp = new int[index]; dp[0] = 1; int i2 = 0, i3 = 0, i5 = 0; for(int i=1; i&lt;index; i++)&#123; dp[i] = Math.min(Math.min(dp[i2]*2, dp[i3]*3), dp[i5]*5); //-----here is three \"if\" judge，rather tha “if else”----- if(dp[i] == dp[i2]*2) i2++; if(dp[i] == dp[i3]*3) i3++; if(dp[i] == dp[i5]*5) i5++; &#125; return dp[index-1]; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：把数组排成最小的数","slug":"剑指Offer：把数组排成最小的数","date":"2019-10-14","updated":"2019-10-21","comments":true,"path":"剑指Offer：把数组排成最小的数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：把数组排成最小的数/","excerpt":"","text":"题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路 + 代码字符串的排序。123456789101112131415161718import java.util.*;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers==null || numbers.length==0)&#123; return \"\"; &#125; int len = numbers.length; String[] strs = new String[len]; for(int i=0; i&lt;len; i++) strs[i] = numbers[i]+\"\"; Arrays.sort(strs, (a, b)-&gt;(a+b).compareTo(b+a)); StringBuilder sb = new StringBuilder(); for(String s: strs) sb.append(s); return sb.toString(); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：整数中1出现的次数","slug":"剑指Offer：整数中1出现的次数","date":"2019-10-14","updated":"2019-10-21","comments":true,"path":"剑指Offer：整数中1出现的次数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：整数中1出现的次数/","excerpt":"","text":"题目求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 思路 + 代码暴力穷举会超出时间，这道题的关键是找规律。[图片来自LeetCode 233](https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode/)一个数字，分解为十位、百位、千位…上来看。因为数字由1~n组成，既有十位、百位、千位等组成。首先，每十个数，个位数字出现一次。每百位数，个位数字出现十次…n/(i*10)*i, i=1, 10, 100, ...其次，对于后面的数，例如1611，从百位数来看，前面的数字 1611/100*10=160, 后面数字为11，因此后面的个位数为 1+1=2， 而1620和1650后面的个位数字都是10个，因此后面个位数字：max(min(n%(i*10)-i+1,0),i)12345678910import java.lang.Math;public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for(int i=1; i&lt;=n; i*=10)&#123; count += n/(i*10)*i + Math.min(Math.max(n%(i*10)-i+1,0),i); &#125; return count; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：最小的K个数","slug":"剑指Offer：最小的K个数","date":"2019-10-13","updated":"2019-10-21","comments":true,"path":"剑指Offer：最小的K个数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：最小的K个数/","excerpt":"","text":"题目输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路1 + 代码维护一个最小堆，该最小堆即为所求。类似题目1234567891011121314import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input==null || input.length==0 || k&gt;input.length) return new ArrayList&lt;Integer&gt;(); PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2-o1); for(int num:input)&#123; pq.add(num); if(pq.size()&gt;k) pq.poll(); &#125; return new ArrayList&lt;Integer&gt;(pq); &#125;&#125; 思路2 + 代码该题完全可以先排序后取最小的K个数。因此排序方法的选取很重要。## 冒泡方法只用排k个最小值即可，因此最外圈循环K次。1234567891011121314151617181920import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input==null || input.length==0 || k&gt;input.length) return new ArrayList&lt;Integer&gt;(); int len = input.length; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i=1; i&lt;k+1; i++)&#123; for(int j=0; j&lt;len-i; j++)&#123; if(input[j]&lt;=input[j+1])&#123; int tmp = input[j]; input[j] = input[j+1]; input[j+1] = tmp; &#125; &#125; res.add(input[len-i]); &#125; return res; &#125;&#125;## 快速排序快排关键在于基准的选择，大于基准的数放于一边，小于基准的数放在另一边。我们的标准是划分的位置刚好是在第k个位置，这样 k 位置之前的数组都为排序好的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input==null || input.length==0 || k&gt;input.length) return new ArrayList&lt;Integer&gt;(); int len = input.length; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); sort(input, 0, input.length-1, k-1); for(int i=0; i&lt;k; i++)&#123; res.add(input[i]); &#125; return res; &#125; private void sort(int[] input, int low, int high, int k)&#123; int l = low; int h = high; while(l&lt;h)&#123; int tmp = partition(input, l, h); if(tmp==k) break; if(tmp&gt;k)&#123; h = tmp-1; &#125;else&#123; l = tmp+1; &#125; &#125; &#125; private int partition(int[] input, int l, int h)&#123; int criterion = input[h]; int i = l-1; int j = h; while(true)&#123; while(i&lt;j &amp;&amp; input[++i]&lt;criterion); while(i&lt;j &amp;&amp; input[--j]&gt;criterion); if(i&gt;=j) break; swap(input, i, j); &#125; swap(input,i, h); return i; &#125; private void swap(int[] arr, int a, int b)&#123; int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：字符串的排列","slug":"剑指Offer：字符串的排列","date":"2019-10-10","updated":"2019-10-21","comments":true,"path":"剑指Offer：字符串的排列/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：字符串的排列/","excerpt":"","text":"题目输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 思路 + 代码典型回溯法，同 全排列 解法类似。123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); backtracking(res, str.toCharArray(), new StringBuilder(), new boolean[str.length()]); return res; &#125; private void backtracking(ArrayList&lt;String&gt; res, char[] chs, StringBuilder sbd, boolean[] used)&#123; if(chs==null || chs.length==0) return; else&#123; if(chs.length==sbd.length())&#123; res.add(new String(sbd.toString())); &#125;else&#123; for(int i=0; i&lt;chs.length; i++)&#123; if(used[i] || i&gt;0&amp;&amp;chs[i]==chs[i-1]&amp;&amp;!used[i-1]) continue; sbd.append(chs[i]); used[i] = true; backtracking(res, chs, sbd, used); sbd.deleteCharAt(sbd.length()-1); used[i] = false; &#125; &#125; &#125; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"Leetcode 46.全排列","slug":"Leetcode-46-全排列","date":"2019-10-10","updated":"2019-10-21","comments":true,"path":"Leetcode-46-全排列/","link":"","permalink":"http://sunyunzeng.com/Leetcode-46-全排列/","excerpt":"","text":"题目给定一个没有重复数字的序列，返回其所有可能的全排列。示例：12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路 + 代码回溯问题。如果遇到一个问题，不用穷举所有情况找不出答案，就采用回溯。回溯是DFS的一种，遍历完一条路径后，回退一步，继续寻找下一可能路径。它与暴力法的区别在于，可以通过剪枝规避掉很多无意义的尝试，且不用每次都从头开始遍历到尾部。讲解可以参考https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, new boolean [nums.length]); return res; &#125; // used访问标志防止重复使用 private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; arr, int[] nums, boolean[] used)&#123; if(nums==null || nums.length==0)&#123; res.add(arr); return; &#125; if(arr.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(arr)); return; &#125;else&#123; for(int i=0; i&lt;nums.length; i++)&#123; if(used[i]) continue; arr.add(nums[i]); used[i] = true; backtracking(res, arr, nums, used); arr.remove(arr.size()-1); used[i] = false; &#125; &#125; &#125;&#125;回溯例题参考来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutations著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"backtrace","slug":"backtrace","permalink":"http://sunyunzeng.com/tags/backtrace/"}]},{"title":"剑指Offer：二叉搜索树与双向链表","slug":"剑指Offer：二叉搜索树与双向链表","date":"2019-10-10","updated":"2020-01-11","comments":true,"path":"剑指Offer：二叉搜索树与双向链表/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：二叉搜索树与双向链表/","excerpt":"","text":"题目输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路 + 代码二叉搜索树的中序遍历即为一个排序的顺序，按照该顺序依次构建双向链表即可。123456789101112131415161718192021222324252627282930313233343536/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private TreeNode firstHead = null; private TreeNode preHead = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree==null) return null; // 整个遍历过程与中序遍历相同 // 遍历到最左侧叶子节点，即最小的叶子节点 Convert(pRootOfTree.left); // 第一次将头指针指向最小叶子节点（处理中间节点pRootOfTree） if(preHead==null)&#123; preHead = pRootOfTree; firstHead = pRootOfTree; &#125;else&#123; pRootOfTree.left=preHead; preHead.right = pRootOfTree; preHead = pRootOfTree; &#125; // 右节点 Convert(pRootOfTree.right); return firstHead; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Search-Tree/"}]},{"title":"剑指Offer：复杂链表的复制","slug":"剑指Offer：复杂链表的复制","date":"2019-10-10","updated":"2019-10-21","comments":true,"path":"剑指Offer：复杂链表的复制/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：复杂链表的复制/","excerpt":"","text":"题目输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路 + 代码参考 https://github.com/CyC2018/CS-Notes/blob/master/notes/剑指 Offer 题解 - 30~39.md#35-复杂链表的复制分为三步：1. 在每个节点的后面插入复制的节点。2. 每个复制的节点 random 赋值。3. 拆分。12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) return null; RandomListNode cur = pHead; // 先在链表中间插入节点 while(cur!=null)&#123; RandomListNode tmp = new RandomListNode(cur.label); tmp.next = cur.next; cur.next = tmp; cur = tmp.next; &#125; // 然后中间节点的 random 指针赋值 cur = pHead; while(cur!=null)&#123; if(cur.random!=null) // 这里是当前节点 random 链接的下一个为复制节点的 random 链接 cur.next.random = cur.random.next; cur = cur.next.next; &#125; // 两个链表分离 cur = pHead; RandomListNode res = cur.next; while(cur.next!=null)&#123; RandomListNode tmp = cur.next; cur.next = tmp.next; cur = tmp; &#125; return res; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：二叉树和为某一值的路径","slug":"剑指Offer：二叉树和为某一值的路径","date":"2019-10-08","updated":"2020-01-11","comments":true,"path":"剑指Offer：二叉树和为某一值的路径/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：二叉树和为某一值的路径/","excerpt":"","text":"题目输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 思路 + 代码递归求解，左右子树分别遍历（深度优先）。遍历终止条件为节点为null或者是叶子节点且和为目标值。否则回退列表，寻找更短的路径。1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res; private ArrayList&lt;Integer&gt; list; public Solution()&#123; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); list = new ArrayList&lt;Integer&gt;(); &#125; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root==null) return res; target = target - root.val; list.add(root.val); if(target==0&amp;&amp;root.right==null&amp;&amp;root.left==null)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); &#125; FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return res; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：二叉搜索树的后序遍历序列","slug":"剑指Offer：二叉搜索树的后序遍历序列","date":"2019-10-06","updated":"2020-01-11","comments":true,"path":"剑指Offer：二叉搜索树的后序遍历序列/","link":"","permalink":"http://sunyunzeng.com/剑指Offer：二叉搜索树的后序遍历序列/","excerpt":"","text":"题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路 + 代码二叉搜索树的左子树所有节点小于根节点，右子树的所有节点大于根节点。后序遍历是先访问左子树，后访问右子树。因此，根节点永远在序列的最后位置。找到根节点数值后，根据前面节点数值与根节点的大小关系，找到左右子树的分割位置，递归求解。123456789101112131415161718192021222324252627public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; // 初始条件判断 if(sequence==null || sequence.length==0) return false; // 调用重写的辅助函数 return VerifySquenceOfBST(sequence, 0, sequence.length-1); &#125; private boolean VerifySquenceOfBST(int[] sequence, int start, int end)&#123; // 递归截止条件 if(start &gt;= end) return true; // 寻找分割节点 int currentCutIndex = start; while(sequence[currentCutIndex]&lt;sequence[end])&#123; currentCutIndex++; &#125; // 如果右子树存在小于根节点的节点，则该序列不是二叉搜索树的后序遍历 for(int i=currentCutIndex; i&lt;end; i++)&#123; if(sequence[i]&lt;sequence[end]) return false; &#125; // 左右子树递归寻找 return VerifySquenceOfBST(sequence, start, currentCutIndex-1) &amp;&amp; VerifySquenceOfBST(sequence, currentCutIndex, end-1); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Search-Tree/"}]},{"title":"剑指Offer：从上往下打印二叉树","slug":"剑指Offer-从上往下打印二叉树","date":"2019-10-06","updated":"2019-10-21","comments":true,"path":"剑指Offer-从上往下打印二叉树/","link":"","permalink":"http://sunyunzeng.com/剑指Offer-从上往下打印二叉树/","excerpt":"","text":"题目从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路 + 代码二叉树的层次遍历，用队列保存同一层次的树节点，然后依次遍历。类似题目http://sunyunzeng.com/Leetcode-102-二叉树的层次遍历/1234567891011121314151617181920212223242526272829303132333435import java.util.*;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root==null) return list; queue.add(root); while(!queue.isEmpty())&#123; int len = queue.size(); for(int i=0; i&lt;len; i++)&#123; root = queue.remove(); list.add(root.val); if(root.left!=null) queue.add(root.left); if(root.right!=null) queue.add(root.right); &#125; &#125; return list; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer：矩阵中的路径","slug":"矩阵中的路径","date":"2019-10-02","updated":"2020-01-11","comments":true,"path":"矩阵中的路径/","link":"","permalink":"http://sunyunzeng.com/矩阵中的路径/","excerpt":"","text":"题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路 + 代码没有接触过类似的题型，因此看了讲解。题目给出的是待查询的矩阵字符串与对应的行与列。首先需要转化为矩阵。然后利用回溯法，起始点依次选择矩阵中的每一个位置，上下左右进行遍历。需要设置一个哨兵矩阵，记录已经访问的，防止重复访问产生无限循环。思想跟http://sunyunzeng.com/Leetcode-岛屿最大的面积/类似。判定成功条件：回溯的路径长度与查询路径长度一致。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; private int[][] next = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; private int rows; private int cols; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if(rows&lt;=0 || cols&lt;=0) return false; this.rows = rows; this.cols = cols; char[][] m = getMatrix(matrix); boolean[][] visit = new boolean[rows][cols]; for(int i=0; i&lt;rows; i++) for(int j=0; j&lt;cols; j++) if(backtrace(m, str, i, j, 0, visit)) return true; return false; &#125; private boolean backtrace(char[][] matrix, char[] str, int r, int c, int pathLen, boolean[][] visit)&#123; // 边界判断 if(pathLen==str.length) return true; if(r&lt;0 || r&gt;rows-1 || c&lt;0 || c&gt;cols-1 || str[pathLen]!=matrix[r][c] || visit[r][c]) return false; // 当前格子设定为已访问，防止重复访问 visit[r][c] = true; for(int[] step: next)&#123; // 递归回溯，只要找到一个字符满足要求，就返回true if(backtrace(matrix, str, r+step[0], c+step[1], pathLen+1, visit)) return true; &#125; // 此路不通，格子回归初始状态，重新选择起始格子 visit[r][c] = false; return false; &#125; // 根据一维字符数组生成二维矩阵 private char[][] getMatrix(char[] matrix)&#123; char[][] res = new char[rows][cols]; int s = 0; for(int i=0; i&lt;rows; i++) for(int j=0; j&lt;cols; j++)&#123; res[i][j] = matrix[s]; s++; &#125; return res; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"},{"name":"backtrace","slug":"backtrace","permalink":"http://sunyunzeng.com/tags/backtrace/"}]},{"title":"设计模式：Java枚举类与注解","slug":"设计模式：Java枚举类与注解","date":"2019-09-30","updated":"2019-11-02","comments":true,"path":"设计模式：Java枚举类与注解/","link":"","permalink":"http://sunyunzeng.com/设计模式：Java枚举类与注解/","excerpt":"","text":"枚举类替代整形常量枚举类的基本形式如下：12public enum Apple &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125;enum关键字指明一个类继承 abstractEnum。该类有两个重要的方法：ordinal(). 返回整形序列值（从0开始）1234567public enum Season&#123; SPRING, SUMMER, FALL, WINTER&#125;System.out.println(Season.SPRING.ordinal())// 打印 0Enum(). 只能被继承Enum的类调用的构造方法，枚举类中每个实例调用该方法实现赋值，每个实例的构造方法都是私有的。1234protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125;枚举类的特征1. 不能被继承其它类也不能被其他类继承，但可以实现接口，对枚举类内部实例进行组织。12345678910111213141516171819202122interface Info&#123; public String getName();&#125;public enum Season implements Info&#123; SPRING(\"春天\"), SUMMER(\"夏天\"), FALL(\"秋天\"), WINTER(\"冬天\"); // 必须为private的构造器，因为枚举类本身是final的，其内部实例也是final，且在枚举类生成同时调用私有的构造器实现值的赋予 private String name; private Season()&#123;&#125; private Season(String name)&#123; this name = name; &#125; // 实现接口，每个实例都有该接口，可以返回对应的中文名称 public String getName( return name; ); @test System.out.println(Season.SPRING.getName()); // 打印 春天&#125;2. 类中每个实例可以重写其中定义的抽象方法12345678910111213141516171819public enum Season implements&#123; SPRING(public String getName(return \"春天\"), SUMMER(public String getName(return \"夏天\")), FALL(public String getName(return \"秋天\")), WINTER(public String getName(return \"冬天\")); // 必须为每个实例都重写抽象方法，否则报错 private String name; private Season()&#123;&#125; private Season(String name)&#123; this name = name; &#125; // 实现接口，每个实例都有该接口，可以返回对应的中文名称 public abstract String getName(); @test System.out.println(Season.SPRING.getName()); // 打印 春天&#125;3. 可利用枚举实现单例12345678910public enmu Sigleton&#123; SINGLETON; public String method()&#123; return \"method\"; &#125;&#125;@testSystem.out.println(Singleton.SINGLETON.method())// 打印 method4. 调用values()方法遍历枚举类型中的每个实例123for(Season season: Season.values)&#123; System.out.println(season.getName());&#125;嵌套枚举12345678910111213141516171819202122232425262728293031323334353637// The strategy enum patternenum PayrollDay &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND); private final PayType payType; PayrollDay(PayType payType) &#123; this.payType = payType; &#125; PayrollDay() &#123; this(PayType.WEEKDAY); &#125; // Default int pay(int minutesWorked, int payRate) &#123; return payType.pay(minutesWorked, payRate); &#125; // The strategy enum type private enum PayType &#123; WEEKDAY &#123; int overtimePay(int minsWorked, int payRate) &#123; return minsWorked &lt;= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2; &#125; &#125;, WEEKEND &#123; int overtimePay(int minsWorked, int payRate) &#123; return minsWorked * payRate / 2; &#125; &#125;; abstract int overtimePay(int mins, int payRate); private static final int MINS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate) &#123; int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); &#125; &#125;&#125; 实例属性代替内置序数内置序数会随枚举内部类位置而改变，通过在内部类的实例属性实现标记与类的一一对应。12345678910public enum Ensemble &#123; SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5), SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8), NONET(9), DECTET(10), TRIPLE_QUARTET(12); private final int numberOfMusicians; Ensemble(int size) &#123; this.numberOfMusicians = size; &#125; public int numberOfMusicians() &#123; return numberOfMusicians; &#125;&#125; 按位属性替换为EnumSet替代前:123456789class Test&#123; public static final int STYLE_BOLD = 1 &lt;&lt; 0; // 1 public static final int STYLE_ITALIC = 1 &lt;&lt; 1; // 2 public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2; // 4 public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3; // 8 // Parameter is bitwise OR of zero or more STYLE_ constants public void applyStyles(int styles) &#123; ... &#125;&#125;修改后：12345678910// EnumSet - a modern replacement for bit fieldspublic class Text &#123; public enum Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125; // Any Set could be passed in, but EnumSet is clearly best public void applyStyles(Set&lt;Style&gt; styles) &#123; ... &#125;&#125;// ----------------------------------------------------------------text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC)); 使用EnumMap1234567891011121314151617181920212223242526class Plant &#123; enum LifeCycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125; final String name; final LifeCycle lifeCycle; Plant(String name, LifeCycle lifeCycle) &#123; this.name = name; this.lifeCycle = lifeCycle; &#125; @Override public String toString() &#123; return name; &#125;&#125;// Using an EnumMap to associate data with an enumMap&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = new EnumMap&lt;&gt;(Plant.LifeCycle.class);for (Plant.LifeCycle lc : Plant.LifeCycle.values()) plantsByLifeCycle.put(lc, new HashSet&lt;&gt;());for (Plant p : garden) plantsByLifeCycle.get(p.lifeCycle).add(p);System.out.println(plantsByLifeCycle);","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://sunyunzeng.com/tags/Java设计模式/"}]},{"title":"剑指Offer: 顺时针打印矩阵","slug":"剑指Offer-顺时针打印矩阵","date":"2019-09-30","updated":"2019-10-21","comments":true,"path":"剑指Offer-顺时针打印矩阵/","link":"","permalink":"http://sunyunzeng.com/剑指Offer-顺时针打印矩阵/","excerpt":"","text":"题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路 + 代码制造一个子函数，用来打印每一层。函数接收的参数是需要打印的行数跟列数，以及起始打印的位置（都是 n * n）。特殊情况处理：打印行列错误、数组为空、单行或单列数组1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); printArr(matrix.length, matrix[0].length, 0, matrix, res); return res; &#125; private void printArr(int I,int J,int s,int[][] arr, ArrayList&lt;Integer&gt; res)&#123; if(I&lt;=0 || J&lt;=0 || arr==null || arr.length==0 || arr[0].length==0) return; if(I==1)&#123; for(int i=0; i&lt;J;i++)&#123; res.add(arr[s][s+i]); &#125; return; &#125; if(J==1)&#123; for(int i=0; i&lt;I;i++)&#123; res.add(arr[s+i][s]); &#125; return; &#125; for(int i=0; i&lt;J;i++)&#123; res.add(arr[s][s+i]); &#125; for(int i=1;i&lt;I;i++)&#123; res.add(arr[s+i][s+J-1]); &#125; for(int i=J-1; i&gt;0; i--)&#123; res.add(arr[s+I-1][s+i-1]); &#125; for(int i=I-1; i&gt;1; i--)&#123; res.add(arr[s+i-1][s]); &#125; printArr(I-2,J-2,s+1,arr, res); return; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"剑指Offer 树的子结构","slug":"剑指Offer-树的子结构","date":"2019-09-29","updated":"2019-11-02","comments":true,"path":"剑指Offer-树的子结构/","link":"","permalink":"http://sunyunzeng.com/剑指Offer-树的子结构/","excerpt":"","text":"树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路 + 代码涉及到二叉树相关的问题，首先想到是剑指O剑指递归。由于二叉树是否为子树的判断，涉及到是否为 null的判断，因此需要建立子判定函数，避免空树情况产生干扰。判断条件：如果当前树节点与待判断树节点数值相同，则继续进行左右树的数值判断。直到两树中某一树为空。否则分别对当前树的子树与右树跟带判断子树进行判定。123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null) return false; // 不能只判断当前第一个节点，如果首节点是伪相等，就是错误的 return isSubtree(root1, root2)|| isSubtree(root1.left, root2)||isSubtree(root1.right, root2); &#125; private boolean isSubtree(TreeNode root1,TreeNode root2)&#123; if(root2==null) return true; if(root1==null) return false; if(root1.val==root2.val)&#123; return (isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right)); &#125;else&#123; return (isSubtree(root1.left, root2) || isSubtree(root1.right, root2)); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"设计模式: Java泛型","slug":"设计模式-Java泛型","date":"2019-09-28","updated":"2019-10-02","comments":true,"path":"设计模式-Java泛型/","link":"","permalink":"http://sunyunzeng.com/设计模式-Java泛型/","excerpt":"","text":"不要使用原始类型原始类型是Java(5之前)的历史遗留问题，之前集合对于类型在编译期间不进行检查，而在运行期进行类型检查。这导致问题的定位困难，降低效率。此后采用泛型解决这个问题，保证在编译期间进行检查。例如List 类型是原始类型，而List&lt; E &gt;是泛型类型，指定了参数化类型为 E 类型。List表明可以存储任何类型的对象，List&lt; E &gt; 是它的子类型，可以转化为List类型，但是丧失了安全性检查；而List&lt; E &gt; 却不是List&lt; Object &gt; 的子类型。List&lt; Object &gt; 只能是List&lt; Object &gt; 。如果想实现类似于List等存储任何类型的对象， 可以利用**无限制通配符类型（unbounded wildcard types）**表示泛型类型，即List&lt; ? &gt; 。泛型的几个注意点：1. 类字面常量不允许使用泛型数组String[].class、基本类型int.class、不带参数化类型的类List.class可以使用。2. instanceof 只能对无限制通配符类型的参数化类型的类或接口使用。123if(o instanceof Set)&#123; Set&lt;?&gt; s = (Set&lt;?&gt;) o;&#125;术语中文含义举例Parameterized type参数化类型List&lt; String &gt;Actual type parameter实际类型参数StringGeneric type泛型类型List&lt; E &gt;Formal type parameter形式类型参数EUnbounded wildcard type无限制通配符类型List&lt;?&gt;Raw type原始类型ListBounded type parameter限制类型参数&lt; E extends Number&gt;Recursive type bound递归类型限制&lt; T extends Comparable&lt; T &gt;&gt;Bounded wildcard type限制通配符类型List&lt;? extends Number&gt;Generic method泛型方法static &lt; E &gt; List&lt; E &gt; asList(E[] a)Type token类型令牌String.class 列表优先于数组即List优先于数组。因为数组是协变类型的，所以下面代码编译期间是合法的, 但是运行期间是违法的。12Object[] o = new String[1];o[1] = 1;尽量使用列表来在编译过程中就确保安全性，虽然会损失掉一定的性能与简洁性。下面代码运行有警告，因为java程序中的泛型信息在编译后会进行擦除（这意味着它们只在编译时执行类型约束，并在运行时丢弃它们的元素类型信息），为了与Java5之前的代码共存。因此实际在运行中虚拟机并不知道返回数组具体类型，返回的类型是顶层类 Object, 在强制转换为**T[]**时会有问题。123public Chooser(Collection&lt;T&gt; choices) &#123; choiceArray = (T[]) choices.toArray();&#125;因此最好采用List替代。123public Chooser(Collection&lt;T&gt; choices) &#123; choiceList = new ArrayList&lt;&gt;(choices);&#125; 优先考虑泛型一个简单实现的栈，原始版本 vs 添加泛型版本。原始版本12345678910111213141516171819202122232425262728293031class Stack&#123; // 存储数量 private int size = 0; // 默认长度 private static final int DEFAULT_INITIAL_CAPACITY; // 元素桶 private Object[] elements; public Stack&#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size==0) throw new EmptyStackException(); Object res = elements[--size]; // 清除无用的引用 elements[size] = null; return res; &#125; private ensureCapacity()&#123; if(elements.length==size) elements = Arrays.copyOf(elements, size*2+1); &#125;&#125;这样的版本Stack每次取出元素都要进行强制类型转换。泛型版本1234567891011121314151617181920212223242526272829303132333435363738class Stack&lt;E&gt;&#123; // 存储数量 private int size = 0; // 默认长度 private static final int DEFAULT_INITIAL_CAPACITY; // 元素桶 private E[] elements; // 确保强制转换是安全的。有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害 @SuppressWarnings(\"unchecked\") public Stack()&#123; // 强制类型转换，因为无法创建泛型数组 new E[DEFAULT_INITIAL_CAPACITY]; elements = (E)new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(E e)&#123; ensureCapacity(); elements[size++] = e; &#125; public E pop()&#123; if(size==0) throw new EmptyStackException(); E res = elements[--size]; // 清除无用的引用 elements[size] = null; return res; &#125; public isEmpty()&#123; return size==0; &#125; private ensureCapacity()&#123; if(elements.length==size) elements = Arrays.copyOf(elements, size*2+1); &#125;&#125; 考虑泛型方法声明类型参数的类型参数列表位于方法的修饰符和返回类型之间。123456// Generic methodpublic static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(s1); result.addAll(s2); return result;&#125; 限定通配符增加API灵活性PECS代表： producer-extends，consumer-super。如果一个参数化类型代表一个 T 生产者，使用 &lt;? extends T&gt;；如果它代表 T 消费者，则使用 &lt;? super T&gt;。 在我们的 Stack 示例中，pushAll 方法的 src 参数生成栈使用的 E 实例，因此 src 的合适类型为 Iterable&lt;? extends E&gt;；popAll 方法的 dst 参数消费 Stack 中的 E 实例，因此 dst 的合适类型是 Collection &lt;? super E&gt;。所有 Comparable 和 Comparator 都是消费者。 可变参数与泛型可变参数: 类型 T 加…构成，例如：12345public void test(String ... strs)&#123; for(String s: strs)&#123; System.out.println(s); &#125;&#125;Java用一个数组来保存变长的参数，但是可变参数的类型与泛型要注意混淆。考虑一个例子：123456public &lt;T&gt; T[] toArray(T ... t)&#123; return t;&#125;// testString[] strs = toArray(\"abc\", \"def\");上面的会报错，因为泛型传递的是非具体类型，也就是编译时的类型信息要多与运行时信息（由于擦除），因此可变参数的数组用 Object类型存储，当Object转为String时，会报错ClassCastException。另一个例子：123456public void test(List&lt;String&gt;... stringList)&#123; Object[] obj = stringList; List&lt;Integer&gt; intList = List.of(15); // List.of生成一个不可变列表（不能用set设置数值） obj[0] = intList; // 发成堆污染 String s = obj[0].get(0); // 出现警告，编译没错，但是运行报错 ClassCastException。&#125;可见，可变参数中混淆了泛型，还是很容易产生类型转换的不安全性，但是Java并没有因此抛弃，而在Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)中大量使用，说明只要保证可变参数中的泛型是安全的（以下三点），就可：1. 可变参数数组不会存储跟修改。2. 可变参数数组的引用不会转义。3. 可变参数数组仅用来为方法传递可变参数。当然，可变参数数组可以变为列表，但同时降低了一定性能与可读性。123456public &lt;T&gt; List&lt;T&gt; toArray(List&lt;T&gt; t)&#123; return t;&#125;// testList&lt;String&gt; strs = toArray(\"abc\", \"def\");可变参数的另一个用法因为可变参数数组的产生都会产生性能损耗，因此当 95％ 的调用是三个或更少的参数的方法，那么声明该方法的五个重载。123456789public void foo() &#123; &#125;public void foo(int a1) &#123; &#125;public void foo(int a1, int a2) &#123; &#125;public void foo(int a1, int a2, int a3) &#123; &#125;public void foo(int a1, int a2, int a3, int... rest) &#123; &#125; 异构容器泛型中规定的可变类型数量总是有限的，例如单个类型约束&lt; T &gt;以及Map的&lt; K , V&gt;。异构容器可以通过参数化键的方式，实现泛型设定数量的灵活性。例如在数据库查询中任意列值。下面是一个异构容器的示例：1234567891011121314151617public class Favorites&#123; // 用Class&lt;T&gt;存放未知的键 Map&lt;Class&lt;?&gt;, T&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance)&#123; favorites.put(Object.requireNonNull(type), type.cast(instance)); &#125; public &lt;T&gt; T get(Class&lt;T&gt; type)&#123; return type.cast(favorites.get(type)); &#125;&#125;public static void main(String[] args) &#123; Favorites f = new Favorites(); f.put(String.class, \"syz\"); f.put(Integer.class, 12); f,get(String.class);&#125;可以使用 ColumnClass 对象作为此类型安全异构容器的键。 以这种方式使用的 Class 对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的 DatabaseRow 类型和一个泛型类型 Column&lt; T &gt; 作为其键。","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://sunyunzeng.com/tags/Java设计模式/"}]},{"title":"Class文件长什么样","slug":"Class文件长什么样","date":"2019-09-25","updated":"2019-10-21","comments":true,"path":"Class文件长什么样/","link":"","permalink":"http://sunyunzeng.com/Class文件长什么样/","excerpt":"","text":"定义Class文件是Java语言实现跨平台的原材料，JVM(Java Vritual Machine)是实现跨平台的机器。机器 + 原材料 = 跨平台。不同的平台有自己的JVM，但是Class文件是一样的。Class文件由java文件编译产生。Class文件是由8位字节构成的二进制流，用类似于C语言结构体的伪结构来存储数据。Class文件由无符号数和表组成。无符号数用u1 u2 u4 u8来表示1 2 4 8个字节的无符号数。它用来表示数量值、数值、索引引用、按照UTF-8编码的字符串。表是一种特殊的数据结构，它由表及无符号数组成，习惯表以_info结尾。Class文件就是一张表，用来描述唯一确定的类或接口。下面是从《深入了解JVM》中摘的Class文件的表结构。图1 Class表结构 进入Class这张表首先我们写一个简单的类，叫做HelloClass。1234567public class HelloClass &#123; private int name; public int addName() &#123; return name + 1; &#125;&#125;然后编译生成 HelloClass.class文件，我们用文本编辑器打开它，如下：图2 编译后的class文件 最复杂的结构，常量池由于Class本身就是一张表，而常量池是嵌套在Class中的表，其结构最复杂。常量池用来存储类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。如图2所示，前四个字节的无符号数 u4表示 Magic Number，是用来区分文件格式的，这样比文件名后缀更安全。**CAFE BABE**是Java的Class文件的魔数，很魔性。接着的u4是版本号，即图1中的 00 00 00 34。然后就是常量池了，先看常量池的项目类型：图3 常量池的项目类型每个项目类型的第一位都是项目标志，唯一标识该类型。常量池开始是容量说明，u2类型，及 00 16，表示容量为 16+6=22-1=21，因为常量池容量计算是从1开始，0表示为空。之后一个u1类型是常量类型标志符，为 0A，为 10。查找图2表示该常量为 CONSTANT_Methodref_info，由两个u2无符号类型组成，第一个指向 00 04 即第4个常量，为 CONSTANT_Class_info 类型；第二个指向 00 12 即第 16+2=18 个常量， 为 CONSTANT_NameAndType 类型。依次类推，直到翻译完常量池。我们可以通过javap工具的 -verbose 输出字节码内容，如下： 访问标志**访问标志(access_flags)**用于识别类和接口的访问信息，诸如是否是public及抽象类等。常量池后面是访问标志。不同访问标志求 | 运算得到。 类索引、父类索引、接口索引分别是一个 u2、u2和一组u2，因为java单继承，可实现多个接口。各自指向一个 CONSTANT_Class_info 的类描述常量。 字段表集合**字段表(field_info)用来描述接口或类中声明的变量，字段包括类级别变量以及实例级别变量。**但不包括方法内部声明的局部变量。字段需要用访问标志描述，包括作用域(public、protected、default、private)、实例变量还是类变量(static)、是否为final、并发可见性(volatile)、是否可序列化(transient)、类型(基本类型、对象及数组)以及字段名称。字段表的结果除了访问标志描述，还有字段的简单名称 name_index 及方法的描述符 discriptor_index、属性表统计 attributes_count 及属性表 attributes。字段的简单名称及方法描述符都是对常量池引用。描述符是用来描述字段与方法的类型与返回参数的。由于这类信息不能跟访问标志描述一样，可以用固定长度来表示，所以需要在常量池中表示后然后引用。基本数据类型用相应大写字母表示，对象类型用大写字母 L加对象全限定名表示。其中数组类型用前面 **[**加类型表示，如 String[][],就表示为 [[Ljava/lang/String;。**描述方法时，先参数列表，后返回类型。**如 int i(), 表示为 （）I 方法表集合与字段表类似,只不过并发可见性(volatile)、是否可序列化(transient)不能修饰方法。方法中的代码描述，由编译器编译成字节指令后，存放在属性表attributes 的 **Code**属性里。 属性表属性表(attributes_info)在Class文件、属性表与方法表内都有出现，用于描述场景特殊信息。属性表其它数据项目严格要求的顺序、长度和内容，它**不再要求各个属性有严格的顺序，且只要不与已有属性名重复，任何实现的编译器都可向属性表中写入自己定义的属性信息；**Java虚拟机在运行时会忽略掉不认识的属性。《Java虚拟机规范(Java SE 7)》中，预定义的属性为：其中每个属性表首先根据 attributes_name_index 去常量池引用 CONSTANT_Class_info 类型的名称，然后用一个 u4 长度的属性说明属性表占用的长度 attribute_length 即可。属性表中描述的信息单位是 u1，共attribute_length个。属性表的结构如下： Code属性java程序方法体内的代码通过编译成字节码后，存在Code属性中。Code属性存储在方法表的属性表集合中。Code属性是Class文件中最重要的属性，是对代码的描述。其它信息可以看做是对元数据（类型、字段、方法及其他信息）的描述。Code的属性表如下：各部分的含义如下：类型名称含义u2attributes_name_index指向 CONSTANT_Class_info 常量索引，表示该属性表名称u1attribute_length属性表长度。由于属性名称索引 u2 加长属性名长度 u4，所以属性表长度为整个属性表长度减去 6 字节。u2max_stack栈的最大深度。Java虚拟机为该方法体分配栈针的操作栈深度。u2max_locals局部变量的最大存储空间。**方法参数、显示异常处理的参数及方法体中定义的局部变量都需用局部变量表表示。**局部变量中统计单位是 Slot。小于32位(boolean、short、char、int、float、returnAddress)的变量用一个 Slot 表示，double与long两个64位的用两个Slot表示。u4code_length字节码长度。实际是 u2 长度，即16个字节， 65535条字节码，超过改长度虚拟机将拒绝编译。u1code一些类的字节码指令，用于描述编译后的方法体内方法。u2exception_table_lenght显示异常处理表长度。excessption_infoexception_table显示异常处理表u2attributes_count属性表数量attributes_infoattributes属性表 参考深入理解java虚拟机","categories":[{"name":"JVM","slug":"JVM","permalink":"http://sunyunzeng.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://sunyunzeng.com/tags/JVM/"}]},{"title":"剑指Offer 打印1到最大的n位数","slug":"剑指Offer-打印1到最大的n位数","date":"2019-09-24","updated":"2019-10-21","comments":true,"path":"剑指Offer-打印1到最大的n位数/","link":"","permalink":"http://sunyunzeng.com/剑指Offer-打印1到最大的n位数/","excerpt":"","text":"题目打印1到最大的n位数。示例：123输入 n = 1打印 1 2 3 4 5 6 7 8 9 思路 + 代码常规操作是暴力循环打印 1 到 n 位数，但是大数问题，存在数值溢出。采用字符串或者数组存储中间结果。 思路1用一个 长度为 n 的数组存储，然后分别在最后一位计算，每次加一，逢十进一。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class PrintToNNumber &#123; private static boolean increment(int[] nums) &#123; if(nums==null || nums.length==0) return false; // 相加是否大于10 int overflow = 0; int len = nums.length; for (int i = len - 1; i &gt;= 0; i--) &#123; int nSum = overflow + nums[i]; // 只在最后一位加 if(i==len-1)&#123; nSum++; &#125; if (nSum &lt; 10) &#123; nums[i] = nSum; return true; &#125; // &gt;= 10 // 超出范围 if(i==0)&#123; return false; &#125; nums[i] = 0; overflow = 1; &#125; return false; &#125; // 清楚掉数组前面的零 public static void printArray(int[] nums) &#123; int len = nums.length; boolean isZero = true; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]!=0) isZero = false; if (!isZero) &#123; System.out.print(nums[i]); &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int n = 3; int[] nums = new int[n]; while (increment(nums))&#123; printArray(nums); &#125; &#125;&#125; 思路2使用递归方法，递归到组后一位，然后依次往前打印。12345678910111213141516private static void recursive(int[] nums, int index) &#123; if (nums.length == index) &#123; printArray(nums); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; nums[index] = i; recursive(nums, index+1); &#125; &#125;public static void main(String[] args) &#123; int n = 3; int[] nums = new int[n]; recursive(nums, 0); &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"LeetCode 15.三数之和","slug":"LeetCode-15-三数之和","date":"2019-09-24","updated":"2019-10-02","comments":true,"path":"LeetCode-15-三数之和/","link":"","permalink":"http://sunyunzeng.com/LeetCode-15-三数之和/","excerpt":"","text":"题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。**注意：**答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路+代码先排序，然后三数之和等于零必定有 1 到 2 个小于零， 1 到 2 个大于零。然后我们采用双指针，先固定最小的一个数（负值）；然后双指针再后面区间寻找两个数，与前面数相加等于零。注意：因为不能包含重复三元组，在遍历过程中注意去重。保证每次遍历的数字与前面不一样即可（因为排序了）。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 排序求解 Arrays.sort(nums); // 循环求解 int len = nums.length; for(int i=0; i&lt;len; i++)&#123; // 此时没有满足条件的情况 if(nums[i]&gt;0) break; // 避免重复计算 if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; int j=i+1; int k=len-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==-nums[i])&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[k]); res.add(list); // 跳过重复的数字 while(j&lt;k&amp;&amp;nums[j]==nums[j+1])&#123; j++; &#125; while(j&lt;k&amp;&amp;nums[k]==nums[k-1])&#123; k--; &#125; j++; k--; &#125;else if(nums[j]+nums[k]&lt;-nums[i])&#123; // 左边负值大了 j++; &#125;else&#123; // 右边正值大了 k--; &#125; &#125; &#125; return res; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 674.最长连续子序列","slug":"Leetcode-674-最长连续子序列","date":"2019-09-23","updated":"2019-10-02","comments":true,"path":"Leetcode-674-最长连续子序列/","link":"","permalink":"http://sunyunzeng.com/Leetcode-674-最长连续子序列/","excerpt":"","text":"题目给定一个未经排序的整数数组，找到最长且连续的的递增序列。示例1：1234输入: [1,3,5,4,7]输出: 3解释: 最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。示例2：123输入: [2,2,2,2,2]输出: 1解释: 最长连续递增序列是 [2], 长度为1。**注意：**数组长度不会超过10000。 思路 + 代码 思路1我的思路，用一个栈进行递增子序列长度的检查，用res缓存结果。12345678910111213141516171819class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int res = 1; int len = nums.length; s.push(nums[0]); for(int i=1; i&lt;len; i++)&#123; if(nums[i]&lt;=nums[i-1])&#123; res = Math.max(res, s.size()); s.clear(); &#125; s.push(nums[i]); &#125; res = Math.max(res, s.size()); return res; &#125;&#125; 思路2动态规划，用一个长度为n的数值维度维护每个位置的最大长度，然后取其中最大值。123456789101112131415161718class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; int res = 1; int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for(int i=1; i&lt;len; ++i)&#123; if(nums[i]&gt;nums[i-1])&#123; dp[i] += dp[i-1]; res = Math.max(dp[i], res); &#125; &#125; return res; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"设计模式：Java类和接口","slug":"设计模式：Java类和接口","date":"2019-09-23","updated":"2019-10-02","comments":true,"path":"设计模式：Java类和接口/","link":"","permalink":"http://sunyunzeng.com/设计模式：Java类和接口/","excerpt":"","text":"使类与成员可访问性最小 成员（类、接口、方法、字段）的访问级别private —— 该成员只能在声明它的顶级类内访问。package-private —— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。protected —— 成员可以从被声明的类的子类中访问（会受一些限制 [JLS, 6.6.2]），以及它声明的包中的任何类。public —— 该成员可以从任何地方被访问。 公共类的实例字段很少情况下采用 public 修饰如果需要调用私有成员，就写一个方法。12345private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final Thing[] values() &#123; return PRIVATE_VALUES.clone();&#125; 公共类中使用访问方法而不是访问属性虽然包内访问权限，如果只包内可见是可行的，也可以，同时可以避免视觉混乱，但是不提倡这样做。12345// Degenerate classes like this should not be public!class Point &#123; public double x; public double y;&#125;提供提供方法与设置方法12345678910111213141516171819// Encapsulation of data by accessor methods and mutatorsclass Point &#123; private double x; private double y; public Point(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setX(double x) &#123; this.x = x; &#125; public void setY(double y) &#123; this.y = y; &#125;&#125; 不变类不变类中所有实例的信息在生命周期中都是固定的，因此是安全可靠的。 不变类的设计规则不要提供修改对象状态的方法 （也称为 mutators）。确保这个类不能被继承。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。把所有属性设置为 final。 通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为。把所有的属性设置为 private。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共 final 属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示。确保对任何可变组件的互斥访问。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法中进行防御性拷贝。 多使用组合而不是继承如果父类不是为了继承而专门设计，那么后面父类的修改可能会导致子类产生严重的bug。明智的方法是多使用组合composition。即在类内部使用其它类的引用。一个新类由一系列现有类组成，新类的方法通过调用现有类的方法获取结果，成为转发 (farwarding)。 继承需要深思熟虑还要详细的设计文档测试为继承而设计的类的唯一方法是编写子类。构造方法绝不能直接或间接调用可重写的方法。For example:12345678910111213141516171819202122232425262728public class Super &#123; // Broken - constructor invokes an overridable method public Super() &#123; overrideMe(); &#125; public void overrideMe() &#123; &#125;&#125;public final class Sub extends Super &#123; // Blank final, set by constructor private final Instant instant; Sub() &#123; instant = Instant.now(); &#125; // Overriding method invoked by superclass constructor @Override public void overrideMe() &#123; System.out.println(instant); &#125; public static void main(String[] args) &#123; Sub sub = new Sub(); sub.overrideMe(); &#125;&#125;上述子类由于重写了方法，调用父类时 instant 成员没有指向任何一个对象，因此有问题。专门为了继承而设计类是一件很辛苦的工作。你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。为了允许其他人能编写出高效的子类，还你必须导出一个或者多个受保护的方法。除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。 接口优先抽象类抽象类的实现只有继承，限制了混合类型的定义。同时，对于非层次的类级关系，想要为类添加额外的功能，接口是一个很好的方法。骨架抽象类，首先是一个抽象类，然后该抽象类实现了一个接口的基本方法，形成默认的方法实现，提供基础的功能。用户可以自由的选择是选择继承该抽象类还是直接实现该抽象类实现的接口，从而保证灵活性。骨架抽象类的例子：AbstractList、AbstractSet等。例子：12345678910111213141516171819202122232425262728293031323334// Skeletal implementation classpublic abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // Entries in a modifiable map must override this method @Override public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; // Implements the general contract of Map.Entry.equals @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue()); &#125; // Implements the general contract of Map.Entry.hashCode @Override public int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; @Override public String toString() &#123; return getKey() + \"=\" + getValue(); &#125;&#125; 接口用户定义类型 层次类优先于标签类标签类：是一个类，该类的实例根据构造方法传入标签的不同而不同。问题：代码可读性差，扩展性差，且内存负担大，因为类实例保存很多不属于它本身的字段。 层次类：即在顶层实现一个抽象类，该抽象类将属于公共的方法、字段及依赖于标签值的方法包括起来，提供实现样板。然后根据需求依次实现不同的子类，每个子类实现各自的方法。12345678910111213141516171819202122232425262728293031323334353637383940// 标签类// Tagged class - vastly inferior to a class hierarchy!class Figure &#123; enum Shape &#123; RECTANGLE, CIRCLE &#125;; // Tag field - the shape of this figure final Shape shape; // These fields are used only if shape is RECTANGLE double length; double width; // This field is used only if shape is CIRCLE double radius; // Constructor for circle Figure(double radius) &#123; shape = Shape.CIRCLE; this.radius = radius; &#125; // Constructor for rectangle Figure(double length, double width) &#123; shape = Shape.RECTANGLE; this.length = length; this.width = width; &#125; double area() &#123; switch(shape) &#123; case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(shape); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930// 层次类// Class hierarchy replacement for a tagged classabstract class Figure &#123; abstract double area();&#125;class Circle extends Figure &#123; final double radius; Circle(double radius) &#123; this.radius = radius; &#125; @Override double area() &#123; return Math.PI * (radius * radius); &#125;&#125;class Rectangle extends Figure &#123; final double length; final double width; Rectangle(double length, double width) &#123; this.length = length; this.width = width; &#125; @Override double area() &#123; return length * width; &#125;&#125;// 类之间的层次关系可读且灵活class Square extends Rectangle &#123; Square(double side) &#123; super(side, side); &#125;&#125; 嵌套类嵌套类最好只存在于宿主类 (enclosing class) 中, 否则，就应将其设计为顶层类。四种嵌套类：静态内部类、非静态内部类、匿名类、局部类。**静态内部类：**不与类的实例有关联，一个用法是提供类的帮助类。非静态内部类：确定与实例有关联才用，否则其默认将引用传给宿主类的实例，会占用存储空间与时间。最常用方法就是 Adapter 模式，可将外部类的实例视为某个不相关类的实例。例子：12345678910111213// Typical use of a nonstatic member classpublic class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; &#123; ... // Bulk of the class omitted @Override public Iterator&lt;E&gt; iterator() &#123; return new MyIterator(); &#125; private class MyIterator implements Iterator&lt;E&gt; &#123; ... &#125;&#125;匿名类： 只能在非静态上下文环境中使用时声明与实例化，在静态上下文环境，只能带有常量型变量（final修饰的基本类型及初始化为 String）。不能执行 instanceof 方法测试，不能在运行外实例化，不能实现多个接口或继承一个类同时实现一个接口。常用：创建小函数对象和处理对象的首选方法。**局部类：**非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 永远不要将多个顶级类或接口放在一个源文件中保证在编译时不能有多个定义。","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://sunyunzeng.com/tags/Java设计模式/"}]},{"title":"设计模式：Java方法","slug":"设计模式：Java方法","date":"2019-09-22","updated":"2019-10-02","comments":true,"path":"设计模式：Java方法/","link":"","permalink":"http://sunyunzeng.com/设计模式：Java方法/","excerpt":"","text":"使用 try-with-resources调用用完需关闭的方法。实现了 AutoCloseable接口（由一个返回为 void的close组成）的资源可以使用try-with-resources方法。AutoCloseable接口在Java的类库和第三方类库中许多类和接口都有实现或继承，例如 BufferedReader、InputStream、OutputStream 等。123456789101112// examplestatic void copy(String src, String dst) throws IOException &#123; try(InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst))&#123; byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.read(buf)) &gt;= 0)&#123; out.write(buf, 0, n); &#125; &#125; OutputStream &#125; 重写equals方法规则使用 == 运算符检查参数是否为该对象的引用。如果是，返回 true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。使用 instanceof 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 Float.compare(float, float) 方法；对于 double 基本类型的属性，使用 Double.compare(double, double) 方法。由于存在 Float.NaN，-0.0f 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。某些对象引用的属性可能合法地包含 null。 为避免出现 NullPointerException 异常，请使用静态方法 Objects.equals(Object, Object) 检查这些属性是否相等。 重写equals方法时一定重写hashCode方法。基于Hash值的散列数据结构，例如hashMap、HashSet等，需要基于Hash值判断两个是否相等，其实是根据equals方法来判断。equals方法改变，要想实例也能跟被基于hash的散列结构识别，需要将hashCode方法重写。 时刻重写toString方法。 使用clone方法对于可变对象的克隆需要谨慎。克隆出来的对象的类型与原始对象的一致，并且x.clone != x返回true。123456789101112131415161718192021222324252627282930313233343536373839404142434445// HashTable的克隆方法，需要深度克隆，保证克隆出来的对象是原先对象的深层拷贝，桶或链都拷贝一份// Recursive clone method for class with complex mutable statepublic class HashTable implements Cloneable &#123; private Entry[] buckets = ...; private static class Entry &#123; final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) &#123; this.key = key; this.value = value; this.next = next; &#125; // Recursively copy the linked list headed by this Entry //Entry deepCopy() &#123; // return new Entry(key, value, // next == null ? null : next.deepCopy()); //&#125; // 避免链表过长导致栈溢出错误 Entry deepCopy()&#123; Entry result = new Entry(key, value, next); for(Entry p = result; p!=null; p=p.next)&#123; p.next = new Entry(p.next.key, p.next.value, p.next.next); &#125; return result; &#125; &#125; @Override public HashTable clone() &#123; try &#123; HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; ... // Remainder omitted&#125; 在可比较大小的类中考虑实验Comparable接口。123public interface Comparable&lt;T&gt;&#123; int compareTo(T t);&#125;在conpareTo()中比较大小时，避免使用 &lt; 或者 &gt; ,应该使用包装类中的compare()方法或者自己实现Comparator接口中的compare()方法12345678910// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123; public int compare(Object o1, Object o2) &#123; return Integer.compare(o1.hashCode(), o2.hashCode()); &#125;&#125;;// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());参考： https://sjsdfg.github.io/effective-java-3rd-chinese/#/","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://sunyunzeng.com/tags/Java设计模式/"}]},{"title":"设计模式：Java创建对象","slug":"Java创建对象设计模式","date":"2019-09-20","updated":"2019-10-02","comments":true,"path":"Java创建对象设计模式/","link":"","permalink":"http://sunyunzeng.com/Java创建对象设计模式/","excerpt":"","text":"使用静态工厂方法代替构造方法静态工厂方法是一个静态方法，用来生成实例。例如：12345678910111213// 单例模式public class Dog&#123; // 私有方法防止在外调用创建实例 private Dog()&#123; &#125; private static class Inner()&#123; private static final Dog dog = new Dog(); &#125; public static getInstance()&#123; return Inner.dog; &#125;&#125;因为构造方法每次调用都需要新建一个对象，有些情况下不能满我们的要求。而静态工厂方法生成对象有以下几个好处：1. 名字更有意义。from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant);of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set faceCards = EnumSet.of(JACK, QUEEN, KING);valueOf —— from 和 to 更为详细的替代 方式，例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：StackWalker luke = StackWalker.getInstance(options);create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen);getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：FileStore fs = Files.getFileStore(path);newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：BufferedReader br = Files.newBufferedReader(path);type —— getType 和 newType 简洁的替代方式，例如：List litany = Collections.list(legacyLitany);2. 可以实现实例数量的控制。例如单例、不可实例化类的实现。3. 返回的对象可以根据参数不同而不同。4. 返回的实例可以没有对应的对象类型。例如服务者提供框架，就是用到静态工厂方法。服务接口，表示实现；提供者注册API，选择实现；服务访问API，客户端调用。服务提供者接口，描述生成服务接口实例的工厂对象。依赖注入框架可以被看作强大的服务提供者。 当构造函数多时使用builder模式构造函数名字都与类名一样，区分不同构造函数依靠参数的顺序与数量。当构造参数很多时，实例的生成非常麻烦，往往不知道调用哪个构造函数。123456789101112131415161718192021222324252627282930313233343536public class NutritionFacts&#123; private final int servingSize; private final int calories; private final int fat; public static class Builder&#123; private final int servingSize; private int calories; private int fat; public Builder(int servingSize)&#123; this.servingSize = servingSize; &#125; public Builder calories(int calories)&#123; calories = calories; return this; &#125; public Builder fat(int fat)&#123; fat = fat; return this; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder)&#123; this.servingSize = builder.servingSize; this.calories = builder.calories; this.fat = builder.fat; &#125;&#125;NutritionFacts coca = NutritionFacts.Builder(10).calories(40).fat(0).build();使用场景：当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。 单例模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 懒汉模式，线程不安全，不是严格意义上单例模式public class Dog&#123; private static final Dog dog; private Dog()&#123; &#125; public static getInstance()&#123; if(dog==null) dog = new Dog(); return dog; &#125;&#125;// 饿汉模式，线程安全，但易产生垃圾public class Dog&#123; private static final Dog dog = new Dog(); private Dog()&#123; &#125; public static getInstance()&#123; return dog; &#125;&#125;// 内部类方式，线程安全，但是序列化要保证单例，需要重写 readResolve()public class Dog&#123; private Dog()&#123; &#125; private static class Inner()&#123; private static final Dog dog = new Dog(); &#125; public static getInstance()&#123; return Inner.dog; &#125; // 序列化也保证一个单类 Object readResolve() throws ObjectStreamException&#123; return dog; &#125;&#125;//枚举模式，最简单，但不常用。线程安全，且保证序列化唯一性public enum Dog&#123; INSTANCE; public static getInstance()&#123; return Dog.INSTANCE; &#125;&#125; 使用私有构造方法非实例化构造方法声明为私有方法，可以创建非实例化类。该类存在的意义就是提供工具静态方法，例如 java.util.Arrays 工具类等。 简单依赖注入通过构造方法把类依赖的客户端资源注入到类中，是依赖注入的一种方式。123456789public class SpellChecker&#123; private final Chinese dictionary; public SpellChecker(Chinese dictionary)&#123; this.dictionary = Object.requireNonNull(dictionary); &#125; public boolean isValid(String word)&#123;...&#125;&#125;可以通过依赖注入把同一子类的资源工厂当做参数。工厂就是可以被重复调用生产实例的对象。Java 8的函数式接口Supplier非常适合工厂。12345@FunctionalInterfaceinterface Supplier&lt;T&gt;&#123; // 用来提供对象 T get();&#125;1Mosaic create(Supplier&lt;T? extends Tile&gt; tileFactroy)&#123;..&#125; 避免创建不必要的对象例如12345678910// 例子1Integer it = 0; for(int i=0; i&lt;1000000; i++)&#123; // 创建了1000000对象 it += i;&#125;// 例子2// 多创建了一个StringString s = new String(\"moreClass\");原则：尽量使用基本类型而不使用装箱的基本类型，即使自动装箱也要考虑。 消除过期的对象引用。如果对象引用是隐式存在，如果不需要，则置为null。例如编写stack类pop()方法：12345public &lt;T&gt; pop()&#123; &lt;T&gt; result = bucket[--size]; bucket[size] = null; return ;&#125; 避免使用Finalizer和Cleaner机制！参考： https://sjsdfg.github.io/effective-java-3rd-chinese/#/","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://sunyunzeng.com/tags/Java设计模式/"}]},{"title":"Leetcode 33.搜索旋转排序数组","slug":"Leetcode搜索旋转排序数组","date":"2019-09-15","updated":"2019-09-17","comments":true,"path":"Leetcode搜索旋转排序数组/","link":"","permalink":"http://sunyunzeng.com/Leetcode搜索旋转排序数组/","excerpt":"","text":"题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路+代码时间复杂度要求是O(log n)，也就是二分法。于是我写了一个最基础的二分法…还是用递归…1234567891011121314151617181920212223242526272829class Solution &#123; public int search(int[] nums, int target) &#123; if(nums.length==0 || nums==null) return -1; if(nums.length==1) return nums[0]==target?0:-1; return subSearch(nums, target, 0, nums.length-1); &#125; private int subSearch(int[] nums, int target, int left, int right)&#123; if(nums[left]==target) return left; if(nums[right]==target) return right; int mid = (left+right)/2; if(nums[mid]==target) return mid; if(right-left==1) return -1; int tmp=-1; tmp=subSearch(nums, target, left, mid); if(tmp!=-1) return tmp; tmp=subSearch(nums, target, mid, right); return tmp; &#125;&#125;看了答案之后… 我想说:****123456789101112131415161718192021222324252627class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(target==nums[mid]) return mid; // 左侧不包含旋转序列 if(nums[left]&lt;=nums[mid])&#123; if(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125; // 右侧不包含旋转序列 else&#123; if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123; left = mid+1; &#125;else&#123; right = mid-1; &#125; &#125; &#125; return -1; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Servlet技术","slug":"Servlet技术","date":"2019-09-11","updated":"2019-09-17","comments":true,"path":"Servlet技术/","link":"","permalink":"http://sunyunzeng.com/Servlet技术/","excerpt":"","text":"什么是Servet?Servlet (Server Applet)，从字面上看，就是Java服务器小程序的意思。它确实就像字面意思一样，是在服务中用于处理网络请求的小程序。在Web的世界中，客户端会提交各种请求到服务端，服务端如何处理客户端的请求呢？常规的Java编程方法，好像很难完成这项任务，但是没有事情是难倒程序猿的。于是，他们设计了Servlet规范，用来处理网络的各种请求。具体网络的请求呢，无非就是get、post等等，这在HTTP规范系列里面有讲到。Servlet规范也没有想象中的那么高大上，其实它就是一个Java接口，里面一共就定义了五个方法，如图：其中：init() 规定了Servet如何初始化。getServletConfig() 获取Sevvlet的配置。service(ServletRequest, ServletResponse) 接收到请求怎么处理。getServletInfo() 提供有关servlet的信息，如作者、版本、版权等。destroy() 销毁Servlet。 Servlet的运行任何合理实现了Servlet接口的类都具有处理HTTP请求的能力，但是就像java类的运行需要在JVM环境中一样，Servlet的运行也要环境，这里称为容器。即Servlet的运行需要特定的容器，该容器负责实现对端口的监听，将请求内容解析，然后实例Servlet对象，给Servlet提供运行环境，然后将Servlet的处理结果发给客户端。Tomcat就是一个开源的Servlet的容器，它也是一个Web服务器。HttpServlet就是已经实现好的一个Servlet类，他对一些方法进行了详细的补充，我们通过doGet()、doPost()等方法很方便地实现处理HTTP请求功能。它的一些源码如下：service()实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取http request的method参数，其实就是html的form标签 //中method属性对应的字符串 String method = req.getMethod(); long errMsg; //判断请求方式 if(method.equals(\"GET\")) &#123; //获取最后被修改时间 errMsg = this.getLastModified(req); if(errMsg == -1L) &#123; /**如果servlet不支持http request header的if-modified-since属性 * 则继续处理 **/ this.doGet(req, resp); &#125; else &#123; //如果支持这个属性 long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(\"If-Modified-Since\"); &#125; catch (IllegalArgumentException var9) &#123; ifModifiedSince = -1L; &#125; /** * 如果客户端的文件最后修改时间和服务器端的文件最后修改时间一致则返回304不需要修改状态 * 这样服务器就不返回html，浏览器读取本地缓存文件，否则重新获取服务器端的对应html文件 **/ if(ifModifiedSince &lt; errMsg / 1000L * 1000L) &#123; this.maybeSetLastModified(resp, errMsg); this.doGet(req, resp); &#125; else &#123; resp.setStatus(304); &#125; &#125; &#125; else if(method.equals(\"HEAD\")) &#123; errMsg = this.getLastModified(req); this.maybeSetLastModified(resp, errMsg); this.doHead(req, resp); &#125; else if(method.equals(\"POST\")) &#123; this.doPost(req, resp); &#125; else if(method.equals(\"PUT\")) &#123; this.doPut(req, resp); &#125; else if(method.equals(\"DELETE\")) &#123; this.doDelete(req, resp); &#125; else if(method.equals(\"OPTIONS\")) &#123; this.doOptions(req, resp); &#125; else if(method.equals(\"TRACE\")) &#123; this.doTrace(req, resp); &#125; else &#123; //如果请求不是以上的所有请求方式，该方法就会响应501错误，也就是不支持这种请求 String errMsg1 = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[]&#123;method&#125;; errMsg1 = MessageFormat.format(errMsg1, errArgs); resp.sendError(501, errMsg1); &#125; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException(\"non-HTTP request or response\"); &#125; this.service(request, response);&#125;doGet()实现：1234567891011121314protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取协议 String protocol = req.getProtocol(); //获取http.method_get_not_supported的国际化字符串 String msg = lStrings.getString(\"http.method_get_not_supported\"); if(protocol.endsWith(\"1.1\")) &#123; //如果是HTTP/1.1，返回405禁止访问方法错误 resp.sendError(405, msg); &#125; else &#123; //如果不是HTTP/1.1，返回400错误的请求错误 resp.sendError(400, msg); &#125; &#125;doPost()实现：12345678910protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString(\"http.method_post_not_supported\"); if(protocol.endsWith(\"1.1\")) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125;其实在工业界，几乎没有直接利用Servlet开发Web应用的了，但是它是一个基础，很多开源框架都是基于Servlet开发的，如大名鼎鼎的Spring 如何实现？首先我写一个Servlet类,作用是得到get()请求，然后返回“Hello Servlet!”与打印当前时间。12345678910111213public class HelloServlet extends HttpServlet&#123; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; response.getWriter().println(\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;然后配置web.xml文件，建立URL与Servlet处理类 HelloServlet 之间的关联关系。1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;其中servlet-name是类名简写，servlet-class 是类名。servlet-mapping实现URL与类的映射，这里实现了访问路径 http://127.0.0.1//hello 时调用HelloServlet类的相应方法。http://127.0.0.1 是一个监听地址，需要服务器实现监听，此时就需要Tomcat。然后修改Tomcat的conf/server.xml的路径配置。1&lt;Context path=\"/\" docBase=\"F:\\\\eclipse-workspace\\\\j2ee\\\\web\" debug=\"0\" reloadable=\"false\" /&gt; Servlet的特点1. Servlet是单实例多线程。当Web服务器启动或者用户请求抵达服务器时，Servlet被实例化且只存在一个实例。当请求抵达时，Servlet容器(如Tomcat)会调度线程 (Dispathchaer Thread)调度它管理下的线程池中等待执行的线程 (Worker Thread) 给请求者。线程执行Servlet中的sercive方法。请求结束，该线程放回线程池，等待被调用。2. Servet使用标准API，可被更多Web服务器调用。 线程安全由于Servlet是单实例多线程，当多个线程的用户同时访问共享资源时，就会出现线程安全的问题。解决方法:首先，定义在 doPost() 和 doGet()里的方法由于是局部变量，再每个用户调用实例方法时都会初始化，所以不存在线程安全。（一些属性尽量定义在实例的局部方法中）实在需要共享的资源，只需加synchronized同步机制，在共享资源被某一线程占用后，该线程就拥有锁，其它线程只有等待该线程执行完毕才能使用该资源（抢占锁后一一执行）。 Servlet的常用方法在HttpServlet中sercive方法中，参数列表接受两个对象，一个是HttpServletResponse对象，一个是HttpServletRequest对象。 HttpServletRequest常用方法常见方法方法名作用request.getRequestURL()浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)&quot;request.getRequestURI()浏览器发出请求的资源名部分，去掉了协议和主机名&quot;request.getQueryString()请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr()浏览器所处于的客户机的IP地址request.getRemoteHost()浏览器所处于的客户机的主机名request.getRemotePort()浏览器所处于的客户机使用的网络端口request.getLocalAddr()服务器的IP地址request.getLocalName()服务器的主机名request.getMethod()得到客户机请求方式一般是GET或者POST获取参数方法名作用request.getParameter()是常见的方法，用于获取单值的参数request.getParameterValues()用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap()用于遍历所有的参数，并返回Map类型。获取头信息方法名作用request.getHeader()获取浏览器传递过来的头信息。比如getHeader(“user-agent”)可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器request.getHeaderNames()获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息头信息含义：host: 主机地址user-agent: 浏览器基本资料accept: 表示浏览器接受的数据类型accept-language: 表示浏览器接受的语言accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码connection: 是否保持连接cache-control: 缓存时限 HttpServletResponse常用方法设置相应内容PrintWriter pw= response.getWriter();通过response.getWriter(); 获取一个PrintWriter 对象可以使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。设置相应内容response.setContentType(“text/html”);设置相应编码response.setContentType(&quot;text/html; charset=UTF-8&quot;);不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文response.setCharacterEncoding(&quot;UTF-8&quot;);仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。301或者302客户端跳转客户端有两种跳转:302 表示临时跳转response.sendRedirect(&quot;fail.html&quot;);301 表示永久性跳转response.setStatus(301);response.setHeader(&quot;Location&quot;, &quot;fail.html&quot;);设置不使用缓存123response.setDateHeader(\"Expires\",0 );response.setHeader(\"Cache-Control\",\"no-cache\");response.setHeader(\"pragma\",\"no-cache\");参考: http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://sunyunzeng.com/tags/Servlet/"}]},{"title":"Git 常用命令","slug":"Git-常用命令","date":"2019-09-11","updated":"2019-09-11","comments":true,"path":"Git-常用命令/","link":"","permalink":"http://sunyunzeng.com/Git-常用命令/","excerpt":"","text":"Git简介Git是世界上最先进的分布式版本控制系统。当时是为了帮助管理 linux 内核开发而开发的一个开源码版本控制系统。Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库Git 是分布式版本控制系统，每个人的电脑上都有完整的版本库。 常用命令列表 常用1234567891011121314151617181920$ git remote add origin git@github.com:yeszao/dofiler.git # 配置远程git版本库$ git pull origin master # 下载代码及快速合并 $ git add . # 跟踪所有改动过的文件$ git add &lt;file&gt; # 跟踪指定的文件$ git commit -m “commit message” # 提交所有更新过的文件$ git push origin master # 上传代码及快速合并$ git fetch origin # 从远程库获取代码$ git branch # 显示所有分支$ git checkout master # 切换到master分支$ git checkout -b dev # 创建并切换到dev分支$ git commit -m &quot;first version&quot; # 提交$ git status # 查看状态$ git log # 查看提交历史$ git config --global core.editor vim # 设置默认编辑器为vim（git默认用nano）$ git config core.ignorecase false # 设置大小写敏感$ git config --global user.name &quot;YOUR NAME&quot; # 设置用户名$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; # 设置邮箱 别名Alias123456789$ git config --global alias.br=&quot;branch&quot; # 创建/查看本地分支$ git config --global alias.co=&quot;checkout&quot; # 切换分支$ git config --global alias.cb=&quot;checkout -b&quot; # 创建并切换到新分支$ git config --global alias.cm=&quot;commit -m&quot; # 提交$ git config --global alias.st=&quot;status&quot; # 查看状态$ git config --global alias.pullm=&quot;pull origin master&quot; # 拉取分支$ git config --global alias.pushm=&quot;push origin master&quot; # 提交分支$ git config --global alias.log=&quot;git log --oneline --graph --decorate --color=always&quot; # 单行、分颜色显示记录$ git config --global alias.logg=&quot;git log --graph --all --format=format:&apos;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)&apos; --abbrev-commit --date=relative&quot; # 复杂显示 创建版本库12$ git clone &lt;url&gt; # 克隆远程版本库$ git init # 初始化本地版本库 修改和提交123456789$ git status # 查看状态$ git diff # 查看变更内容$ git add . # 跟踪所有改动过的文件$ git add &lt;file&gt; # 跟踪指定的文件$ git mv &lt;old&gt; &lt;new&gt; # 文件改名$ git rm &lt;file&gt; # 删除文件$ git rm --cached &lt;file&gt; # 停止跟踪文件但不删除$ git commit -m “commit message” # 提交所有更新过的文件$ git commit --amend # 修改最后一次提交 查看提交历史123$ git log # 查看提交历史$ git log -p &lt;file&gt; # 查看指定文件的提交历史$ git blame &lt;file&gt; # 以列表方式查看指定文件的提交历史 撤销12345$ git reset --hard HEAD # 撤消工作目录中所有未提交文件的修改内容$ git reset --hard &lt;version&gt; # 撤销到某个特定版本$ git checkout HEAD &lt;file&gt; # 撤消指定的未提交文件的修改内容$ git checkout -- &lt;file&gt; # 同上一个命令$ git revert &lt;commit&gt; # 撤消指定的提交 分支与标签1234567891011$ git branch # 显示所有本地分支$ git checkout &lt;branch/tag&gt; # 切换到指定分支或标签$ git branch &lt;new-branch&gt; # 创建新分支$ git branch -d &lt;branch&gt; # 删除本地分支$ git tag # 列出所有本地标签$ git tag &lt;tagname&gt; # 基于最新提交创建标签$ git tag -a &quot;v1.0&quot; -m &quot;一些说明&quot; # -a指定标签名称，-m指定标签说明$ git tag -d &lt;tagname&gt; # 删除标签$ git checkout dev # 合并特定的commit到dev分支上$ git cherry-pick 62ecb3 合并与衍合1234$ git merge &lt;branch&gt; # 合并指定分支到当前分支$ git merge --abort # 取消当前合并，重建合并前状态$ git merge dev -Xtheirs # 以合并dev分支到当前分支，有冲突则以dev分支为准$ git rebase &lt;branch&gt; # 衍合指定分支到当前分支 远程操作12345678910复制代码$ git remote -v # 查看远程版本库信息$ git remote show &lt;remote&gt; # 查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; # 添加远程版本库$ git remote remove &lt;remote&gt; # 删除指定的远程版本库$ git fetch &lt;remote&gt; # 从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; # 下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; # 上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; # 删除远程分支或标签$ git push --tags # 上传所有标签 打包123$ git archive --format=zip --output ../file.zip master # 将master分支打包成file.zip文件，保存在上一级目录$ git archive --format=zip --output ../v1.2.zip v1.2 # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中$ git archive --format=zip v1.2 &gt; ../v1.2.zip # 作用同上一条命令 远程与本地合并123456$ git init # 初始化本地代码仓$ git add . # 添加本地代码$ git commit -m &quot;add local source&quot; # 提交本地代码$ git pull origin master # 下载远程代码$ git merge master # 合并master分支$ git push -u origin master # 上传代码参考资料：https://www.cnblogs.com/ldj3/p/9172804.htmlhttps://www.zhihu.com/question/41667536/answer/486640083","categories":[{"name":"Git","slug":"Git","permalink":"http://sunyunzeng.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://sunyunzeng.com/tags/Git/"}]},{"title":"TCP/IP协议","slug":"TCP-IP协议","date":"2019-09-10","updated":"2019-09-11","comments":true,"path":"TCP-IP协议/","link":"","permalink":"http://sunyunzeng.com/TCP-IP协议/","excerpt":"","text":"起源 HTTP的来历CERN(欧洲核子研究组织)的蒂姆 • 伯纳斯 - 李(Tim BernersLee)博士提出了一种能让远隔两地的研究者们共享知识的设想。最初的设想是通过超文本(HyperText)标记,各地互联连接成可相互参阅的WWW(World Wide Web, 万维网)。目前WWW构建的关键技术为：基于SGML(Standard Generalized Markup Language,标准通用标记语言)的HTML （HyperText Markup Language, 超文本标记语言）。指定文档所在的地址URL (Uniform Resource Locator, 统一资源定位符) 。各个Web服务器通过万维网互相连接，以 HTML 标准编辑网页（存储信息），用 URL 实现信息的查找，最后通过Web浏览器实现界面的渲染。 如何控制信息的传输？然而，Web服务器有各种各样的类型及硬件接口，显示平台也有各种各样的类型，如何实现平台之间信息的互相交流呢？ —— 统一协议控制。答案是通过统一的协议 (Protocol)。# TCP/TP 协议簇TCP/IP 有说法是专指TCP和IP协议。这里指互联网相关的各类协议簇的总称，例如：IP, PPPoE, TCP, FTP, HTTP, FDDI, IEEE 802.3, SNMP, UDP, DNS, ICMP 等等。也就是说 HTTP 是 TCP/IP 协议的子集。 分层管理在逻辑上，TCP/IP分为四个层次：应用层、传输层、网络层和数据链路层。名称作用应用层客户端实现信息的封装与解析。该层使用的协议如 HTTP、DNS (Domain Name System, 域名系统)、FTP (File Transfer Protocol, 文件传输协议)等。传输层提供网络连接中两台计算机之间的数据传输。使用的协议：TCP (Transmission Control Protocol) 和 UDP (User Data Protocol, 用户数据协议)。网络层将网络中流动的数据包（网络传输最小数据单位）通过规定的路径（传输线路）到达对方的计算机，并把数据传给对方。数据链路层肉眼可见的硬件层，包括网卡、光纤等。 数据传输过程用户根据HTTP协议发送一个数据请求（应用层）。获得应用层数据后，传输层（TCP协议）为了方便，将数据（HTTP请求报文）进行分割，每个报文打上标记序号及端口号，然后转发给网络层。网络层将通信目的地的DNS增加到数据中，然后转发给数据链路层。数据链路层将数据发给目的地终端。在解析数据时，按照数据包装的逆序层层解包（去除每一层打上的首部信息），最终获得请求的HTTP报头。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://sunyunzeng.com/categories/HTTP/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://sunyunzeng.com/tags/TCP-IP/"}]},{"title":"Leetcode 岛屿最大的面积","slug":"Leetcode-岛屿最大的面积","date":"2019-09-07","updated":"2020-01-11","comments":true,"path":"Leetcode-岛屿最大的面积/","link":"","permalink":"http://sunyunzeng.com/Leetcode-岛屿最大的面积/","excerpt":"","text":"题目给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)示例1:12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。示例2:1[[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。注意: 给定的矩阵grid 的长度和宽度都不超过 50。 思路+代码一开始想的是动态规划，但是该题没有规律的求解方法，即岛屿的形状无法用统一的方法计算。此题采用 DFS（深度优先遍历）的方法求解。DFS一般解体模板（https://blog.csdn.net/weixin_43272781/article/details/82959089）。123456789101112131415161718192021int check(参数)&#123; if(满足条件) return 1; return 0;&#125; void dfs(int step)&#123; 判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） &#125;&#125;此题的解法：边界条件是二维矩阵的边界。尝试每一种可能是上、下、左、右四个方向进行遍历。check是是否为陆地（数值是否为1）。标记是将遍历过的陆地变成海洋（置为0）。123456789101112131415161718192021222324252627282930313233class Solution &#123; private int row; private int col; public int maxAreaOfIsland(int[][] grid) &#123; row = grid.length; col = grid[0].length; if(row==0 || col==0) return 0; int res = 0; for(int i=0; i&lt;row; i++)&#123; for(int j=0; j&lt;col; j++)&#123; if(grid[i][j]&gt;0)&#123; res = Math.max(res, dfs(grid, i, j)); &#125; &#125; &#125; return res; &#125; private int dfs(int[][] g, int i, int j)&#123; int sum = 1, x=0, y=0; int[][] dir = new int[][]&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; //避免再次被选到 g[i][j] = 0; for(int s=0;s&lt;4;s++)&#123; x = i + dir[s][0]; y = j + dir[s][1]; if(x&gt;=0 &amp;&amp; x&lt;row &amp;&amp; y&gt;=0 &amp;&amp; y&lt;col &amp;&amp; g[x][y]&gt;0)&#123; sum += dfs(g, x ,y); &#125; &#125; return sum; &#125;&#125;题目链接：https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"backtrace","slug":"backtrace","permalink":"http://sunyunzeng.com/tags/backtrace/"}]},{"title":"Markdown文件中添加UML图","slug":"Markdown文件中添加UML图","date":"2019-09-04","updated":"2019-09-05","comments":true,"path":"Markdown文件中添加UML图/","link":"","permalink":"http://sunyunzeng.com/Markdown文件中添加UML图/","excerpt":"","text":"UML图简介UML(Unified Modeling Language)是统一建模语言的简写。它可分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。静态图分为：用例图，类图，对象图，包图，构件图，部署图。动态图分为：状态图，活动图，协作图，序列图。其中类图 (Class Diagrams)是用来表示类的内部结构和类与类之间的关系的一种UML。常见的关系有：泛化 (Generalization)，实现 (Realization)，组合 (Composition)，聚合 (Aggregation)，关联 (Association)，依赖 (Dependency)。各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖参考教程 UML类图的绘制及插入我们利用在线的开源工具plantUML实现UML图绘制。具体的绘制方法可以参考官网plantUML。然后将网址中生成的UML图片地址插入到Markdown文件中。参考教程","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"网页","slug":"网页","permalink":"http://sunyunzeng.com/tags/网页/"}]},{"title":"Leetcode 字符串的排列 (String 练习 03)","slug":"Leetcode-字符串的排列-String-练习-03","date":"2019-09-01","updated":"2019-09-01","comments":true,"path":"Leetcode-字符串的排列-String-练习-03/","link":"","permalink":"http://sunyunzeng.com/Leetcode-字符串的排列-String-练习-03/","excerpt":"","text":"题目给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。示例1:123输入: s1 = \"ab\" s2 = \"eidbaooo\"输出: True解释: s2 包含 s1 的排列之一 (\"ba\").示例2:12输入: s1= \"ab\" s2 = \"eidboaoo\"输出: False注意:121. 输入的字符串只包含小写字母2. 两个字符串的长度都在 [1, 10,000] 之间 思路 1暴力法，滑动窗口依次判定。但是超出时间限制！1234567891011121314151617181920212223class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; for(int i=0; i+len1&lt;=len2; i++)&#123; if(checkSubString(s1, s2.substring(i, i+len1))) return true; &#125; return false; &#125; private boolean checkSubString(String subS1, String subS2)&#123; String s = new String(subS2); for(int i=0; i&lt;subS1.length(); i++)&#123; if(s.indexOf(subS1.charAt(i))!=-1)&#123; s = s.replaceFirst(String.valueOf(subS1.charAt(i)), \"\"); &#125; &#125; return s.isEmpty()?true:false; &#125;&#125;时间复杂度：O((len2-len1) * len1 * len2 * len2)空间复杂度：O(1) 思路 2也是滑动窗口法，不过不用内置的函数（使用过程中存在循环遍历），而利用数组存储各个字母出现的次数，进行子串是否匹配的判定依据。123456789101112131415161718192021222324252627class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; int[] temp1 = new int[26]; for(int i=0; i&lt;len1; i++) temp1[s1.charAt(i)-'a']++; for(int i=0; i+len1&lt;=len2; i++)&#123; int[] temp2 = new int[26]; for(int j=0; j&lt;s1.length(); j++)&#123; temp2[s2.charAt(i+j)-'a']++; &#125; if(match(temp1, temp2)) return true; &#125; return false; &#125; private boolean match(int[] tmp1, int[] tmp2)&#123; for(int i=0; i&lt;tmp1.length; i++)&#123; if(tmp1[i]!=tmp2[i]) return false; &#125; return true; &#125;&#125;时间复杂度：O(len1 + (len2-len1) * len1 * 26)空间复杂度: O(1) 思路 3基于思路2，继续进行优化。其实在滑动窗口中，每次只更新哈希表（数组）的第一个值及最后一个值，中间的不需要遍历。因此时间复杂度降低 len1123456789101112131415161718192021222324252627282930class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; int[] temp1 = new int[26]; int[] temp2 = new int[26]; for(int i=0; i&lt;len1; i++)&#123; temp1[s1.charAt(i)-'a']++; temp2[s2.charAt(i)-'a']++; &#125; if(match(temp1, temp2)) return true; for(int i=0; i+len1&lt;len2; i++)&#123; temp2[s2.charAt(i+len1)-'a']++; temp2[s2.charAt(i)-'a']--; if(match(temp1, temp2)) return true; &#125; return false; &#125; private boolean match(int[] tmp1, int[] tmp2)&#123; for(int i=0; i&lt;tmp1.length; i++)&#123; if(tmp1[i]!=tmp2[i]) return false; &#125; return true; &#125;&#125;时间复杂度：O(len1 + (len2-len1) * 26)空间复杂度: O(1)作者：LeetCode链接：https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 最长公共前缀 (String 练习 01)","slug":"Leetcode-最长公共前缀","date":"2019-08-31","updated":"2019-09-01","comments":true,"path":"Leetcode-最长公共前缀/","link":"","permalink":"http://sunyunzeng.com/Leetcode-最长公共前缀/","excerpt":"","text":"题目编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。示例1:12输入: [\"flower\",\"flow\",\"flight\"]输出: \"fl\"示例2:123输入: [\"dog\",\"racecar\",\"car\"]输出: \"\"解释: 输入不存在公共前缀。说明:1所有输入只包含小写字母 a-z 。 思路1暴力法，时间复杂度O(n^3)。123456789101112131415161718192021class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; String ans = \"\"; if(strs.length==0) return ans; lable:&#123; for(int j=0; j&lt;strs[0].length(); j++)&#123; char c = strs[0].charAt(j); for(int i=1; i&lt;strs.length; i++)&#123; if(j&gt;=strs[i].length() || !isCharEqual(c, strs[i], j))&#123; break lable; &#125; &#125; ans += c; &#125; &#125; return ans; &#125; private boolean isCharEqual(char c, String s, int i)&#123; return c==s.charAt(i); &#125;&#125; 思路2巧用String提供的一些API，例如substring(),判定子串的位置。123456789101112131415class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; String ans; if(strs.length==0) return \"\"; ans = strs[0]; for(int i=1; i&lt;strs.length; i++)&#123; while(strs[i].indexOf(ans)!=0)&#123; ans = ans.substring(0, ans.length()-1); if(ans.isEmpty()) return ans; &#125; &#125; return ans; &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Java: Set API","slug":"Java-Set-API","date":"2019-08-31","updated":"2019-08-31","comments":true,"path":"Java-Set-API/","link":"","permalink":"http://sunyunzeng.com/Java-Set-API/","excerpt":"","text":"Java Set 概述Set 继承自集合（Collection），该集合不能包含相同的元素。Set 里面进行元素是否相同的判定是通过 Object 类自带的**equals()**实现。Set 最多可存储一个 null 元素。Set 只是一个抽象的接口，具体的使用还要用具体的实现，如HashSet、TreeSet等。 常用方法因为 Set 继承自集合 Collection，所以具有集合的方法。方法描述int size()返回Set里面存储的元素个数。boolean isEmpty()如果没有元素，返回true。boolean add(E e)如果Set里面没有包含元素e，就将其加入。boolean addAll(Collection&lt;? extends E&gt;c)如果指定集合中的元素不存在Set中，就将其加入Set。如果该Collection也是一个Set，相当于对这两个Set取并集。boolean contains(Object o)是否包含特定的元素 o。即对Set里面的任意元素e执行判定(onull?enull:o.equals(e))。boolean containsAll(Collecton&lt; ? &gt;c)该Set是否包含指定Collection的所有元素。void clear()清除所有元素。boolean remove(Object o)删除指定元素。boolean removeAll(Collection&lt; ? &gt;c)删除Set中存在于该Collection里的元素。Object[ ] toArray()将Set转化为数组。&lt; T &gt; T[ ] toArray(T[ ] a)返回所有的Set元素并存储在Array中。如果a的长度大于Set长度，则多余空间以null补全。Iterator&lt; E &gt; iterator()返回一个该Set的迭代器default Spliterator&lt; E &gt; spliterator()在该集合中创建拆分器。 常用Set实现 HashSetHashSet的方法基本与Set一致，只不过多了一个**Object clone()**方法（浅复制，只复制地址）。主要方法包括：add()clear()clone()contains()isEmpty()iterator()remove()size()spliterator()HashSet底层是基于HashMap实现的。即通过HashMap的键唯一性实现。构造方法示例1234567891011121314151617public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125;// 该构造方法为LinkedHashSet实现准备HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; LinkedHashSetLinkedHashSet保存了元素的顺序，即插入时的顺序，再使用iterator遍历时会按顺序遍历。LinkedHashSet底层也是根据LinkHashMap实现的。通过父类HashSet的构造方法，调用LinkHashMap。123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;继承自 HashSet，实现了接口 Serializable 及 Cloneable。Serializable是一个空接口，是一个序列化的标记，用来告诉JVM该类可以序列化。序列化就是把对象的状态转化为可存储和传输的格式（如二进制流）；反序列化就是序列化的逆过程，根据序列化后的数据重新恢复对象及其状态。 TreeSet可实现排序的Set，排序规则可以是自带的或者通过Comparator实现。基础操作（add,contains and remove）的耗时是log(n)。实现了NavigableSet接口，该接口是基于TreeMap的。TreeSet底层是基于TreeMap实现，所以对于系统内部类例如Integer、String等，由于实现了Comparable接口，可直接进行存储；对于自定义的类，必须实现Comparable接口并重写comparaTo（）方法，这样TreeSet才能根据排序规则进行排序。TreeSet不能有重复元素。TreeSet的存取不如HashSet快。**comparaTo()**方法在被调用过程中，如果返回真值（或大于零的数），就认为新插入元素大于根元素，存入右节点，此时为顺序排列；反之存入左节点，为逆序排列。构造函数：序号构造函数的说明1TreeSet()，此构造函数构造空树集，将在根据其元素的自然顺序按升序排序。2TreeSet (集合 c)，此构造函数生成树的集合，它包含的元素的集合 c。3TreeSet (比较器 comp)，此构造函数构造一个空树集，将根据给定的比较器进行排序。4TreeSet (SortedSet ss)，此构造函数生成包含给定 SortedSet 的元素 TreeSet常用方法：修饰符和类型方法和描述booleanadd(E e)，将指定的元素添加到这套，如果它已不存在。booleanaddAll(Collection&lt;? extends E&gt; c)，在加入这一组指定的集合中添加的所有元素。Eceiling(E e)，返回最小的元素在这一组大于或等于给定的元素，则null如果没有这样的元素。voidclear()，从这一组中移除所有元素。Objectclone()，返回此TreeSet实例浅表副本。Comparator&lt;? super E&gt;comparator()，返回用于排序在这集，或空元素，如果这套使用自然排序其元素的比较。booleancontains(Object o)，如果此集合包含指定的元素，则返回true 。IteratordescendingIterator()，返回迭代器中这套降序排序的元素。NavigableSetdescendingSet()，返回逆序视图中包含的元素这一套。Efirst()，返回第一个 （最低） 元素当前在这一套。Efloor(E e)，返回的最大元素在这一组小于或等于null如果没有这样的元素。SortedSetheadSet(E toElement)，返回其元素是严格小于toElement这套的部分视图.NavigableSetheadSet(E toElement, boolean inclusive)，返回一个视图的这部分设置的元素都小于 （或等于，如果inclusive是真的） toElement.Ehigher(E e)，返回最小的元素在这套严格大于给定的元素，则null如果没有这样的元素。booleanisEmpty()，如果此集不包含任何元素，则返回true 。Iteratoriterator()，返回迭代器中这套以升序排序的元素。Elast()，在这套目前返回的最后一个 （最高） 的元素。Elower(E e)，在这一套严格的小于给定的元素，则null返回的最大元素，如果没有这样的元素。EpollFirst()，检索和删除第一个 （最低） 元素，或如果此集合为空，则返回null 。EpollLast()，检索和删除的最后一个 （最高） 的元素，或如果此集合为空，则返回null 。booleanremove(Object o)，从这一组中移除指定的元素，如果它存在。intsize()，在这套 （其基数） 中返回的元素的数目。NavigableSetsubSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)，返回此集的部分视图的元素范围从fromElement到toElement.SortedSetsubSet(E fromElement, E toElement)，返回视图的部分的这一套的元素范围从fromElement，具有包容性，到toElement，独家。SortedSettailSet(E fromElement)，返回其元素是大于或等于fromElement这套的部分视图.NavigableSettailSet(E fromElement, boolean inclusive)，返回其元素是大于 （或等于，如果inclusive是真的） 这套的部分视图fromElement.实现原理TreeSet底层依赖于TreeMap，通过TreeMap来作为存储TreeSet的容易，键值保证了元素的唯一性。采用“红黑树”的排序二叉树保存Map中的每个Entry，每个Entry被当做“红黑树”的一个节点。“红黑树”是一种平衡二叉查找树，树中节点都大于等于左子树所有节点，且小于等于右子树左右节点。TreeSet部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245package java.util;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 使用NavigableMap对象的key来保存Set集合的元素 private transient NavigableMap&lt;E,Object&gt; m; //使用PRESENT作为Map集合中的value private static final Object PRESENT = new Object(); // 不带参数的构造函数。创建一个空的TreeMap //以自然排序方法创建一个新的TreeMap，再根据该TreeMap创建一个TreeSet //使用该TreeMap的key来保存Set集合的元素 public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; // 将TreeMap赋值给 \"NavigableMap对象m\" TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; //以定制排序的方式创建一个新的TreeMap。根据该TreeMap创建一个TreeSet //使用该TreeMap的key来保存set集合的元素 public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;E,Object&gt;(comparator)); &#125; // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中 public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); // 将集合c中的元素全部添加到TreeSet中 addAll(c); &#125; // 创建TreeSet，并将s中的全部元素都添加到TreeSet中 public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; // 返回TreeSet的顺序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator(); &#125; // 返回TreeSet的逆序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator(); &#125; // 返回TreeSet的大小 public int size() &#123; return m.size(); &#125; // 返回TreeSet是否为空 public boolean isEmpty() &#123; return m.isEmpty(); &#125; // 返回TreeSet是否包含对象(o) public boolean contains(Object o) &#123; return m.containsKey(o); &#125; // 添加e到TreeSet中 public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; // 删除TreeSet中的对象o public boolean remove(Object o) &#123; return m.remove(o)==PRESENT; &#125; // 清空TreeSet public void clear() &#123; m.clear(); &#125; // 将集合c中的全部元素添加到TreeSet中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // Use linear-time version if applicable if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; //把C集合强制转换为SortedSet集合 SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; //把m集合强制转换为TreeMap集合 TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); //如果cc和mc两个Comparator相等 if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; //把Collection中所有元素添加成TreeMap集合的key map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; return super.addAll(c); &#125; // 返回子Set，实际上是通过TreeMap的subMap()实现的。 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; // 返回Set的头部，范围是：从头部到toElement。 // inclusive是是否包含toElement的标志 public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; // 返回Set的尾部，范围是：从fromElement到结尾。 // inclusive是是否包含fromElement的标志 public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。 public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; // 返回Set的头部，范围是：从头部到toElement(不包括)。 public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。 public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; // 返回Set的比较器 public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; // 返回Set的第一个元素 public E first() &#123; return m.firstKey(); &#125; // 返回Set的最后一个元素 public E first() &#123; public E last() &#123; return m.lastKey(); &#125; // 返回Set中小于e的最大元素 public E lower(E e) &#123; return m.lowerKey(e); &#125; // 返回Set中小于/等于e的最大元素 public E floor(E e) &#123; return m.floorKey(e); &#125; // 返回Set中大于/等于e的最小元素 public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; // 返回Set中大于e的最小元素 public E higher(E e) &#123; return m.higherKey(e); &#125; // 获取第一个元素，并将该元素从TreeMap中删除。 public E pollFirst() &#123; Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null)? null : e.getKey(); &#125; // 获取最后一个元素，并将该元素从TreeMap中删除。 public E pollLast() &#123; Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null)? null : e.getKey(); &#125; // 克隆一个TreeSet，并返回Object对象 public Object clone() &#123; TreeSet&lt;E&gt; clone = null; try &#123; clone = (TreeSet&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; clone.m = new TreeMap&lt;E,Object&gt;(m); return clone; &#125; // java.io.Serializable的写入函数 // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); // 写入比较器 s.writeObject(m.comparator()); // 写入容量 s.writeInt(m.size()); // 写入“TreeSet中的每一个元素” for (Iterator i=m.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeSet的“比较器、容量、所有的元素值”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden stuff s.defaultReadObject(); // 从输入流中读取TreeSet的“比较器” Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); TreeMap&lt;E,Object&gt; tm; if (c==null) tm = new TreeMap&lt;E,Object&gt;(); else tm = new TreeMap&lt;E,Object&gt;(c); m = tm; // 从输入流中读取TreeSet的“容量” int size = s.readInt(); // 从输入流中读取TreeSet的“全部元素” tm.readTreeSet(size, s, PRESENT); &#125; // TreeSet的序列版本号 private static final long serialVersionUID = -2479143000061671589L;&#125;我们发现，TreeSet底层是依靠TreeMap对key进行存储排序实现的，现在看一下TreeMap的部分源码。TreeMap的put()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public V put(K key, V value) &#123; //定义一个t来保存根元素 Entry&lt;K,V&gt; t = root; //如果t==null，表明是一个空链表 if (t == null) &#123; //如果根节点为null，将传入的键值对构造成根节点（根节点没有父节点，所以传入的父节点为null） root = new Entry&lt;K,V&gt;(key, value, null); //设置该集合的size为1 size = 1; //修改此时+1 modCount++; return null; &#125; // 记录比较结果 int cmp; Entry&lt;K,V&gt; parent; // 分割比较器和可比较接口的处理 Comparator&lt;? super K&gt; cpr = comparator; // 有比较器的处理，即采用定制排序 if (cpr != null) &#123; // do while实现在root为根节点移动寻找传入键值对需要插入的位置 do &#123; //使用parent上次循环后的t所引用的Entry // 记录将要被掺入新的键值对将要节点(即新节点的父节点) parent = t; // 使用比较器比较父节点和插入键值对的key值的大小 cmp = cpr.compare(key, t.key); // 插入的key较大 if (cmp &lt; 0) t = t.left; // 插入的key较小 else if (cmp &gt; 0) t = t.right; // key值相等，替换并返回t节点的value(put方法结束) else return t.setValue(value); &#125; while (t != null); &#125; // 没有比较器的处理 else &#123; // key为null抛出NullPointerException异常 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 与if中的do while类似，只是比较的方式不同 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 没有找到key相同的节点才会有下面的操作 // 根据传入的键值对和找到的“父节点”创建新节点 Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); // 根据最后一次的判断结果确认新节点是“父节点”的左孩子还是又孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 对加入新节点的树进行调整 fixAfterInsertion(e); // 记录size和modCount size++; modCount++; // 因为是插入新节点，所以返回的是null return null; &#125;发现在插入过程中，会进行二叉树排序的判定：如果新增节点大于当前节点且当前节点的右子节点存在，则以右子节点作为当前节点。并继续循环如果新增节点小于当前节点且当前节点的左子节点存在，则以左子节点作为当前节点。并继续循环如果新增节点等于当前节点，则新增节点覆盖当前节点，并结束循环。TreeMap的get()方法123456public V get(Object key) &#123; //根据key取出Entry Entry&lt;K,V&gt; p = getEntry(key); //取出Entry所包含的value return (p==null ? null : p.value); &#125;关键在于 **getEntry()**是怎么根据Comparable取出对应Entry的。1234567891011121314151617181920212223242526272829303132final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 如果有比较器，返回getEntryUsingComparator(Object key)的结果 if (comparator != null) return getEntryUsingComparator(key); // 查找的key为null，抛出NullPointerException if (key == null) throw new NullPointerException(); // 如果没有比较器，而是实现了可比较接口 //将key强制转换为Comparable接口 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 获取根节点 Entry&lt;K,V&gt; p = root; // 从根节点开始对树进行遍历查找节点 while (p != null) &#123; // 把key和当前节点的key进行比较 int cmp = k.compareTo(p.key); // key小于当前节点的key if (cmp &lt; 0) // p “移动”到左节点上 p = p.left; // key大于当前节点的key else if (cmp &gt; 0) // p “移动”到右节点上 p = p.right; // key值相等则当前节点就是要找的节点 else // 返回找到的节点 return p; &#125; // 没找到则返回null return null;&#125;其实就是一个二叉查找，根据Comparable进行key大小的判断。如果采用定制比较器，则采用**getEntryUsingComparator()**方法。1234567891011121314151617181920212223242526272829final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; // 获取比较器 Comparator&lt;? super K&gt; cpr = comparator; // 其实在调用此方法的get(Object key)中已经对比较器为null的情况进行判断，这里是防御性的判断 if (cpr != null) &#123; // 获取根节点 Entry&lt;K,V&gt; p = root; // 遍历树 while (p != null) &#123; // 获取key和当前节点的key的比较结果 int cmp = cpr.compare(k, p.key); // 查找的key值较小 if (cmp &lt; 0) // p“移动”到左孩子 p = p.left; // 查找的key值较大 else if (cmp &gt; 0) // p“移动”到右节点 p = p.right; // key值相等 else // 返回找到的节点 return p; &#125; &#125; // 没找到key值对应的节点，返回null return null;&#125;参考资料1 参考资料2","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Leetcode 无重复字符的最长子串（String 练习 02）","slug":"Leetcode-无重复字符的最长子串","date":"2019-08-30","updated":"2019-09-01","comments":true,"path":"Leetcode-无重复字符的最长子串/","link":"","permalink":"http://sunyunzeng.com/Leetcode-无重复字符的最长子串/","excerpt":"","text":"题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例1:123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例2:123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例3:1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 思路 1暴力法，用Set记录检查的无重复的最长子串。123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; char[] chars = s.toCharArray(); if(chars.length==1) return 1; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int result = 0; for(int i=0; i &lt; chars.length-1; i++)&#123; set.add(chars[i]); for(int j=i+1; j&lt;chars.length;j++)&#123; if(!set.contains(chars[j]))&#123; set.add(chars[j]); &#125;else&#123; break; &#125; &#125; result = Math.max(result, set.size()); set.clear(); &#125; return result; &#125;&#125; 思路 2滑动窗口法。暴力法虽然容易想到，但是很多情况重复考虑了。例如假定在 i ~ j 子串为不重复子串，那么该子串内的子串都会不重复。滑动窗口法 1：采用标记记录左侧窗口的索引值。12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int result = 0; char[] chars = s.toCharArray(); int leftIndex = 0; // 滑动窗口的右边索引 for(int i=0; i&lt;chars.length; i++)&#123; // 对于当前的滑动窗口进行重复性字符检查 for(int checkIndex = leftIndex; checkIndex&lt;i; checkIndex++)&#123; // 如果存在相同字符串，就更新窗口左边索引 if(chars[checkIndex]==chars[i])&#123; // 更新结果 result = Math.max(result, i-leftIndex); leftIndex = checkIndex+1; break;a &#125; &#125; &#125; // 检查最后一次窗口的长度与result保留长度进行对比 return Math.max(chars.length-leftIndex, result); &#125;&#125;滑动窗口 2：巧用 HashSet，利用HashSet维护范围为 [i,j) 的滑动窗口。先滑动右边，j++。如果存在重复，记录此时长度，再滑动左边 i++。直到所有的 i 遍历完成。12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ans=0, i=0, j=0; int len = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while(i &lt; len &amp;&amp; j &lt; len)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j-i); &#125;else&#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125;滑动窗口 3：上面的优化。如果 j 存在重复，那么 i 不仅移动一位，而是移动到 j+1 的位置。123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int ans = 0; int len = s.length(); for(int i=0, j=0; j&lt;len; j++)&#123; if(map.containsKey(s.charAt(j)))&#123; i = Math.max(i, map.get(s.charAt(j))); &#125; ans = Math.max(ans, j-i+1); map.put(s.charAt(j), j+1); &#125; return ans; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 969.煎饼排序","slug":"Leetcode-969-煎饼排序","date":"2019-08-28","updated":"2019-08-30","comments":true,"path":"Leetcode-969-煎饼排序/","link":"","permalink":"http://sunyunzeng.com/Leetcode-969-煎饼排序/","excerpt":"","text":"题目给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。示例 1:123456789输入：[3,2,4,1]输出：[4,2,4,3]解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。初始状态 A = [3, 2, 4, 1]第一次翻转后 (k=4): A = [1, 4, 2, 3]第二次翻转后 (k=2): A = [4, 1, 2, 3]第三次翻转后 (k=4): A = [3, 2, 1, 4]第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。示例 2:12345输入：[1,2,3]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如[3，3]，也将被接受。 思路煎饼反转就是以数组中心索引位置为轴，两两数字交换。例如最后一个数字与第一个数字交换，倒数第二个与第二个交换。要想实现排序效果，就是依次把最大的放入最后面，这需要以下几步：找到未排序的数组里面最大的数，并记录索引。以该索引为数组边界，进行一次煎饼反转，将该数转到第一个数字。以未排序的子数组边界索引为边界，进行一次煎饼反转，将该数转到最后面。循环进行。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;Integer&gt; pancakeSort(int[] A) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int size = A.length-1; while(size&gt;0)&#123; if(findIndex(A, size) &lt; size)&#123; // 两次反转将未排序子数组中最大的数字移到后面 // result记录反转的索引位置 result.add(findIndex(A, size)+1); reverse(A, 0, findIndex(A, size)); result.add(size+1); reverse(A, 0, size); &#125; size--; &#125; return result; &#125; // 煎饼反转算法 private static void reverse(int[] A, int i, int j)&#123; for(;i&lt;j;i++,j--)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; // 寻找当前数组的最大值所在的索引位置 private static int findIndex(int[] A, int size)&#123; int max=0, k=0; for(int i=0; i&lt;=size; i++)&#123; if(A[i]&gt;max)&#123; max = A[i]; k = i; &#125; &#125; return k; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pancake-sorting著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"JVM如何回收对象","slug":"JVM如何回收对象","date":"2019-08-14","updated":"2019-10-02","comments":true,"path":"JVM如何回收对象/","link":"","permalink":"http://sunyunzeng.com/JVM如何回收对象/","excerpt":"","text":"如何判断对象是否要回收？ 对象回收的依据——是否被有效引用？引用的可分为强引用(Strong Reference)——指向new 对象的引用、软引用(Soft Reference)——有用但没必要的引用、弱引用(Weak Reference)——没有必要的引用、虚引用(Phantom Reference)——为了在对象被回收时获得系统通知。强引用只要存在就不回收；软引用只有在内存即将不足的情况下才回收；弱引用及虚引用随便回收。 怎么判断对象是否被有效引用？引用计数法。如果对象的引用计数器为0，则表示该对象可以回收。但是存在互相引用无法清理的情况。可达性分析法。通过创建一个成为“GC Root”的对象作为搜索根节点，向下搜索。如果对象到该对象之间没有引用链关联，则该对象可回收。 对象死亡的判决书再对象确定没有引用的情况下，还需要判断其finalize方法没有被覆盖或者已经被执行一次（该方法只能执行一次），满足这两个条件，GC才会回收该对象。如果finalize方法被覆盖，则将该对象加入一个 &quot;F-Queue&quot;队列中，由虚拟机创建的、优先级低的Finalizer的线程去处理。如果对象在finalize方法中建立了与&quot;GC Root&quot;对象的连接链，则对象成功逃离了死亡的命运。否则，对象就被判决了死刑。 垃圾回收算法 标记-清理算法。根据对象是否被有效引用进行标记，然后清理无用对象。优点：简洁有效。缺点：存在空间碎片，不利于下次对象内存的分配及内存空间的合理利用。 复制算法。将内存划分为两大块，一块用于存储对象，另一块用于复制准备。第一步也是标记，第二步是把不需清理的对象复制到另一块内存区域，保持这些对象在内存空间上是连续排列。优点：无碎片空间，且新对象内存空间分配便捷。缺点：二分法对空间利用率不高，且复制过程中效率不高。由于新生代中无用对象多，需要复制移动的对象少，所以该法很适合。改进版：内存划分为一块较大的Eden内存空间及两块较小的Survivor空间（默认8:1:1），一块Eden及Survivor用于分配对象，另一块用于复制准备。如果要复制的对象的内存超出了准备的Survivor，则需要其他内存（老生代）进行分配担保。 标记-整理。第一步标记。第二步将存活的对象都往前移动，在内存空间中紧密排列，然后对于边界外的内存空间进行清理。 分代收集算法。将内存空间分为新生代与老生代。新生代中每次垃圾回收时都会有大量对象死亡，需要复制的对象很少，因此采用复制算法。老生代对象的利用率高，存活时间长，因此采用标记-清理或者标记整理算法。 垃圾回收器 新生代垃圾收集器1. Serial收集器特点： Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。使用算法：复制算法2. ParNew收集器特点： ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。使用算法：复制算法3. Parallel Scavenge收集器特点： Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。使用算法：复制算法 老年代垃圾收集器1. Serial Old收集器特点： Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。使用算法：标记-整理2. Parallel Old收集器特点： Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。使用算法：标记-整理3. CMS收集器特点： CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用&quot;标记-清除&quot;算法的并发收集器。CMS 收集器的工作过程可以分为 4 个阶段：初始标记（CMS initial mark）阶段、并发标记（CMS concurrent mark）阶段、重新标记（CMS remark）阶段、并发清除(（CMS concurrent sweep）阶段。**使用算法：**复制+标记清除3. G1 垃圾收集器特点： 主要步骤：初始标记，并发标记，重新标记，复制清除。**使用算法：**复制 + 标记整理 参考:深入理解java虚拟机JVM面试突破","categories":[{"name":"JVM","slug":"JVM","permalink":"http://sunyunzeng.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://sunyunzeng.com/tags/JVM/"}]},{"title":"Leetcode 638.大礼包","slug":"Leetcode-638-大礼包","date":"2019-08-13","updated":"2019-08-30","comments":true,"path":"Leetcode-638-大礼包/","link":"","permalink":"http://sunyunzeng.com/Leetcode-638-大礼包/","excerpt":"","text":"题目在LeetCode商店中， 有许多在售的物品。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。任意大礼包可无限次购买。示例1:1234567输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释: 有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。示例2:1234567输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]输出: 11解释: A，B，C的价格分别为¥2，¥3，¥4.你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。 思路 + 代码DFS + 剪枝即使暴力法，然后提出一些不满足条件的情况，即购买数量超出 (大礼包数量不对)1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; return subShoppingOffers(price, special, needs, 0); &#125; private int subShoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, int index)&#123; // index标记，顺序开始计算，防止(1,2) 与 (2,1) 的重复计算 int minCost = originalCost(price, needs); for(int i=index; i&lt;special.size(); i++)&#123; // 统计当前还需要购买多少物品 List&lt;Integer&gt; currentNeeds = new ArrayList&lt;&gt;(); // 当前礼包信息 List&lt;Integer&gt; offer = special.get(i); for(int j=0; j&lt;needs.size(); j++)&#123; // 剪枝 if(offer.get(j) &gt; needs.get(j))&#123; currentNeeds = null; break; &#125; currentNeeds.add(needs.get(j)-offer.get(j)); &#125; // 如果礼包中物品的数量没有超,则加上该礼包金额，并且继续深度优先(DFS)遍历 if(currentNeeds!=null)&#123; minCost = Math.min(minCost, offer.get(offer.size()-1)+subShoppingOffers(price, special, currentNeeds, i)); &#125; &#125; return minCost; &#125; private int originalCost(List&lt;Integer&gt; price, List&lt;Integer&gt; needs)&#123; int sum = 0; for(int i=0; i&lt;needs.size(); i++)&#123; sum += price.get(i) * needs.get(i); &#125; return sum; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shopping-offers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Java 运行时数据区域","slug":"Java-运行时数据区域","date":"2019-08-08","updated":"2019-10-02","comments":true,"path":"Java-运行时数据区域/","link":"","permalink":"http://sunyunzeng.com/Java-运行时数据区域/","excerpt":"","text":"定义Java虚拟机把所管理的内存划分为不同的区域，总称为运行时数据区域。数据区域用途各不相同，有的随虚拟机启动而存在，有的随线程的生命周期存在。根据《Java虚拟机规范（Java SE7版)》规定，Java虚拟机将数据区域划分为：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）。 程序计数器• 线程私有，每个线程都有一个用来记录字节码执行位置。• 一块内存区域，java虚拟机规范中唯一没有规定OutOfMemoryError的区域。• java字节码解释器通过改变计数器的值实现分支、跳转、循环、异常处理、线程恢复等操作。• 如果执行的是Java方法，则存储的是虚拟机字节码指令地址；如果是Native方法，则存储为空。 Java虚拟机栈• 所谓的栈内存指的就是Java虚拟机栈。• Java方法的运行，都会生成一个栈帧，用来存储执行Java方法的局部变量、操作数栈、动态链接、方法出口等信息。• 一个Java方法的执行到结束，对应为一个栈帧的出栈与入栈。• 虚拟机栈可以为固定内存，也可动态扩展。如果线程请求栈深度大于虚拟机深度，则会报StackOverflowError;如果动态扩展时无法申请到足够内存，则会报OutOfMemoryError。 本地方法栈• 与Java虚拟机栈类似，但是是为Native方法的执行提供服务。• 也会抛出StackOverflowError与OutOfMemoryError。 Java堆• 各线程共享区域。• 是java虚拟机管理的最大的一块内存区域。• 是Java对象实例存储的空间。• 是垃圾收集器主要工作区域。• 存储空间逻辑上连续，物理上可以不连续。• 可设置为固定大小或动态扩展，如果动态扩展时无法申请到足够内存，则会报OutOfMemoryError。 方法区• 各线程共享区域。• 用于存储已被Java虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等。• 方法区无法内存分配需求时，会抛出OutOfMemoryError。 运行时常量池• 是方法区的一部分。• Class类文件中有一项是常量池，用来存放编译期生成的字面量和符号引用。• 类加载后常量池存储在方法区内的运行时常量池。• 具有动态性，非编译期间的新的常量也可放入运行时常量池中。 直接内存• 不是Java虚拟机规范定义的内存区域。• JDK1.4后新加入的NI/O（New Input/Output）类，引入了仅与通道（Channel）与缓存。(Buffer)的I/O方式，可以直接通过Native函数库分配堆外内存。• 内存收到本机总内存及处理器寻址空间的限制。直接内存无法内存分配需求时，会抛出OutOfMemoryError。 参考:深入理解java虚拟机","categories":[{"name":"JVM","slug":"JVM","permalink":"http://sunyunzeng.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://sunyunzeng.com/tags/JVM/"}]},{"title":"Leetcode 1046.最后一块石头的重量","slug":"Leetcode-1046-最后一块石头的重量","date":"2019-07-30","updated":"2019-08-30","comments":true,"path":"Leetcode-1046-最后一块石头的重量/","link":"","permalink":"http://sunyunzeng.com/Leetcode-1046-最后一块石头的重量/","excerpt":"","text":"题目有一堆石头，每块石头的重量都是正整数。每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。提示121 &lt;= stones.length &lt;= 301 &lt;= stones[i] &lt;= 1000 思路（排序 -&gt; 选最大及第二大做差 -&gt; 更新数组 -&gt; 排序）（循环 length-1 次） -&gt;最大的为结果 代码1234567891011class Solution &#123; public int lastStoneWeight(int[] stones) &#123; int len = stones.length; for(int i=len-1; i&gt;=1; i--)&#123; Arrays.sort(stones); stones[len-1] = stones[len-1]-stones[len-2]; stones[len-2] = 0; &#125; return stones[len-1]; &#125;&#125;或者采用优先堆栈的方法维护数据的先后顺序123456789101112131415161718192021class Solution &#123; public int lastStoneWeight(int[] stones) &#123; int len = stones.length; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; return (b - a); &#125; &#125;); for(int i=0; i&lt;len; i++)&#123; queue.add(stones[i]); &#125; while(queue.size()&gt;1)&#123; int a = queue.poll(); int b = queue.poll(); if(a-b != 0)&#123; queue.add(a-b); &#125; &#125; return queue.isEmpty()?0:queue.poll(); &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/last-stone-weight著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Greedy Algorithm","slug":"Greedy-Algorithm","permalink":"http://sunyunzeng.com/tags/Greedy-Algorithm/"}]},{"title":"Leetcode 647.回文子串","slug":"Leetcode-647-回文子串","date":"2019-07-28","updated":"2019-08-30","comments":true,"path":"Leetcode-647-回文子串/","link":"","permalink":"http://sunyunzeng.com/Leetcode-647-回文子串/","excerpt":"","text":"题目给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。示例1：123输入: \"abc\"输出: 3解释: 三个回文子串: \"a\", \"b\", \"c\".示例2：123输入: \"aaa\"输出: 6说明: 6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".注意：1输入的字符串长度不会超过1000。 思路 + 代码回文子串的内部一定是回文子串，因此关键在于重复利用回文子串已经统计过的数值。可采用双指针由回文子串向两端同时检测的方法。分为偶数回文子串与奇数回文子串。123456789101112131415161718class Solution &#123; private int sum = 0; public int countSubstrings(String s) &#123; int len = s.length(); for(int i=0; i&lt;len; i++)&#123; count(s, i, i); // 统计奇数的回文子串数量 count(s, i, i+1); //统计偶数的回文子串数量 &#125; return sum; &#125; private void count(String s, int start, int end)&#123; while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s.charAt(start)==s.charAt(end))&#123; sum++; start--; end++; &#125; &#125;&#125; 思路 + 代码采用动态规划，用一个二维数组 dp[i][j] 统计字符串从 i ~ j 是否是回文子串。1234567891011121314151617181920212223242526272829303132class Solution &#123; public int countSubstrings(String s) &#123; int sum = 0; int length = s.length(); // 用dp数组存储回文子串结果，第一维为长度（有哨兵），第二维为起始位置 boolean[][] dp = new boolean[length+1][length]; for(int i=1; i&lt;length+1; ++i)&#123; for(int j=0; j&lt;length; ++j)&#123; // 所有长度为1的子串都为回文子串 if(i==1)&#123; dp[j][j] = true; sum++; &#125; // 所有长度为2的子串情况 else if(i==2)&#123; if(j+1&lt;length &amp;&amp; s.charAt(j)==s.charAt(j+1))&#123; dp[j][j+1] = true; sum++; &#125; &#125; // 长度大于3的情况 else&#123; if(j+i-1&lt;length &amp;&amp; dp[j+1][j+i-2] &amp;&amp; s.charAt(j)==s.charAt(j+i-1))&#123; dp[j][j+i-1] = true; sum++; &#125; &#125; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 983.最低票价","slug":"Leetcode-983-最低票价","date":"2019-07-18","updated":"2019-07-27","comments":true,"path":"Leetcode-983-最低票价/","link":"","permalink":"http://sunyunzeng.com/Leetcode-983-最低票价/","excerpt":"","text":"题目在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。示例1：12345678输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。示例2：1234567输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。提示：123451 &lt;= days.length &lt;= 3651 &lt;= days[i] &lt;= 365days 按顺序严格递增costs.length == 31 &lt;= costs[i] &lt;= 1000 思路动态规划。ans[i] = min(ans[i-1]+costs[0] + ans[i-7]+costs[1] + ans[i-30]+costs[2]); 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int mincostTickets(int[] days, int[] costs) &#123; int len = days.length; int[] results = new int[len]; for(int i=0; i&lt;len; ++i)&#123; results[i] = Integer.MAX_VALUE; &#125; // 防止一周或者一月的火车票更便宜的情况出现 int minCost = Math.min(Math.min(costs[0],costs[1]),costs[2]); results[0] = costs[0]; // 动态规划寻找最优值，分三种情况，计划时间一周内，一周到一个月，一个月以上 for(int i=1; i&lt;len; ++i)&#123; if(days[i]&lt;=7)&#123; results[i] = Math.min(minCost+results[i-1],costs[1]); &#125;else if(7&lt;days[i]&amp;&amp;days[i]&lt;=30)&#123; // 遍历具今天最近的一周外的时间 int j=i; while(days[j]&gt;days[i]-7)&#123; j--; if(j&lt;0) break; &#125; // 这种情况是如果最开始的到当前时间都在一周内，例如[5,7,8,9] int tmp0 = j&lt;0?0:results[j]; results[i] = Math.min(Math.min(results[i-1]+minCost,costs[1]+tmp0),costs[2]); &#125;else if(30&lt;days[i])&#123; // 同上 int k=i; while(days[k]&gt;days[i]-30)&#123; k--; if(k&lt;0) break; &#125; int m=i; while(days[m]&gt;days[i]-7 &amp;&amp; m&gt;0)&#123; m--; if(m&lt;0) break; &#125; int tmp1 = k&lt;0?0:results[k]; int tmp2 = m&lt;0?0:results[m]; results[i] = Math.min(Math.min(results[i-1]+minCost,costs[2]+tmp1),costs[1]+tmp2); &#125; &#125; return results[len-1]; &#125;&#125;大神的做法，扩充dp数组，实现算法的一致，即简化了代码，又提高了代码的运行效率。1234567891011121314151617class Solution &#123; public int mincostTickets(int[] days, int[] costs) &#123; boolean[] rec = new boolean[365+1]; for(int day:days) rec[day] = true; int lastDay = days[days.length-1]+30; // 扩充一个月dp数组使得判定条件一致 int[] dp = new int[366+30]; for(int i=31; i&lt;=lastDay; ++i)&#123; if(rec[i-30]) dp[i] = Math.min(Math.min(dp[i-1]+costs[0],dp[i-7]+costs[1]),dp[i-30]+costs[2]); else dp[i]=dp[i-1]; &#125; return dp[lastDay]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 11.盛最多水的容器","slug":"Leetcode-11-盛最多水的容器","date":"2019-07-17","updated":"2019-07-27","comments":true,"path":"Leetcode-11-盛最多水的容器/","link":"","permalink":"http://sunyunzeng.com/Leetcode-11-盛最多水的容器/","excerpt":"","text":"题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明: 你不能倾斜容器，且 n 的值至少为 2。 思路 + 代码方法1：暴力破解法即遍历所有情况，找到最优解。123456789101112class Solution &#123; public int maxArea(int[] height) &#123; int len = height.length; int res = 0; for(int i=1; i&lt;len; i++)&#123; for(int j=0; j&lt;i; j++)&#123; res = Math.max((i-j)*Math.min(height[i], height[j]),res); &#125; &#125; return res; &#125;&#125;时间复杂度O(n^2), 空间复杂度 1方法2：双指针法两个指针，一个指向数组首，一个指向数组尾。指向数字小的往中间移动，并计算一次结果。取最优即为最终结果。原因请戳1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int last = height.length-1; int first = 0; int res = 0; while(first &lt; last)&#123; int tmp = (last-first)*Math.min(height[first], height[last]); if(height[first] &lt;= height[last])&#123; first++; &#125;else&#123; last--; &#125; res = Math.max(res,tmp); &#125; return res; &#125;&#125;时间复杂度O(n), 空间复杂度 1来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 347.前K个高频元素","slug":"Leetcode-347-前K个高频元素","date":"2019-07-15","updated":"2019-07-27","comments":true,"path":"Leetcode-347-前K个高频元素/","link":"","permalink":"http://sunyunzeng.com/Leetcode-347-前K个高频元素/","excerpt":"","text":"题目给定一个非空的整数数组，返回其中出现频率前 k 高的元素。示例1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例2:12输入: nums = [1], k = 1输出: [1]说明:12你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 思路首先用一个HashMap统计不同数字出现的次数。然后用一个最小堆维护k大小的结果。这里采用java的优先队列 PriorityQueue 去维护最小堆。这里需要注意的一点是比较器的设计，部分源代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public boolean add(E e) &#123; return offer(e); &#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125;@SuppressWarnings(\"unchecked\")private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key;&#125;@SuppressWarnings(\"unchecked\")private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; // 注意：这里的比较原则是当前的与栈顶元素比较，大的就进行替换，所以维护的是最小堆栈。 if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125;PriorityQueue方法参考博文 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; return map.get(a) - map.get(b); &#125; &#125;); int len = nums.length; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); // 统计各数字出现次数 for(int i=0; i&lt;len; ++i)&#123; if(map.containsKey(nums[i]))&#123; map.put(nums[i], map.get(nums[i])+1); &#125;else&#123; map.put(nums[i], 1); &#125; &#125; // 使用最小堆更新结果 for(int i:map.keySet())&#123; if(pq.size()&lt;k)&#123; pq.add(i); &#125;else&#123; if(map.get(i)&gt;map.get(pq.peek()))&#123; pq.remove(); pq.add(i); &#125; &#125; &#125; while(!pq.isEmpty())&#123; result.add(pr.poll()); &#125; return result; &#125;&#125;l","categories":[],"tags":[]},{"title":"Leetcode 739.每日温度","slug":"Leetcode-739-每日温度","date":"2019-07-12","updated":"2019-10-06","comments":true,"path":"Leetcode-739-每日温度/","link":"","permalink":"http://sunyunzeng.com/Leetcode-739-每日温度/","excerpt":"","text":"题目根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 思路+代码最简单的思路，两次循环。1234567891011121314151617class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] results = new int[len]; for(int i=0; i&lt;len-1; i++)&#123; int tmp = 0; for(int j=i+1; j&lt;len; j++)&#123; if(T[j]&gt;T[i])&#123; results[i]=tmp+1; break; &#125; tmp++; &#125; &#125; return results; &#125;&#125;利用栈栈的特性是先进后出，所以需要从后往前遍历。维护一个递减数据的索引（天）序列。如果当前数据（温度）大于等于栈顶索引（天）对应的数据（温度），则更新栈内数据，保持递减特性。否则计算当前数据索引（天）与栈顶所索引（天）为结果值。123456789101112131415161718class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] results = new int[len]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=len-1; i&gt;=0; --i)&#123; while(!stack.isEmpty() &amp;&amp; T[i] &gt;= T[stack.peek()])&#123; stack.pop(); &#125; if(!stack.isEmpty()) // 更新结果值 results[i] = stack.peek() - i; // 维护递减序列 stack.push(i); &#125; return results; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/daily-temperatures著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 287.寻找重复数","slug":"Leetcode-287-寻找重复数","date":"2019-07-06","updated":"2019-07-10","comments":true,"path":"Leetcode-287-寻找重复数/","link":"","permalink":"http://sunyunzeng.com/Leetcode-287-寻找重复数/","excerpt":"","text":"题目给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。示例1：12输入: [1,3,4,2,2]输出: 2示例2：12输入: [3,1,3,4,2]输出: 3说明：1234不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 思路 + 代码易想到方法不符合题目要求，因为需要额外的空间。用链表或者HashMap存储数值，遇到相同的已存储的数就返回。空间复杂度最坏O(n)，时间复杂度最坏O(n)。或者先排序，遇到相同的数返回。时间复杂度视排序方法而定，最好O(log(n))。巧妙算法1巧用快慢指针。数组的索引与存储的数值之间形成了特殊链表。如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。环的入口即为结果。答案的求解变成环入口的求解。思路123456789101112131415161718class Solution &#123; public int findDuplicate(int[] nums) &#123; // 快慢指针 int fast = nums[0]; int low = nums[0]; do&#123; low = nums[low]; fast = nums[nums[fast]]; &#125;while(fast != low); int step = nums[0]; // 寻找环链表的入口，即为结果 while(step != low)&#123; step = nums[step]; low = nums[low]; &#125; return low; &#125;&#125;巧妙算法2二分法。统计小于中间数 mid 的数值数量，如果大于，则在0~mid之间寻找。反之，则在mid~high中寻找。最终找到重复的数值。123456789101112131415161718192021class Solution &#123; public int findDuplicate(int[] nums) &#123; // 二分法 int len = nums.length; int low = 0; int hight = len-1; while(low&lt;hight)&#123; int count = 0; int mid = low+(hight-low)/2; for(int i=0; i&lt;len; i++)&#123; if(nums[i]&lt;=mid) count++; &#125; if(count&lt;=mid) low = mid+1; else hight = mid; &#125; return low; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 746.使用最小花费爬楼梯","slug":"Leetcode-746-使用最小花费爬楼梯","date":"2019-07-05","updated":"2019-07-10","comments":true,"path":"Leetcode-746-使用最小花费爬楼梯/","link":"","permalink":"http://sunyunzeng.com/Leetcode-746-使用最小花费爬楼梯/","excerpt":"","text":"题目数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。示例1：123输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例2：123输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。注意：121. cost 的长度将会在 [2, 1000]。2. 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 思路典型的动态规划问题，上楼梯问题。注意的是，最后的结果是最后一阶楼梯与倒数第二个楼梯中取最小值。 代码123456789101112131415161718class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len = cost.length; if(len==2) return(Math.min(cost[0], cost[1])); int[] result = new int[len]; result[0]=cost[0]; result[1]=cost[1]; for(int i=2; i&lt;len; i++)&#123; result[i] = Math.min(result[i-1], result[i-2])+cost[i]; &#125; // noted return Math.min(result[len-2], result[len-1]); &#125;&#125;`来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 102.二叉树的层次遍历","slug":"Leetcode-102-二叉树的层次遍历","date":"2019-07-04","updated":"2019-07-10","comments":true,"path":"Leetcode-102-二叉树的层次遍历/","link":"","permalink":"http://sunyunzeng.com/Leetcode-102-二叉树的层次遍历/","excerpt":"","text":"题目给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \\9 20 / \\ 15 7返回其层次遍历结果：12345[ [3], [9,20], [15,7]] 思路 + 代码二叉树相关算法题两种解题思路：递归和迭代。递归方法用一个辅助函数，更新结果。记录遍历的层数，并按照从左到右的顺序依次在相应层数List中记录数值。返回结果。代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public void helper(TreeNode root, int level)&#123; // 更新记录List if(results.size()==level) results.add(new ArrayList&lt;Integer&gt;()); // 从左到右记录数据 results.get(level).add(root.val); if(root.left!=null) helper(root.left, level+1); if(root.right!=null) helper(root.right, level+1); &#125; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null) return results; helper(root, 0); return results; &#125;&#125;迭代方法:用队列辅助，先进的节点先出。层层进队列，然后层层出队列，存入结果results中。代码:12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(root==null) return results; queue.add(root); int level = 0; while(!queue.isEmpty())&#123; results.add(new ArrayList&lt;Integer&gt;()); int levelLength = queue.size(); // 将level层元素依次存入List，level+1层节点依次入队列 for(int i=0; i&lt;levelLength; ++i)&#123; // 改成节点出队列 root = queue.remove(); // 按层存入 results.get(level).add(root.val); // 下一层节点入队列 if(root.left!=null) queue.add(root.left); if(root.right!=null) queue.add(root.right); &#125; level++; &#125; return results; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"Leetcode 94.二叉树的中序遍历","slug":"Leetcode-94-二叉树的中序遍历","date":"2019-07-03","updated":"2019-10-21","comments":true,"path":"Leetcode-94-二叉树的中序遍历/","link":"","permalink":"http://sunyunzeng.com/Leetcode-94-二叉树的中序遍历/","excerpt":"","text":"题目描述给定一个二叉树，返回它的中序 遍历。示例:12345678输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2]**进阶:**递归算法很简单，你可以通过迭代算法完成吗？ 思路 + 代码 递归方法递归截止条件：root==null递归执行条件：list.add(inorderTraversal(root.left))list.add(root.val)list.add(inorderTraversal(root.right))代码12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List &lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List &lt;Integer&gt; res = new ArrayList &lt;&gt; (); helper(root, res); return res; &#125; public void helper(TreeNode root, List &lt;Integer&gt; res) &#123; if (root != null) &#123; if (root.left != null) &#123; helper(root.left, res); &#125; res.add(root.val); if (root.right != null) &#123; helper(root.right, res); &#125; &#125; &#125;&#125; 迭代方法用一个栈存储遍历过得父子节点，循环遍历。代码12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); // 当树没有遍历完全 while(root!=null || !stack.isEmpty())&#123; // 找到当前树的最左侧叶子节点（父节点） while(root!=null)&#123; stack.push(root); root=root.left; &#125; // 中序遍历 root = stack.pop(); list.add(root.val); root = root.right; &#125; return list; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"Leetcode 215.数组中第K个最大元素","slug":"Leetcode-215-数组中第K个最大元素","date":"2019-07-01","updated":"2019-08-30","comments":true,"path":"Leetcode-215-数组中第K个最大元素/","link":"","permalink":"http://sunyunzeng.com/Leetcode-215-数组中第K个最大元素/","excerpt":"","text":"题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:12输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2::12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 思路 + 代码简单办法，最容易想到的：用一个长度为 k 存储最大到第k大的数，然后返回数组最后一个元素，即为结果。1234567891011121314151617181920212223class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; // 数组初始化 int[] results = new int[k]; for(int i=0; i&lt;k; i++)&#123; results[i] = Integer.MIN_VALUE; &#125; // 特殊情况处理 int len = nums.length; if(len&lt;2) return nums[0]; // 维护结果数组的值 for(int i=0; i&lt;len; i++)&#123; for(int j=0; j&lt;k; j++)&#123; if(nums[i]&gt;results[j])&#123; System.arraycopy(results,j,results,j+1,k-1-j); results[j] = nums[i]; break; &#125; &#125; &#125; return results[k-1]; &#125;&#125;执行用时 :74 ms, 在所有 Java 提交中击败了18.90%的用户内存消耗 :40.5 MB, 在所有 Java 提交中击败了35.28%的用户答案里的方法：桶排序，非常好理解，先遍历一遍数组找出最大最小值。创建一个桶，长度为max-min+1，桶的引对应于与Min的差值，桶中装的元素为该值出现次数。1234567891011121314151617181920class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int max=Integer.MIN_VALUE; int min=Integer.MAX_VALUE; for(int num:nums)&#123; max=Math.max(max,num); min=Math.min(min,num); &#125; int[] bucket=new int [max-min+1]; for(int num:nums)&#123; bucket[num-min]++; &#125; int count=0; for(int i=bucket.length-1;i&gt;=0;i--)&#123; count+=bucket[i]; if(count&gt;=k) return min+i; &#125; return -1; &#125;&#125;执行用时 :2 ms, 在所有 Java 提交中击败了99.61%的用户内存消耗 :37.8 MB, 在所有 Java 提交中击败了94.49%的用户","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 105.从前序与中序遍历序列构造二叉树","slug":"Leetcode-105-从前序与中序遍历序列构造二叉树","date":"2019-07-01","updated":"2019-10-02","comments":true,"path":"Leetcode-105-从前序与中序遍历序列构造二叉树/","link":"","permalink":"http://sunyunzeng.com/Leetcode-105-从前序与中序遍历序列构造二叉树/","excerpt":"","text":"题目根据一棵树的前序遍历与中序遍历构造出二叉树。注意:你可以假设树中没有重复的元素。例如，给出12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \\9 20 / \\ 15 7 思路先序遍历：先根节点 后左子树 最后右子树中序遍历：先左子树 再根节点 最后右子树所以先序遍历的第一个数值为根节点，在中序遍历中找到根节点位置，前面为左子树的中序遍历，后面为右子树的中序遍历。Java代码如下:123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder==null || inorder==null) return null; if(preorder.length==0 || inorder.length==0)&#123; return null; &#125; if(preorder.length!=inorder.length)&#123; return null; &#125; TreeNode root = new TreeNode(preorder[0]); int len = preorder.length; for(int i=0; i&lt;len; i++)&#123; if(inorder[i]==preorder[0])&#123; root.left = buildTree(Arrays.copyOfRange(preorder,1,i+1), Arrays.copyOfRange(inorder,0,i)); root.right = buildTree(Arrays.copyOfRange(preorder,i+1,len),Arrays.copyOfRange(inorder,i+1,len)); &#125; &#125; return root; &#125;&#125;Python代码如下：1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): \"\"\" :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode \"\"\" if not preorder: return None x = preorder.pop(0) node = TreeNode(x) idx = inorder.index(x) node.left = self.buildTree(preorder[:idx], inorder[:idx]) node.right = self.buildTree(preorder[idx:], inorder[idx+1:]) return node","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"Leetcode 101.对称二叉树","slug":"Leecode-101-对称二叉树","date":"2019-06-25","updated":"2019-07-10","comments":true,"path":"Leecode-101-对称二叉树/","link":"","permalink":"http://sunyunzeng.com/Leecode-101-对称二叉树/","excerpt":"","text":"题目给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \\2 2 \\ \\ 3 3说明:如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 思路二叉树的一个典型套路就是递归求解。左右树分别对待。注意递归截止条件以及是否对称的判断条件。 代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; return tryTree(root.left, root.right); &#125; public boolean tryTree(TreeNode left, TreeNode right)&#123; // 递归截止条件 if(right==null&amp;&amp;left==null) return true; if(left==null||right==null) return false; // 对称判断条件 if(left.val==right.val) return tryTree(left.left, right.right)&amp;&amp;tryTree(left.right, right.left); return false; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"Leetcode 48.旋转图像","slug":"Leecode-48-旋转图像","date":"2019-06-24","updated":"2019-07-01","comments":true,"path":"Leecode-48-旋转图像/","link":"","permalink":"http://sunyunzeng.com/Leecode-48-旋转图像/","excerpt":"","text":"题目给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。示例1：12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]]示例2：123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 思路如果可以拷贝矩阵，则可以每一行与每一列同时旋转。但是要求在原矩阵中操作，所以需要每一个元素进行位置旋转变换。一个4*4的矩阵如下图所示：顺时针旋转即相同颜色的元素进行依次替换。对于四阶矩阵，先从最外圈i=0开始，到里圈i=1结束。n+1阶矩阵从最外圈i=0开始，i=n/2里圈结束。每j圈依次从j行第i个元素开始，n-i个元素结束。四个元素互换条件：tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; 代码123456789101112131415161718class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length-1; int tmp; // 循环几圈 for(int i=0; i&lt;=n/2;i++)&#123; // 每一圈要交换几轮 for(int j=i;j&lt;n-i;j++)&#123; // 四个元素依次交换 tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; &#125; &#125; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 155.最小栈","slug":"Leecode-155-最小栈","date":"2019-06-22","updated":"2019-07-01","comments":true,"path":"Leecode-155-最小栈/","link":"","permalink":"http://sunyunzeng.com/Leecode-155-最小栈/","excerpt":"","text":"题目设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 思路1可以用两个栈，一个栈用来维护当前栈内最小的元素，一个栈用来维度当前栈内的元素。属于投机取巧的方法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.isEmpty() || x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; public void pop() &#123; // 注意，peek()方法返回的是Integer对象，而java在比较Integer时数据范围在-128~127用 == 比较是相等的，但是 // 超过这个范围就是不相等的。这是因为常量池范围内地Integer对象都是同一个，而 == 是比较对象是否为同一个对象 // 如果比较数值是否相等，应该采用Integer重写的equals()方法!!! if(stack.peek().equals(minStack.peek()))&#123; minStack.pop(); &#125; stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 思路2自己用数组实现元素栈与存储最小元素的栈。要点，数组的自动扩容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MinStack &#123; private int[] minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = new int[10]; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) resize(); data[index] = x; if(index==0 || x &lt;minValue[index-1])&#123; minValue[index]=x; &#125;else&#123; minValue[index] = minValue[index-1]; &#125; &#125; public void pop() &#123; index--; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue[index]; &#125; public void resize()&#123; int[] newdata = new int[data.length*2]; int[] newMinValue = new int[data.length*2]; System.arraycopy(data,0,newdata,0,data.length); System.arraycopy(minValue,0,newMinValue,0,minValue.length); data = newdata; minValue = newMinValue; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */或者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MinStack &#123; private int minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = Integer.MAX_VALUE; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) data = Arrays.copyOf(data, data.length*2); data[index] = x; if(x &lt; minValue)&#123; minValue = x; &#125; &#125; public void pop() &#123; index--; if(data[index+1]==minValue)&#123; minValue = Integer.MAX_VALUE; for(int i=0; i&lt;=index; i++)&#123; if(data[i]&lt;minValue)&#123; minValue = data[i]; &#125; &#125; &#125; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue; &#125; &#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 448.找到所有数组中消失的数字","slug":"Leecode-448-找到所有数组中消失的数字","date":"2019-06-20","updated":"2019-07-01","comments":true,"path":"Leecode-448-找到所有数组中消失的数字/","link":"","permalink":"http://sunyunzeng.com/Leecode-448-找到所有数组中消失的数字/","excerpt":"","text":"题目给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。示例：12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 思路将出现数字位置的数置为负数。关键点：置负数时一定取绝对值后取负数，否则会出现负负得正的情况。例如：1[2,1,2,4]1[-2,-1,2,-1] 代码123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]); &#125; for(int i=0;i&lt;len;i++)&#123; if(nums[i]&gt;0)&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 234.回文链表","slug":"Leecode-234-回文链表","date":"2019-06-20","updated":"2019-07-01","comments":true,"path":"Leecode-234-回文链表/","link":"","permalink":"http://sunyunzeng.com/Leecode-234-回文链表/","excerpt":"","text":"题目请判断一个链表是否为回文链表。示例1：12输入: 1-&gt;2输出: false示例2：12输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 思路用 栈+快慢指针 或者 快慢指针+反转链表快慢指针是用来寻找中间节点。栈是用来反转链表。 代码栈 + 快慢指针1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; // 栈用来反转链表 Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); ListNode fast = head; ListNode low = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; stack.push(low); low = low.next; // 奇数链表中间位置需要往后移动一位 if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; // 循环遍历前后链表是否相等 while(!stack.empty())&#123; if(stack.pop().val!=low.val) return false; low = low.next; &#125; return true; &#125;&#125;快慢指针 + 反转链表12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; ListNode fast = head; ListNode low = head; // 快慢指针找到中间点 while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; low = low.next; if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; ListNode compNode = reverseLinkedList(low); // 链表前后判断 while(compNode!=null)&#123; if(compNode.val!=head.val) return false; compNode = compNode.next; head = head.next; &#125; return true; &#125; // 反转链表 public ListNode reverseLinkedList(ListNode head)&#123; ListNode preNode = null; ListNode curNode = head; while(curNode!=null)&#123; ListNode temp = curNode.next; curNode.next = preNode; preNode = curNode; curNode = temp; &#125; return preNode; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 70.爬楼梯","slug":"Leecode-70-爬楼梯","date":"2019-06-19","updated":"2019-07-01","comments":true,"path":"Leecode-70-爬楼梯/","link":"","permalink":"http://sunyunzeng.com/Leecode-70-爬楼梯/","excerpt":"","text":"题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。示例1:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶示例2:123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 思路递归或者动态规划。第n阶楼梯的走法 = 第n-1阶楼梯走法 + 第n阶楼梯走法。边界条件，n&lt;=3。 代码1234567891011121314// 动态规划class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; int[] dp = new int[n]; for(int i=0;i&lt;3;i++)&#123; dp[i] = i+1; &#125; for(int i=3; i&lt;n; i++)&#123; dp[i]=dp[i-2]+dp[i-1]; &#125; return dp[n-1]; &#125;&#125;1234567// 递归class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; return climbStairs(n-2) + climbStairs(n-1); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Leetcode 198.打家劫舍","slug":"Leecode-198-打家劫舍","date":"2019-06-17","updated":"2019-07-01","comments":true,"path":"Leecode-198-打家劫舍/","link":"","permalink":"http://sunyunzeng.com/Leecode-198-打家劫舍/","excerpt":"","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例1：1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例2：1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 思路动态规划用一个数组维护截止到当前偷窃的最大值。更新条件：dp[i]=max(nums[i]+dp[i-1], dp[i-1])。 代码123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if(len == 0) return 0; if(len == 1 ) return nums[0]; if(len == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i=2; i&lt;len; i++)&#123; dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); &#125; return dp[len-1]; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Leetcode 53.最大子序和","slug":"Leecode-53-最大子序和","date":"2019-06-17","updated":"2019-10-21","comments":true,"path":"Leecode-53-最大子序和/","link":"","permalink":"http://sunyunzeng.com/Leecode-53-最大子序和/","excerpt":"","text":"题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例：123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路动态规划。用一个数组维护一个包含当前数字的最大子序列，取该数组的最大值即为结果。 代码12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; int len = nums.length; int result = nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; for(int i=1; i&lt;len; i++)&#123; dp[i] = Math.max(dp[i-1]+nums[i], nums[i]); result = Math.max(dp[i], result); &#125; return result; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sunyunzeng.com/tags/剑指Offer/"}]},{"title":"Leetcode 538.二叉搜索树转换为累加树","slug":"Leecode-538-二叉搜索树转换为累加树","date":"2019-06-17","updated":"2019-07-01","comments":true,"path":"Leecode-538-二叉搜索树转换为累加树/","link":"","permalink":"http://sunyunzeng.com/Leecode-538-二叉搜索树转换为累加树/","excerpt":"","text":"题目给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。二叉搜索树：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。 思路因为二叉搜索树左子树、根节点及右子树已经拍好顺序，所以只需遍历右子树计算累加值，然后对根节点与左子树分别累加。可采用递归或遍历方法。首先累加右子树数值，然后依次修改根节点与左子树的数值。 代码1 递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; if(root == null) return null; convertBST(root.right); root.val +=sum; sum = root.val; convertBST(root.left); return root; &#125;&#125; 代码2 遍历123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; rightNodeStack = new Stack&lt;TreeNode&gt;(); TreeNode node = root; while(node!=null || !rightNodeStack.isEmpty())&#123; while(node!=null)&#123; rightNodeStack.add(node); node = node.right; &#125; node = rightNodeStack.pop(); node.val += sum; sum = node.val; node = node.left; &#125; return root; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"算法题-移动零","slug":"算法题-移动零","date":"2019-06-14","updated":"2019-06-26","comments":true,"path":"算法题-移动零/","link":"","permalink":"http://sunyunzeng.com/算法题-移动零/","excerpt":"","text":"题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:1. 必须在原数组上操作，不能拷贝额外的数组。2. 尽量减少操作次数。 思路1采用双循环，当遇到零元素时，与后面序列中第一个非零元素交换。时间复杂度: O(n!)O(n!)O(n!)结果:执行用时 : 16 ms内存消耗 :37.4 MB 代码12345678910111213141516class Solution &#123; public void moveZeroes(int[] nums) &#123; int len = nums.length; for(int i=0;i&lt;len-1;i++)&#123; if(nums[i]==0)&#123; int j =i+1; while(j&lt;len&amp;&amp;nums[j]==0)&#123; j++; &#125; if(j==len) break; nums[i]=nums[j]; nums[j]=0; &#125; &#125; &#125;&#125; 思路2评论中高赞方法是采用双指针的方式。先将非零元素按照顺序紧密移动到前面，再按照零元素数量对数组后面元素补零。 代码2123456789101112131415class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int len = nums.length; for(int j=0; j&lt;len; j++)&#123; if(nums[j]!=0)&#123; nums[i]=nums[j]; i++; &#125; &#125; for(; i&lt;len; i++)&#123; nums[i] = 0; &#125; &#125;&#125;结果执行用时 : 1 ms内存消耗 :39.3 MB题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题-合并两个有序链表","slug":"算法题-合并两个有序链表","date":"2019-06-13","updated":"2019-06-26","comments":true,"path":"算法题-合并两个有序链表/","link":"","permalink":"http://sunyunzeng.com/算法题-合并两个有序链表/","excerpt":"","text":"题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例1：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路1分为两步：第一步： 记录所有的链表的数值并排序。因为链表的长度未知，所以需要用 List 来存储。第二步： 按照排序后的链表数值，建立对应链表。 代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null&amp;&amp;l2==null) return null; if(l1!=null&amp;&amp;l2==null) return l1; if(l1==null&amp;&amp;l2!=null) return l2; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(l1!=null)&#123; list.add(l1.val); l1=l1.next; &#125; while(l2!=null)&#123; list.add(l2.val); l2=l2.next; &#125; Collections.sort(list); int size = list.size(); ListNode result = new ListNode(list.get(0).intValue()); ListNode pev = result; for(int i=1;i&lt;size;i++)&#123; ListNode tmp = new ListNode(list.get(i).intValue()); pev.next = tmp; pev = tmp; &#125; return result; &#125;&#125; 思路2官方题解：采用递归方法。终止条件：l1 = null 或者 l2 = null。判断条件：if(l1.val&lt;l2.val): mergeTwoLists(l1.next, l2)else: mergeTwoLists(l1, l2.next) 代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 思路3官方题解：采用递归。时间复杂度与空间复杂度最优。关键在于设计哨兵节点，记录前一个节点。 代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; preNode.next = l1; l1 = l1.next; &#125;else&#123; preNode.next = l2; l2 = l2.next; &#125; preNode = preNode.next; &#125; preNode.next = l1==null?l2:l1; return preHead.next; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题：计算众数","slug":"算法题-计算众数","date":"2019-06-05","updated":"2019-06-26","comments":true,"path":"算法题-计算众数/","link":"","permalink":"http://sunyunzeng.com/算法题-计算众数/","excerpt":"","text":"题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。示例1：12输入: [3,2,3]输出: 3示例2：12输入: [2,2,1,1,1,2,2]输出: 2 思路 + 代码法1. 我的方法，超笨。用一个Map记录数字出现的次数，然后当次数大于n/2时返回。代码12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; if(map.get(nums[i])!=null)&#123; Integer num = map.get(nums[i]); map.put(nums[i], num+1); &#125;else&#123; map.put(nums[i], 1); &#125; if(map.get(nums[i])&gt;len/2) return nums[i]; &#125; return 0; &#125;&#125;法2. 先排序，后取中位数代码略法3. 用一个变量count计数，从0开始，遇到相同的+1，遇到不同的-1，变为零则重新计数。代码12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int len = nums.length; int num = nums[0]; for(int i=1; i&lt;len; i++)&#123; if(num==nums[i]) count++; else count--; if(count==0) &#123; num = nums[i]; count = 1; &#125; &#125; return num; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题：反转链表","slug":"算法题-反转链表","date":"2019-06-03","updated":"2019-09-01","comments":true,"path":"算法题-反转链表/","link":"","permalink":"http://sunyunzeng.com/算法题-反转链表/","excerpt":"","text":"题目描述反转一个单链表。示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路 方案1采用迭代方法，及循环迭代。用一个变量存储上一节点对象，一个变量存储当前节点对象，一个对象存储下一节点对象。 代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while(curr!=null)&#123; ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125;&#125; 方案2采用递归，先递归找到原链表尾巴作为头节点，再依次反转链表。head.next.next = head;head.next = null; 代码1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"算法题：子集","slug":"算法题-子集","date":"2019-05-31","updated":"2019-10-21","comments":true,"path":"算法题-子集/","link":"","permalink":"http://sunyunzeng.com/算法题-子集/","excerpt":"","text":"求一个数组的所有子集数组给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 思路1从前往后遍历，新子集就是原子集加上新加的数。 代码1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; List&lt;Integer&gt; inList = new ArrayList&lt;&gt;(); list.add(inList); for(int i=0; i&lt;len; i++)&#123; int size = list.size(); for(int j = 0; j&lt;size; j++)&#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list.get(j)); newList.add(nums[i]); list.add(newList); &#125; &#125; return list; &#125;&#125; 思路2当成回溯问题求解。 代码12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 如果有重复数字，则需要 Arrays.sort(nums); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, 0); return res; &#125; private void backtracking(ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; arr, int[] nums, int location)&#123; if(nums==null || nums.length==0)&#123; res.add(arr); return; &#125;else&#123; res.add(new ArrayList&lt;Integer&gt;(arr)); for(int i=location; i&lt;nums.length; i++)&#123; // 如果有重复数字，则只调重复的第一个 if(i&gt;location &amp;&amp; nums[i]==nums[i-1]) continue; arr.add(nums[i]); backtracking(res, arr, nums, i+1); arr.remove(arr.size()-1); &#125; &#125; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"backtrace","slug":"backtrace","permalink":"http://sunyunzeng.com/tags/backtrace/"}]},{"title":"算法题：二叉树相关","slug":"算法题-二叉树相关","date":"2019-05-30","updated":"2019-08-30","comments":true,"path":"算法题-二叉树相关/","link":"","permalink":"http://sunyunzeng.com/算法题-二叉树相关/","excerpt":"","text":"合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:1234567891011121314输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 思路递归算法，每棵树都由子树构成，根节点融合可以通过递归拆分成子树进行。 代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125; 二叉树最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。示例:给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \\9 20 / \\ 15 7返回它的最大深度 3 。 思路同上，树划分成两棵树，递归求解。 代码12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125;题目链接 N叉树的最大深度给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。例如，给定一个 3叉树 :我们应返回其最大深度，3。说明:树的深度不会超过 1000。树的节点总不会超过 5000。 思路+代码类比二叉树最大深度，迭代求解。12345678910111213141516171819202122232425/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public int maxDepth(Node root) &#123; if(root==null) return 0; int depth = 0; for(int i=0; i&lt;root.children.size(); i++)&#123; depth = Math.max(maxDepth(root.children.get(i)),depth); &#125; return depth+1; &#125;&#125; 翻转二叉树翻转一棵二叉树。示例：输入:12345 4 / \\ 2 7 / \\ / \\1 3 6 9输出:12345 4 / \\ 7 2 / \\ / \\9 6 3 1备注:这个问题是受到 Max Howell 的 原问题 启发的 ：谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 思路so easy! 递归完事了。 代码12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; TreeNode obj = root.left; root.left = root.right; root.right = obj; invertTree(root.right); invertTree(root.left); return root; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Binary Tree","slug":"Binary-Tree","permalink":"http://sunyunzeng.com/tags/Binary-Tree/"}]},{"title":"算法题：位运算相关","slug":"算法题-位运算相关","date":"2019-05-28","updated":"2019-06-26","comments":true,"path":"算法题-位运算相关/","link":"","permalink":"http://sunyunzeng.com/算法题-位运算相关/","excerpt":"","text":"只出现一次的数字 题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例1:12输入: [2,2,1]输出: 1示例2:12输入: [4,1,2,1,2]输出: 4 思路由于时间复杂度与空间复杂度的限制，这道题目解决办法一定是很巧妙的。答案是采用异或的方法。Java的**异或^**是位运算的一种，含义是相同的位数置 0 ，相异的位数置 1 。数字本身(相同数字)的异或结果为 0 ，0 与任何数字的异或结果为其本身。Hash Map中的hash码映射到数组位置就采用了异或的方法，(h=key.hashcode())^(h&gt;&gt;16);例如:0000 0000 0000 1011 ^0000 0000 0000 11110000 0000 0000 0100 代码12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; int len = nums.length; for(int i=0; i&lt;len; i++)&#123; result = result^nums[i]; &#125; return result; &#125;&#125; 汉明距离 题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 231.示例：12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 思路先异或运算 ^ 将相同位置不同数字的置为 1 。再通过移位， 与 1 进行 与 &amp; 运算，计算出结果。 代码1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x^y; int result = 0; // 计算二进制表示中 1 的数量 while(z&gt;0)&#123; if((z &amp; 1) == 1)&#123; result ++; &#125; z &gt;&gt;= 1; &#125; return result; &#125;&#125; 计算m的n次方例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:m^1101 = m^0001 * m^0100 * m^1000。 代码12345678910111213141516public class Pow &#123; public static int pow(int m, int n) &#123; int sum = 1; int tmp = m; while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; // 几个1乘几次 sum *= tmp; &#125; // 第二位乘两次，第三位乘四次... tmp *= tmp; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125; 不用辅助变量交换两个数用异或运算 ^ ，相同的数异或为 0 ,且支持交换律与结合律。 伪代码123x = x^y;y = x^y;x = x^y; 比特位计数给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。示例1:12输入: 2输出: [0,1,1]示例2:12输入: 5输出: [0,1,1,2,1,2]进阶:给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C或任何其他语言中不使用任何内置函数（如 C 中的 __builtin_popcount）来执行此操作。最容易想到方法12345678910111213141516class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=0; i&lt;=num; i++)&#123; int count = 0; int t = i; while(t &gt; 0)&#123; if((t &amp; 1) == 1) count++; t &gt;&gt;= 1; &#125; result[i] = count; &#125; return result; &#125;&#125;当前数字的比特位数量等于左移一位数字的比特位数量加上（当前数字&amp;1）123456789class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=1; i&lt;=num; i++)&#123; result[i] = result[i&gt;&gt;1] + (i &amp; 1); &#125; return result; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"快速排序 | 选择排序 | 冒泡排序","slug":"Algorithm-排序算法","date":"2019-05-27","updated":"2020-01-11","comments":true,"path":"Algorithm-排序算法/","link":"","permalink":"http://sunyunzeng.com/Algorithm-排序算法/","excerpt":"","text":"选择排序每次选择最小的元素放在第一个位置，再选第二小元素放到第二个位置… 以此类推，排序完成。12345678910111213141516171819202122232425public class SelectSort &#123; public static int[] sort(int[] nums)&#123; if(nums==null || nums.length==0) return null; int len = nums.length; int[] A = new int[len]; System.arraycopy(nums, 0, A, 0, len); for(int i=0; i&lt;len-1; i++)&#123; int min = i; for(int j=i+1; j&lt;len; j++)&#123; if(A[min]&gt;A[j])&#123; min = j; &#125; &#125; swap(A, i, min); &#125; return A; &#125; private static void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125; 冒泡排序每次将最大的(或最小的)沉入数组最底层。 代码123456789101112131415161718public class BubbleSort &#123; public static int[] sort(int[] arr) &#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr,0, A, 0, len); for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-i; j++) &#123; if(A[j]&gt;A[j+1])&#123; // 无需中介的数值互换方法 A[j] += A[j+1]; A[j+1] = A[j] - A[j+1]; A[j] -= A[j+1]; &#125; &#125; &#125; return A; &#125;&#125;转自知乎(插入、冒泡图片来源，侵删) 快速排序每次找出一个基准，作为划分标准。方法类似于二分法，每次都把小于基准的数放于基准数组的左边，把大于基准的数放于数组的右边。算法不稳定，时间复杂度最好O(nlog(n))O(nlog(n))O(nlog(n))，最差O(n2)O(n^2)O(n2)当数组本来是排序好的，例如是顺序排列，此时要计算逆序排列，如果利用快排方法，则时间复杂度为O(n2)O(n^2)O(n2)，当然，此时的基准选取是头部或者尾部。所以基准的选取很重要，常见得有随机选取、取首或末端的数及三数中值法（取首末及中间位置三个数的中值）。理论上，选取的基准是所有数的中位数，则划分最均匀，用时最短。 选取末尾值作为基准1234567891011121314151617181920212223242526272829303132333435363738394041public class QuickSort &#123; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = A[right]; int i = left; int j = right; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right] = A[i]; A[i] = criterion; return i; &#125;&#125; 优化的快速排序采用三值法作为划分基准，并在数据量不大时采用插入排序，提高效率。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class QuickSort &#123; private int threshold = 4; QuickSort()&#123;&#125;; QuickSort(int i) &#123; this.threshold = i; &#125; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 小数据情况下递归方法需要调用栈，效率较低，此时采用插入排序方法 if(right-left&gt;4)&#123; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125;else &#123; insertionSort(A); &#125; &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = getMedianPivot(A, left, right); // 从第二个及倒数第二个开始，因为getMedianPivot已经对首末数值进行了排序 int i = left+1; int j = right-1; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right-1] = A[i]; A[i] = criterion; return i; &#125; private int getMedianPivot(int[]A, int left, int right)&#123; int center = (left+right)/2; // 对于首末及中间的数进行排序 if (A[left] &gt; A[center]) &#123; swap(A, left, center); &#125; if (A[center] &gt; A[right]) &#123; swap(A, center, right); &#125; if (A[left] &lt; A[right]) &#123; swap(A, left, right); &#125; //交换中间与倒数第二个数，因为经过排序，最后一个已经是最大 swap(A, center, right-1); return A[right-1]; &#125; private void swap(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; private void insertionSort(int[] A) &#123; int len = A.length; int i,j; for (i = 0; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j] &lt; A[j - 1]; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; &#125;&#125;学习资料:LeetCode 知乎回答排序算法快速排序–CSDN讲解十大排序算法讲解推荐–微信公众号(快排图片来源，侵删)排序算法–CyC2018大神博客","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://sunyunzeng.com/tags/排序算法/"}]},{"title":"Linux终端常用指令","slug":"Linux终端常用指令","date":"2019-05-27","updated":"2019-06-10","comments":true,"path":"Linux终端常用指令/","link":"","permalink":"http://sunyunzeng.com/Linux终端常用指令/","excerpt":"","text":"常用指令集指令作用pwd打印当前工作目录hostname获取我的计算机的网络名称mkdir创建目录cd更改目录ls列出目录下的文件rmdir删除目录pushdpush directorypopdpop directorycp复制文件或目录mv移动/重命名文件或目录less按页查看文件cat输出整个文件xargs执行参数find查找文件grep查找文件里面的东西man阅读帮助手册aproposfind what man page is appropriateenv查看计算机环境echo输出一些参数export设置一个新的环境变量exit退出终端sudo危险! 拥有超级用户权限!sudo rm –rf /*赶紧跑路吧！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://sunyunzeng.com/categories/Linux/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"算法题--买卖股票的最佳时机","slug":"算法题-买卖股票的最佳时机","date":"2019-05-26","updated":"2020-01-11","comments":true,"path":"算法题-买卖股票的最佳时机/","link":"","permalink":"http://sunyunzeng.com/算法题-买卖股票的最佳时机/","excerpt":"","text":"基础版给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例11234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例212345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例3123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路贪心算法，通过计算局部最优，综合多个局部最优结果得到全局最优结果一次循环，只要第二天股票价格比当天高，就买入，否则不买入。计算当天买入跟第二天卖出的利润和，即为结果。并不一定要在最低值买入，在最高点卖出。因为每次低买高卖的累积和等于最低点与最高点之间的收益。 代码1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int result = 0; for(int i=0; i&lt;=prices.length-2; i++)&#123; if(prices[i]&lt;prices[i+1])&#123; result += prices[i+1]-prices[i]; &#125; &#125; return result; &#125;&#125;题目链接 有手续费版给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。示例 1：12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.注意 :1230 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000. 思路简单DP问题当前的状态 i 共有两种，持有股票与不持有股票持有股票状态可能是 前一状态买入 或者 当前买入:收益方程：buyprofiti=max(buyprofiti−1,sellprofiti−1−prices[i])buy_{profit}^i=max(buy_{profit}^{i-1}, sell_{profit}^{i-1}-prices[i])buyprofiti​=max(buyprofiti−1​,sellprofiti−1​−prices[i])不持有股票可能是 前一状态卖出 或者 当前卖出:收益方程：sellprofiti=max(sellprofiti−1,prices[i]+buyprofiti−fee)sell_{profit}^i=max(sell_{profit}^{i-1}, prices[i]+buy_{profit}^i-fee)sellprofiti​=max(sellprofiti−1​,prices[i]+buyprofiti​−fee) 代码1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len&lt;2) return 0; //没有stock的收益 int sell_profit = 0; //拥有stock的收益 int buy_profit = -prices[0]; for(int i=1; i&lt;len; i++)&#123; //今天卖了或者之前卖了的收益 sell_profit = Math.max(sell_profit, prices[i]+buy_profit-fee); //今天买了或者之前买了的收益 buy_profit = Math.max(buy_profit, sell_profit-prices[i]); &#125; //卖了股票的收益肯定大于持有股票的收益，因为持有股票是负收益 return sell_profit; &#125;&#125;题目链接 有冷冻期版给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 思路 + 代码与 题目2类似，不过要增加一个状态 ———— 冻结状态。卖出状态只能由买入状态转来。买入状态可由买入状态或者冻结状态转来。冻结状态由冻结状态或者买入状态转来。注意状态的依赖关系，不要再依赖前一状态之前先改变当前状态。1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices==null || prices.length==0) return 0; int hold = -prices[0]; int sold = 0; int freeze = 0; int len = prices.length; for(int i=1; i&lt;len; i++)&#123; int pre_sold = sold; sold = hold + prices[i]; hold = Math.max(hold,freeze-prices[i]); freeze = Math.max(freeze, pre_sold); &#125; return Math.max(sold, freeze); &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 只允许买卖一次版本给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。示例1：1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例2：123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路动态规划问题。维护一个值，存储之前i-1天的最大利润，当前i天的最大利润为当前价格与前i-1天价格最小值的差值与i-1最大利润的较大值。 代码123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len&lt;2) return 0; int result = -prices[0]; int min_price = prices[0]; for(int i=1; i&lt;len; i++)&#123; result = Math.max(result, prices[i]-min_price); if(prices[i]&lt;min_price) min_price = prices[i]; &#125; return result&lt;0?0:result; &#125;&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 只允许买卖两次版本给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:1234输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:123输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 思路 + 代码四个状态，即第一次买入与卖出，第二次买入与卖出。12345678910111213141516171819class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if not prices: return 0 first_buy, first_sell = float('-inf'), 0 second_buy, second_sell = float('-inf'), 0 for price in prices: if first_buy &lt; -price: first_buy = -price if first_buy+price &gt; first_sell: first_sell = first_buy+price if second_buy + price &lt; first_sell: second_buy = first_sell - price if second_buy + price &gt; second_sell: second_sell = second_buy + price return second_sell来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 允许买卖k次给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:123输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。示例 2:1234输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 思路 + 代码参考链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/12345678910111213141516171819202122232425262728class Solution(object): def maxProfitInf(self, prices): buy, sell = -prices[0], 0 for i in range(1, len(prices)): buy = max(buy, sell-prices[i]) sell = max(sell, buy+prices[i]) return sell def maxProfit(self, k, prices): \"\"\" :type k: int :type prices: List[int] :rtype: int \"\"\" if not prices or k&lt;=0: return 0 n = len(prices) # 此时相当于可以无限交易 if k &gt;= n//2: return self.maxProfitInf(prices) # 0表示不持有股票，1表示持有股票 dp = [[[0]*2 for _ in range(k+1)] for _ in range(n)] for i in range(n): for j in range(1,k+1): if i-1&lt;0: dp[i][j][0], dp[i][j][1] = 0, -prices[i] continue dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1]+prices[i]) # 表明交易是在k=1开始的 dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0]-prices[i]) return dp[-1][-1][0]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"},{"name":"Greedy Algorithm","slug":"Greedy-Algorithm","permalink":"http://sunyunzeng.com/tags/Greedy-Algorithm/"}]},{"title":"Minimum-Falling-Path-Sum","slug":"Minimum-Falling-Path-Sum","date":"2019-05-25","updated":"2019-05-29","comments":true,"path":"Minimum-Falling-Path-Sum/","link":"","permalink":"http://sunyunzeng.com/Minimum-Falling-Path-Sum/","excerpt":"","text":"下降路径最小和题目细节给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。示例112输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12解释：可能的下降路径有：123[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。提示121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100 思路典型的二维动态数组题目。创建一个二维的数组**A[row][column]**存储结果，每一个位置存储的是第一行到该位置最小的下降路径。一般情况1A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]);前后两列情况12第一列: A[i][j] += min(A[i-1][j],A[i-1][j+1]);最后一列: A[i][j] += min(A[i-1][j-1],A[i-1][j]); Algorithm123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minFallingPathSum(int[][] A) &#123; int row = A.length; int col = A[0].length; if(row==1)&#123; return A[0][0]; &#125; for(int i=1;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; if(j-1&lt;0)&#123; A[i][j] += min(A[i-1][j],A[i-1][j+1]); &#125; else if(j+1&gt;col-1)&#123; A[i][j] += min(A[i-1][j-1],A[i-1][j]); &#125; else&#123; A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]); &#125; &#125; &#125; int result = Integer.MAX_VALUE; for(int i=0;i&lt;col;++i)&#123; if (A[row-1][i] &lt; result) &#123; result = A[row-1][i]; &#125; &#125; return result; &#125; public int min(int a, int b)&#123; return (a&lt;=b?a:b); &#125;&#125;题目链接类似题目","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Algorithm--Third Maximum Number","slug":"Algorithm-Third-Maximum-Number","date":"2019-05-23","updated":"2019-05-31","comments":true,"path":"Algorithm-Third-Maximum-Number/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Third-Maximum-Number/","excerpt":"","text":"1. Third Maximum Number Title DetailGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).Example 1:123Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:123Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:12Input: [2, 2, 3, 1]Output: 1Explanation:Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 思路因为要求算法的时间复杂度为O(n)，所以不能用排序的方法。因为只求第三大的数，跟求第一大的数原理类似，只不过注意边界条件。 Algorithm1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int thirdMax(int[] nums) &#123; if(nums.length==1) return nums[0]; if(nums.length==2) return Math.max(nums[0], nums[1]); int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; int max3 = Integer.MIN_VALUE; int flag = 0; boolean f = true; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;max1)&#123; max3=max2; max2=max1; max1=nums[i]; ++flag; continue; &#125; if(max1&gt;nums[i] &amp;&amp; nums[i]&gt;max2)&#123; max3=max2; max2=nums[i]; ++flag; continue; &#125; if(max2&gt;nums[i] &amp;&amp; nums[i]&gt;max3)&#123; max3=nums[i]; ++flag; continue; &#125; // 边界条件，如果有多个最小值，则只算一次 if(nums[i]==Integer.MIN_VALUE&amp;&amp;f)&#123; flag++; f = false; continue; &#125; &#125; return (flag&lt;3?max1:max3); &#125;&#125;题目链接 2. Smallest Range I Title DetailGiven an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i].After this process, we have some array B.Return the smallest possible difference between the maximum value of B and the minimum value of B.Example 1:123Input: A = [1], K = 0Output: 0Explanation: B = [1]Example 2:123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8]Example 3:123Input: A = [1,3,6], K = 3Output: 0Explanation: B = [3,3,3] or B = [4,4,4]Note:1231 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 100000 &lt;= K &lt;= 10000 思路求出数组最大值与最小值的差值，比较差值与K/2的关系。 Algorithm1234567891011121314151617class Solution &#123; public int smallestRangeI(int[] A, int K) &#123; if(A.length==0) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(int i=0; i&lt;A.length; i++)&#123; if(A[i]&lt;min) min = A[i]; if(A[i]&gt;=max) max = A[i]; &#125; int len = max-min; if(len&gt;2*K) return len-2*K; else return 0; &#125;&#125;题目链接 3. 数组形式的整数加法 题目细节对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。示例1：123输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234示例2：123输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455示例3：123输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021示例4：123输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000提示：12341 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 90 &lt;= K &lt;= 10000如果 A.length &gt; 1，那么 A[0] != 0 思路最初思路是字符串转数字，相加后转字符串。但是最终没过，因为数据量太大，不允许。后又通过进位方式实现，老太太的裹脚布。 Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int len = A.length; for(int i=len-1; i&gt;=0; --i) &#123; int temp = A[i] + K; if (temp &gt;= 10) &#123; A[i] = temp % 10; K = temp / 10; &#125; else &#123; A[i] = temp; K = temp /10; break; &#125; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (K!=0)&#123; String s = String.valueOf(K); for(char c: s.toCharArray()) result.add(c-'0'); &#125; for (int i : A) &#123; result.add(i); &#125; return result; &#125;&#125;官方答案123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int N = A.length; int cur = K; List&lt;Integer&gt; ans = new ArrayList(); int i = N; while (--i &gt;= 0 || cur &gt; 0) &#123; if (i &gt;= 0) cur += A[i]; ans.add(cur % 10); cur /= 10; &#125; Collections.reverse(ans); return ans; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Java：List API","slug":"Java-ArrayList-API","date":"2019-05-21","updated":"2019-09-05","comments":true,"path":"Java-ArrayList-API/","link":"","permalink":"http://sunyunzeng.com/Java-ArrayList-API/","excerpt":"","text":"Java List 常用类型类型特征ArrayList随机访问元素快；中间插入与删除元素较慢；操作不是线程安全的LinkedList中间插入与删除操作代价较低，提供优化的顺序访问；随机访问元素慢 ArrayListArrayList的UML类图如下所示：ArrayList 继承了 AbstractList, 直接实现了 Cloneable, Serializable，RandomAccess 类型标志接口。AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的 for 循环方式，并且执行效率上给迭代器方式更高。Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 clone 方法，实现 ArrayList 的拷贝。Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 serialVersionUID 属性值。 ArrayList 常用 API方法描述boolean add(E object)再 ArrayList 尾存入对象void add(int location, E object)在 location 添加对象boolean addAll(Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入boolean addAll(int location, Collection&lt;? extends E&gt; collection)将一个 Collection 对象中存储全部的对象复制并存入locationboolean contains(Object object)是否包对象 objectboolean containsAll(Collection&lt;?&gt; collection)是否包含一个 Collection 对象boolean isEmpty()ArrayList 是否为空E get(int location)获取 location 的对象E set(int location, E object)将某个位置的元素替换成 objectint indexOf(Object object)获取某个对象的位置（顺序遍历第一个）int lastIndexOf(Object object)获取某个对象的位置（逆序遍历第一个）int size()返回 ArrayList 存储的对象数量boolean remove(Object object)删除存储的某个对象E remove(int lcoation)删除位于 location 的对象boolean removeAll(Collection&lt;?&gt; collection)删除存储的某个 Collection 对象Object [] toArray()ArrayList 转数组List&lt;‘E’&gt; subList(int start, int end)获取位于 start 与 end 之间的 Listvoid clone()克隆ArrayListvoid clear()移除ArrayList中所有对象Iterator&lt;‘E’&gt; iterator()获取该 ArrayList 对应的迭代器对象 ArrayList 应用示例1. ArrayList与数组之间的转换1234567891011121314151617181920// 转数组List&lt;String&gt; list = new ArrayList&lt;&gt;();String[] strings = new String[list.size()];list.toArray(strings);// 或者String[] strings = (String[])list.toArray(new String[list.size()]);// 数组转List// 法1 快速，但是以视图形式返回，无法对数据进行删除及添加操作；// 可用 set() 方法修改元素，但是原始List数据会随之改变String[] s = &#123;\"abc\", \"def\", \"ghi\"&#125;;List&lt;String&gt; list = java.util.Arrays.asList(s);//法 2 慢，但是新生成一个ArrayList，可对List进行操作不会对原对象产生影响List&lt;String&gt; assertList = new ArrayList();Collections.addAll(assertList, strings);2. ArrayList遍历方式123456789101112131415161718192021222324List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));// 第一种，通过迭代器遍历。即通过Iterator去遍历。Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123;value = (Integer)iter.next();&#125;// 第二种，随机访问，通过索引值去遍历。Integer value = null;int size = list.size();for (int i=0; i &lt; size; i++) &#123;value = (Integer)list.get(i); &#125;// 第三种，for循环遍历。Integer value = null;for (Integer integer: list) &#123;value = integer;&#125;// 第四种，利用Stream API的 stream.forEach()方法依次获取。list.forEach(num -&gt; System.out.println(num));3. 初始化12345678910111213141516171819202122232425// 第一种方式 Arrays.asList()方法ArrayList&lt;Integer&gt; list = new Arraylist&lt;&gt;(Arrays.asList(1, 2, 3));// 第二种方法 常规方式ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);//或者List innerList = Arrays.asList(1, 2, 3);list.addAll(innerList);// 第三种方法 使用生成匿名内部类ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123; &#123; add(1); add(2); add(3); &#125;&#125;；// 第四种方式 使用Collection.nCopiesint element = 1;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Collections.nCopies(2, element)); //复制伍分到list中。4. 打印信息由于ArrayList内部实现了toString()方法，所以可以直接打印12ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));System.out.println(list);对于数组信息的打印123456789int[] A = &#123;1, 2, 3&#125;;// 方法一for(Integer i: A)&#123; System.out.println(i);&#125;//方法二System.out.println(Arrays.toString(A));5. 大量头部的增删操作ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 LinkedList 代替。由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。 参考资料ArrayList源码剖析: http://www.spring4all.com/article/16262","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Algorithm：删除最外层的括号","slug":"Algorithm-删除最外层的括号","date":"2019-05-21","updated":"2019-05-31","comments":true,"path":"Algorithm-删除最外层的括号/","link":"","permalink":"http://sunyunzeng.com/Algorithm-删除最外层的括号/","excerpt":"","text":"删除最外层括号 题目有效括号字符串为空 (&quot;&quot;)、&quot;(&quot; + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 “(()(()))” 都是有效的括号字符串。如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。示例1输入：&quot;(()())(())&quot;输出：&quot;()()()&quot;解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。示例2输入：&quot;(()())(())(()(()))&quot;输出：&quot;()()()()(())&quot;解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。示例3输入：&quot;()()&quot;输出：&quot;&quot;解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。提示123S.length &lt;= 10000S[i] 为 \"(\" 或 \")\"S 是一个有效括号字符串 思路用一个数组模拟栈，发现 “(” 使其进栈，发现 “)” 时使 “(” 出栈。注意: 栈底的 “(” 出栈不输出，当输出字符串中 “(” 和 “)” 数量不相等时，才输出 “)” 。 代码12345678910111213141516171819202122232425262728class Solution &#123; public String removeOuterParentheses(String S) &#123; // list作为栈，记录(数量 List&lt;Character&gt; list = new ArrayList(); StringBuilder bf = new StringBuilder(); int left = 0; // 记录输出的 ( 数量 int right = 0; //记录输出的 ) 数量 for(int i=0; i&lt;S.length(); i++)&#123; char c = S.charAt(i); if(c=='(') list.add(c); if(c==')')&#123; if(list.size()==1&amp;&amp;left==right) list.remove(0); if(list.size()&gt;1)&#123; while(list.size()!=1)&#123; bf.append(\"(\"); list.remove(list.size()-1); ++left; &#125; &#125; if(left!=right)&#123; bf.append(\")\"); ++right; &#125; &#125; &#125; return bf.toString(); &#125;&#125; 更Niubility的code：123456789101112131415161718class Solution &#123; public String removeOuterParentheses(String S) &#123; StringBuilder bf = new StringBuilder(); int flag = 0; for(char c: S.toCharArray())&#123; if(c == '(')&#123; ++flag; if(flag == 1) continue; &#125; if(c==')')&#123; --flag; if(flag == 0) continue; &#125; bf.append(c); &#125; return bf.toString(); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm--Minimum path sum","slug":"Algorithm-Minimum-path-sum","date":"2019-05-21","updated":"2019-05-29","comments":true,"path":"Algorithm-Minimum-path-sum/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Minimum-path-sum/","excerpt":"","text":"Dynamic Programming Minimum Path SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6 思路动态规划 问题。用原来的grid矩阵存储路径和注意三种特殊情况，即矩阵初始位置、顶栏及左侧栏和求解。初始：grid[0][0] = grid[0][0]顶栏：grid[i][j] = grid[i][j-1]左侧栏：grid[i][j] = grid[i-1][j]其余位置：grid[i][j] = min(grid[i][j-1], grid[i-1][j]) Algorithm12345678910111213141516171819202122class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; for(int i=0; i&lt;m;i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0&amp;&amp;j==0)&#123; continue; &#125; else if(i==0&amp;&amp;j!=0)&#123; grid[i][j] += grid[i][j-1]; &#125; else if(j==0&amp;&amp;i!=0)&#123; grid[i][j] += grid[i-1][j]; &#125;else&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Algorithm--Partition-array-for-maximum-sum","slug":"Algorithm-partition-array-for-maximum-sum","date":"2019-05-21","updated":"2019-05-29","comments":true,"path":"Algorithm-partition-array-for-maximum-sum/","link":"","permalink":"http://sunyunzeng.com/Algorithm-partition-array-for-maximum-sum/","excerpt":"","text":"Dynamic Programming Partition Array for Maximum SumTitle DetailGiven an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray.Return the largest sum of the given array after partitioning.Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6 思路动态规划 问题。用一个长度为A.length的数组dp维护最终的加和结果。计算思想如下：dp[i] := max sum of A[0] ~ A[i]dp[i] = max{dp[i – k] + max(A[i+1-k:i]) * k}, 1 &lt;= k &lt;= min(i, K)最终返回结果dp[A.length-1] Algorithm1234567891011121314class Solution &#123; public int maxSumAfterPartitioning(int[] A, int K) &#123; int len = A.length; int[] dp = new int[len]; for(int i=0; i&lt;A.length; ++i)&#123; int max_num = A[i]; for(int k=1; k&lt;=K &amp;&amp; i+1-k&gt;=0; ++k)&#123; max_num = Math.max(max_num, A[i+1-k]); dp[i] = Math.max(dp[i], (i-k&gt;=0?dp[i-k]:0) + k*max_num); &#125; &#125; return dp[len-1]; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Java-for循环那些事","slug":"Java-for循环那些事","date":"2019-05-21","updated":"2019-05-29","comments":true,"path":"Java-for循环那些事/","link":"","permalink":"http://sunyunzeng.com/Java-for循环那些事/","excerpt":"","text":"Java for循环里面的 i++ 与 ++i在for循环里两者的作用是一样的i++12345for(int i=0; i&lt;5; i++)&#123; System.out.print(i + \",\");&#125;&gt;&gt; 0, 1, 2, 3, 4++i12345for(int i=0; i&lt;5; ++i)&#123; System.out.print(i + \",\");&#125;&gt;&gt; 0, 1, 2, 3, 4工作原理i++1234&#123; System.out.print(i + \",\"); i++;&#125;++i1234&#123; System.out.print(i + \",\"); ++i;&#125;区别在Java里面，i++ 需要开辟新的存储空间用于存储结果，++i 直接在原存储空间中存储结果。故 ++i 在 for 循环里面执行效率要高。 可以作为代码优化的一部分。 foreach 与 for循环的效率首先测试数组123456789101112131415161718192021// 测试for循环int[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(int i=0; i&lt;len; i++)&#123; res += A[i];&#125;long endTime = System.nanoTime();System.out.println(\"for循环: \"+(endTime- startTime));// 测试foreachint[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(Integer i: A)&#123; res += i;&#125;long endTime = System.nanoTime();System.out.println(\"foreach循环: \"+(endTime- startTime));结果12for循环: 37143324forecah循环: 75450311可见对于大数组采用for循环效率更高再测试ArrayList12345678910111213141516171819202122ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000); for(int i=0; i&lt;30000000; i++)&#123; list.add(i); &#125;// 测试for循环long startTime = System.nanoTime();int size = list.size();int res = 0;for(int i=0; i&lt;size; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(\"for循环: \"+(endTime- startTime));// 测试foreachlong startTime = System.nanoTime();int res = 0;for(Integer i: list)&#123; res += i; &#125;long endTime = System.nanoTime();System.out.println(\"foreach循环: \"+(endTime- startTime));结果12for循环: 39368248forecah循环: 42177137可见对于ArrayList仍然是采用for循环效率更高！ for循环小技巧 关于数组循环嵌套采用小套大。原理跟复制几个大文件跟复制一堆小文件耗时一样。测试12345678910long startTime = System.nanoTime();int res = 0;// 大套小for(int i=0; i&lt;10000000; i++)&#123; for(int j=0; j&lt;100; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println(\"大套小: \"+(endTime- startTime));12345678// 小套大for(int i=0; i&lt;100; i++)&#123; for(int j=0; j&lt;10000000; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println(\"小套大: \"+(endTime- startTime));结果12大套小: 57934223小套大: 4918044数组复制时采用System.arraycopy()方法比for循环复制效率高。System.arraycopy()public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 关于ArrayList在循环时，首先把ArrayList长度size记录下来。测试1234567891011121314151617181920ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000);for(int i=0; i&lt;30000000; i++)&#123; list.add(i);&#125;long startTime = System.nanoTime();//先把长度保存下来int len = list.size();int res = 0;for(int i=0; i&lt;len; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(\"保存size(): \"+(endTime- startTime));//没有保存size()for(int i=0; i&lt;list.size(); i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(\"没有保存size(): \"+(endTime- startTime));结果12保存size(): 38973440没有保存size(): 39486862","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Java：Map API","slug":"Java-Map-API","date":"2019-05-19","updated":"2019-09-05","comments":true,"path":"Java-Map-API/","link":"","permalink":"http://sunyunzeng.com/Java-Map-API/","excerpt":"","text":"Java Map 常用类型类型特征HashMap根据 HashCode 存储数据，访问速度快。至多允许一条记录键为 null;允许多条记录的值为 null；线程非同步TreeMap保存的记录按照键(key)排序，也可自定义排序规则。用生成的 Iterator 遍历 TreeMap 得到记录是排序后的。不允许记录的键为 null；线程非同步Hashtable用 HashMap 类似,不同的是键值都不允许为 null。 支持线程同步，但写入较慢LinkedHashMap保留记录的插入顺序，生成Iterator遍历顺序与插入顺序一致。遍历比HashMap慢，键值都允许为 null；线程非同步–&gt; HashMap剖析 常用 API方法描述Object put(Object k, Object v)存入键值对Object get(Object k)返回键所映射的值；如果不存在该映射则返回 nullboolean containsKey(Object k)是否包含键 kboolean containsValue(Object v)是否包含值 vboolean isEmpty()Map 是否为空int size()返回 Map 的键值对数boolean remove(Object k)如果存在一个键映射关系，则删除此关系(映射关系不存在不会报错)void clear()移除Map中所有映射关系boolean equals(Object obj)比较指定对象于此 Map 是否相等void putAll(Map m)将指定 Map 的映射关系复制到此 Map 中Collection values()以 Collection 形式返回 Map 包含的值Set keySet()以 Set 形式返回 Map 包含的键Set entrySet()以 Set 形式返回 Map 的映射关系Map 应用示例123456789Map&lt;Integer, Character&gt; map = new HashMap&lt;&gt;();map.put(1, 'c');map.get(1);for(int i: map.keySet())&#123; System.out.println(map.get(i)); &#125;if(map.containsKey(1))&#123; map.remove(1);&#125; 常用遍历方法1. 只获取键或值123456789// 获取键for(Integer key: map.keyset())&#123; System.out.println(key);&#125;// 获取值for(Integer value: map.value())&#123; System.out.println(value);&#125;2. 同时获取键和值1234567891011// 2.1 先取key再取value。不推荐for(Integer key:map.keySet())&#123; System.out.println(map.get(key));&#125;// 2.2 通过map entrySet遍历。性能优于上一种。for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; System.out.println(entry.getKey() + \":\" + entry.getValue());&#125;3. Iterator上面的foreach都可以用Interator代替。foreach是对Set遍历,大小不能改变。如果改变map的大小，会报错。如果想要删除元素，还是要用Interator的方式删除。123456Interator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.enteySet().iterator();while(it.hasNext())&#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + \":\" + entry.getValue()); // it.remove() 删除元素&#125;4. Lambda代码简洁，但是性能低于entrySet。123map.forEach((key, value)-&gt;&#123; System.out.println(key + \":\" + value);&#125;)5. 性能测试用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap12345static&#123; for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125;&#125;测试结果如下：KeySet： 392Values： 320keySet get(key)： 552entrySet： 465entrySet Iterator：508Lambda： 536Map的遍历方法参考(侵删)","categories":[{"name":"Java","slug":"Java","permalink":"http://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://sunyunzeng.com/tags/Tips/"}]},{"title":"Algorithm--Coin Change","slug":"Algorithm-Coin-Change","date":"2019-05-19","updated":"2019-05-29","comments":true,"path":"Algorithm-Coin-Change/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Coin-Change/","excerpt":"","text":"Dynamic Programming Coin ChangeTitle DetailYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.Example 1:123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 1:12Input: coins = [2], amount = 3Output: -1Note:You may assume that you have an infinite number of each kind of coin. 思路动态规划 问题。用一个 amount+1长度的数组 bp 维护不同面值金额需要最小的硬币数。bp[0]=0bp[1~amount]=amount+1位置0表示面值为零，最小需要0个硬币，初始为0.位置0~amount假设需要amount个硬币，因硬币类型为int，即代表无解。对于硬币类型coins[i]，寻找j=coins[i] ~j=amount对应面值金额的最小硬币数，即为min(dp[j], dp[j-coins[i]]+1)。dp[j-coins[i]]+1代表放入一个该类型硬币。前提： dp[j-coins[i]]面值的金额不是无解，因为如果无解，那么dp[j-coins[i]]+1对于当前面值金额也是无解。返回dp数组第amount位置数字，即为所求。 Algorithm12345678910111213141516171819class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(coins.length==0) return -1; // 创建维护结果的数组 int[] dp=new int[amount+1]; Arrays.fill(dp,1,dp.length,amount+1); for(int i=0; i&lt;coins.length;i++)&#123; // 前提 for(int j=coins[i]; j&lt;=amount;j++)&#123; // 硬币数量统计 if(dp[j-coins[i]]!=amount+1)&#123; dp[j]=Math.min(dp[j], dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=amount+1) return dp[amount]; return -1; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://sunyunzeng.com/tags/Dynamic-Programming/"}]},{"title":"Algorithm--Sqrt(x)","slug":"Algorithm-Sqrt-x","date":"2019-05-19","updated":"2019-05-31","comments":true,"path":"Algorithm-Sqrt-x/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Sqrt-x/","excerpt":"","text":"Some Algorithm using Math Algorithm Algorithm-1 Sqrt(x)Title detailImplement int sqrt(int x)Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:12Input: 4Output: 2Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 思路牛顿迭代法公式： xk+1=⌊xk+n/xk⌋/2x_{k+1} = \\lfloor {x_k + n / {x_k}} \\rfloor / 2xk+1​=⌊xk​+n/xk​⌋/2当k→∞k \\rightarrow \\inftyk→∞ 时，xk+12→n{x_{k+1}}^2 \\rightarrow nxk+1​2→n Algorithm123456789101112class Solution &#123; public int mySqrt(int x) &#123; if(x&lt;=1) return x; long r=x; long t = x/r; while(r&gt;t)&#123; t = x/r; r = (r + t)/2; &#125; return (int)r; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algortthm--Jewels and Stones","slug":"Algortthm-Jewels-and-Stones","date":"2019-05-19","updated":"2019-05-31","comments":true,"path":"Algortthm-Jewels-and-Stones/","link":"","permalink":"http://sunyunzeng.com/Algortthm-Jewels-and-Stones/","excerpt":"","text":"Map的应用 Jewels and StonesTitle DetailYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.Example 1:12Input: J = \"aA\", S = \"aAAbbbb\"Output: 3Example 2:12Input: J = \"z\", S = \"ZZ\"Output: 0Note:S and J will consist of letters and have length at most 50.The characters in J are distinct. 思路使用Java里面的 Map。key键保存宝石类型，value键保存数量统计。 Algorithm1234567891011121314151617181920class Solution &#123; public int numJewelsInStones(String J, String S) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;J.length(); i++)&#123; map.put(J.charAt(i), 0); &#125; for(int i=0; i&lt;S.length();i++)&#123; Character c = S.charAt(i); if(map.get(c)!=null)&#123; Integer freq =map.get(c); map.put(c, freq+1); &#125; &#125; int result = 0; for(Integer value: map.values())&#123; result += value; &#125; return result; &#125;&#125; 法2 正则表达式123String a = \"[^\"+J+\"]\"; S = S.replaceAll(a, \"\"); return S.length(); Python方法1return sum(S.count(i) for i in J)题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm--Fast and Slow Pointer","slug":"Algorithm-Fase-and-Low-Pointer","date":"2019-05-17","updated":"2019-05-31","comments":true,"path":"Algorithm-Fase-and-Low-Pointer/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Fase-and-Low-Pointer/","excerpt":"","text":"快慢指针的应用 判断链表是否存在环Title DetailGiven a linked list, determine if it has a cycle in it.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.Example 1:123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. 思路利用快慢指针，快指针每次走两步，慢指针每次走一步。如果快指针能够追上慢指针，则链表存在环。 Algorithm1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null || head.next.next==null) return false; ListNode fast = head; ListNode slow = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow)&#123; return true; &#125; &#125; return false; &#125;&#125;题目链接 有序数组移除重复数字Title DetailGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 1:12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 思路前提是有序数组，可见排序是很基础且重要的算法！过程：初始，快慢指针指向第一个数字。当快慢指针指向的数字都相同，快指针往前移动一位。当快慢指针指向的数字不相同，慢指针往前移动一位，把快指针指向的数字赋予慢指针，快指针往前移动一位。慢指针移动的 位数+1 即为不同数字的数量。且数组从初始位置到慢指针指向的位置，数字都是排好序的。 Algorithm1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int fast=0; int slow=0; while(fast&lt;nums.length)&#123; if(nums[fast]==nums[slow])&#123; fast++; &#125;else&#123; nums[++slow]=nums[fast++]; &#125; &#125; return slow+1; &#125;&#125;图片地址题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"Algorithm--Find Common Characters","slug":"Algorithm-Find-Common-Characters","date":"2019-05-17","updated":"2019-05-31","comments":true,"path":"Algorithm-Find-Common-Characters/","link":"","permalink":"http://sunyunzeng.com/Algorithm-Find-Common-Characters/","excerpt":"","text":"Find Common Characters Title detailGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.You may return the answer in any order.Example 112Input: [\"bella\",\"label\",\"roller\"]Output: [\"e\",\"l\",\"l\"]Example 212Input: [\"cool\",\"lock\",\"cook\"]Output: [\"c\",\"o\"]Note:1231 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 100A[i][j] is a lowercase letter 思路统计每个字符串中26个字母的出现次数。每个字符串都出现的字母且统计次数最少的即为结果输出的字符。用int数组0-25位置表示0-26个字母，存储的整数代表出现总次数。 Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; commonChars(String[] A) &#123; List&lt;String&gt; list = new ArrayList(); int[] res = new int[26]; for(int i=0; i&lt;A[0].length();i++)&#123; res[A[0].charAt(i) - 'a'] += 1; &#125; for(int i=0; i&lt;A.length;i++)&#123; int[] temp = new int[26]; for(int j=0; j&lt;A[i].length(); j++)&#123; temp[A[i].charAt(j) - 'a'] +=1; &#125; for(int m=0; m&lt;26; m++)&#123; res[m] = Math.min(res[m], temp[m]); &#125; &#125; for(int i=0; i&lt;26; i++)&#123; if(res[i] &gt; 0)&#123; for(int j=0; j&lt;res[i]; j++)&#123; list.add((char)('a'+i)+\"\"); &#125; &#125; &#125; return list; &#125;&#125;题目链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sunyunzeng.com/categories/Algorithm/"}],"tags":[{"name":"Other Algorithm","slug":"Other-Algorithm","permalink":"http://sunyunzeng.com/tags/Other-Algorithm/"}]},{"title":"在Linux系统中同步更新我们的Github博客","slug":"在Linux系统中同步更新我们的Github博客","date":"2019-04-28","updated":"2019-09-01","comments":true,"path":"在Linux系统中同步更新我们的Github博客/","link":"","permalink":"http://sunyunzeng.com/在Linux系统中同步更新我们的Github博客/","excerpt":"","text":"原理介绍类似于版本管理，我们把hexo博客文件系统在Github上建立一个分支，通过管理分支提交最新的博客文件系统，保证我们博客框架的更新。然后我们基于最新的博客框架，撰写文章，进行Github Pages网页的更新，即我们博客内容的更新。创建两个分支，一个用于存放博客静态资源，一个用于备份博客的部署文件。参考资料 前期准备一台Linux系统的电脑（我的linux系统是Ubuntu 18.04.2 LTS）安装node.js 及 npm安装 ssh安装 git按照我们前面教程搭建好的博客 创建Github 博客仓库分支首先在我们搭建Hexo博客的电脑上，创建我们博客仓库在Github上的分支。打开我们的博客仓库，选择setting：选择Branches,创建博客仓库的Hexo分支，并将其设置为默认分支。将该仓库克融到本地，并把本地博客的(所有Hexo目录下文件)全部拷贝进username.github.io文件目录中去。 然后把更新后的博客部署文件提交到Github的hexo分支中。依次执行123git add .git commit -m &apos;some info&apos;git push注意事项：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后我们的博客备份分支就创建好了。 Linux 部署项目安装Node.js 与 npm安装gitlinux与Github建立联系把我们创建好的博客备份仓库clone到本机（linux）4.1 在要保存的位置执行语句 git clone git@github.com:your.github.io/your.github.io.git4.2 进入username.github.io目录，执行npm install (由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以要安装依赖)安装hexo插件sudo npm install hexo-cli -g撰写我们的博客文章，然后依次执行下面指令，更新我们的博客备份。12345hexo cleanhexo ggit add .git commit -m &apos;some info&apos;git push更新博客界面hexo d 注意事项1. 每当撰写博客前，先 git pull，获取最新的博客备份。2. 写完博客后，先依次执行hexo clean 、 hexo g 、 git add . 、 git commit -m 'some info 、 git push'进行博客备份部署文件更新。3. 最后执行 hexo d部署博客界面，实现博客更新。","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"网页","slug":"网页","permalink":"http://sunyunzeng.com/tags/网页/"}]},{"title":"Windows环境下Hexo+Github搭建个人博客教程","slug":"博客搭建教程","date":"2019-04-23","updated":"2019-05-01","comments":true,"path":"博客搭建教程/","link":"","permalink":"http://sunyunzeng.com/博客搭建教程/","excerpt":"","text":"前言你是否也想拥有属于自己的博客？是否也想拥有跟我一样的博客空间？如果心动了，就赶紧往下看吧！教程炒鸡简单，炒鸡详细，而且博客搭建完全是Free of Charge! 原理 Github PagesGithub不仅可以让我们把代码托管在平台上，而且允许我们利用Github的服务器部署自定义网页对我们的项目作简介。这个网页就被称为Github Pages。这是我们可以利用Github搭建免费博客的基础啦~ Hexo**Hexo**是一款轻量但高逼格的搭建博客快速工具，它是基于Node.js开发的。而Node.js…好了，扯远了…有兴趣的童鞋可以出门左转自己百度… 准备知道了大致的原理，我们首先需要准备搭建博客的材料。如下：1. 一台windows系统的电脑2. 一个Github账号3. 安装Node.js4. 安装Git5. 安装Hexo 开始 申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)假设我们都有了Github账号，这是首先在右上角点击“+”号，选择New repository注意 仓库名一定是&quot;你的Github用户名&quot;+github.io !!!之后为我们的项目添加一个说明Pages！建好的项目顶部最右边有个Setting按钮，点击进入配置界面，下滑界面，直到看到Github Pages，这时你发现竟然自动生成了一个说明网页！因为Github说明网页的默认地址就是“你的Github用户名”+github.io，其它说明网页都是基于该地址的。 Ok! 到此为止，Gihub Pages的部分就结束了。 搭建Hexo，把Github Pages修改为自己的博客界面！ 安装Git以及Node.js！因为我们需要通过Git把我们的Hexo生成的网页提交到Github pages上，而Node.js是我们Hexo插件运行的基础！下载安装Windows版Git下载安装Node.js验证：“Win”+R打开运行界面，输入&quot;cmd&quot;打开命令行窗口。是否安装Git:输入git version出现版本信息：1git version 2.19.1.windows.1是否安装Node.js:输入node -v出现版本信息：1v8.12.0 安装及部署Hexo首先创建一个文件夹，用来放置我们的Hexo。然后进入我们的文件夹，例如我们文件夹路径为D:\\blog则在终端依次输入并执行D: 、 cd blog 进入文件夹打开命令终端，利用Node.js的包管理器npm安装Hexo:npm install hexo-cli -g输入hexo -v验证是否安装成功输入hexo init初始化该文件夹输入npm install安装需要的组件输入npm g生成静态文件输入npm s启动服务器，现在在浏览器输入http://localhost:4000/打开我们的博客界面！是不是有点鸡冻！别急，我们还需要把页面推送到Github Pages上，步骤如下：1. 设置Git的user name和email在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;2. SSH 授权打开git bash，输入ssh-keygen -t rsa, 接着回车三下。最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去3. 上传项目首先用IDE(我用的是WebStorm)打开我们的Hexo文件夹，发现它的文档目录是这样的：12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- public|-- themes|-- .gitignore_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 --save 保存进去。scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;layout(布局)&gt; &lt;‘title’&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用hexo clean 清除 db.json 和 public 文件夹下的所有文件。themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。打开配置文档_config.yml，修改deploy值（在末尾）:1234deploy: type: git repo: git@github.com:SUNYunZeng/SUNYunZeng.github.io.git branch: master安装在git上部署文章的扩展npm install hexo-deployer-git --save打开终端并进入到Hexo文件系统中，创建一篇新博客hexo new post &quot;博客名&quot;这时文件夹source/_posts文件夹里会出现博客名.md的博客文章源文件文件是markdown格式，书写方法有一套规范，下篇博客会讲到。PS:非常简单啦~编辑好博客内容后，一顿滚键盘，依次执行以下命令：hexo g 生成静态文件hexo d 部署到Github Pages就这样，你的第一篇博客就上传啦！ 更换Hexo主题由于默认的博客主题可能不能满足大家的需求，所以再提一下更换主题的方法。首先到Hexo官网中选择一款喜欢的主题这里我以我博客采用的主题为例，我采用的pure主题首先在Hexo系统文件夹中打开终端，然后输入git clone https://github.com/cofess/hexo-theme-pure.git themes/pure之后在系统目录theme文件夹下你会发现多出了pure命名的一个文件夹，这就是我们主题保存的位置,其中pure文件夹下的config.yml文件就是我们博客的配置文件，在里面可以自己对博客界面进行个性化配置，详情请参看网址在我们的Hexo系统配置文件config.yml中，修改theme为我们的pure主题1theme: pure然后进入文件夹 cd themes/pure把主题提交git pull重新生成博客静态文件，然后部署到Github Pageshexo ghexo d当当~我们的个性化博客就搭建完毕啦！","categories":[{"name":"教程","slug":"教程","permalink":"http://sunyunzeng.com/categories/教程/"}],"tags":[{"name":"网页","slug":"网页","permalink":"http://sunyunzeng.com/tags/网页/"}]}]}